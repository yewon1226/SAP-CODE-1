## < ABAP 문법 정리 >
</br>

### 1) WITH HEADER LINE
- 내부 테이블 안에 자동으로 한 줄(row)을 나타내는 구조를 생성
- 테이블 이름과 동일한 구조가 만들어져 별도 워크에어리어 없이 한 줄 데이터를 바로 사용 가능
  - `itab[]` → 테이블 전체
  - `itab` → 테이블의 헤더라인(한 줄)
```abap
DATA: <itab> TYPE TABLE OF <structure> WITH HEADER LINE.
```
- INTO 절 생략 가능
```abap
LOOP AT gt_hline.
  WRITE: gt_hline-carrid.  "헤더 라인 사용 덕분에 INTO 생략 가능
ENDLOOP.
```
- MODIFY 시 자동 참조
```abap
gt_hline-percentage = gt_hline-seatsocc * 100 / gt_hline-seatsmax.
MODIFY gt_hline.  "워크 에어리어(gt_hline)를 테이블에 적용
```
- 실습
```abap
" Header Line이 있는 Internal table 선언
" gt_hline은 Structure, gt_hline[] 은 Itab 이 된다.
DATA: gt_hline TYPE TABLE OF bc400_s_flight WITH HEADER LINE.

SELECT carrid connid fldate seatsmax seatsocc
  FROM sflight
  INTO TABLE gt_hline[]
  WHERE carrid = 'AA'.

IF ( sy-subrc = 0 ).
  LOOP AT gt_hline.       " INTO 절 생략 가능
    gt_hline-percentage = gt_hline-seatsocc * 100 / gt_hline-seatsmax.
    MODIFY gt_hline.
  ENDLOOP.
ENDIF.

SORT gt_hline[] BY connid ASCENDING
                   percentage DESCENDING.

CLEAR gt_hline.
LOOP AT gt_hline WHERE percentage > 80.
  WRITE:/ gt_hline-carrid,
          gt_hline-connid,
          gt_hline-fldate,
          gt_hline-seatsmax,
          gt_hline-seatsocc,
          gt_hline-percentage.
ENDLOOP.
```
</br>
</br>

### 2) FOR ALL ENTRIES IN
- 내부 테이블의 값들을 기준으로 DB에서 데이터를 조회
- 다중 조건 가능
- 내부 테이블이 비어있으면 전체 조회되므로 체크 필요
- `FOR ALL ENTRIES IN <내부 테이블>` → 어떤 내부 테이블의 값들을 조건으로 쓸지 지정
- `WHERE <DB필드> = <내부테이블-필드>` → 실제 비교 조건 작성
```abap
SELECT <필드>
  FROM <DB 테이블>
  INTO <내부 테이블 또는 변수>
  FOR ALL ENTRIES IN <내부 테이블>
  WHERE <조건 = 내부테이블-필드>.
```
```abap
IF gt_data IS NOT INITIAL.
  SELECT *
    FROM sflight
    INTO TABLE @gt_result
    FOR ALL ENTRIES IN @gt_data
    WHERE carrid = @gt_data-carrid.
ENDIF.
```
</br>
</br>

### 3) WHERE 조건
- 조건에 맞는 데이터만 조회할 때 사용
  
| 연산자 | 설명 |
|---|---|
| `=`, `<`, `>`, `<=`, `>=`, `<>` | 비교 연산자 (같다, 크다, 작다 등) |
| `IN (dobj1, dobj2, …)` | 값 목록에 포함 여부 |
| `BETWEEN dobj1 AND dobj2` | 범위 내 값 포함 |
| `LIKE dobj1` | 패턴 매칭 (`%`, `_` 사용) |
| `IN seltab` | 내부 테이블 값 포함 여부 |
| `IS [NOT] NULL` | NULL 여부 검사 |
| `AND`, `OR`, `NOT` | 논리 조건 결합 / 부정 |

</br>

```abap
DATA: lt_sflight TYPE TABLE OF sflight,
      lt_spfli   TYPE TABLE OF spfli.

SELECT * FROM sflight
  INTO TABLE @lt_sflight
  WHERE seats > 10.
" 결과 예시: seats가 11, 20, 50 등 10 초과인 항공편 조회

SELECT * FROM sflight
  INTO TABLE @lt_sflight
  WHERE carrid IN ('AA','LH').
" 결과 예시: carrid가 'AA' 또는 'LH'인 항공편 조회

SELECT * FROM spfli
  INTO TABLE @lt_spfli
  WHERE cityfrom LIKE 'S%O'.
" 결과 예시: cityfrom이 'S'로 시작하고 'O'로 끝나는 도시 조회
" 예: 'SEOUL', 'STOCKHOLM'

DATA: gt_carriers TYPE TABLE OF sflight-carrid.
" (gt_carriers 내부에 carrid 값이 들어있다고 가정)
SELECT * FROM sflight
  INTO TABLE @lt_sflight
  WHERE carrid IN @gt_carriers.
" 결과 예시: 내부 테이블 gt_carriers에 포함된 carrid의 항공편 조회

SELECT * FROM sflight
  INTO TABLE @lt_sflight
  WHERE seats IS NOT NULL.
" 결과 예시: seats 컬럼 값이 NULL이 아닌 모든 항공편 조회

SELECT * FROM sflight
  INTO TABLE @lt_sflight
  WHERE carrid = 'AA' AND seats > 10.
" 결과 예시: carrid가 'AA'이고 seats가 10 초과인 항공편 조회
```
</br>
</br>

### 4) SELECT: ORDER BY & DISTINCT
### 4-1) SELECT … ORDER BY
- 조회 결과를 특정 필드 기준으로 정렬
```abap
SELECT <필드1> <필드2> … 
  FROM <테이블>
  INTO TABLE @<내부테이블>
  WHERE <조건>
  ORDER BY <필드> [ASCENDING|DESCENDING].
```
```abap
DATA: lt_sflight TYPE TABLE OF sflight.

" 프라이머리 키(CARRID + CONNID) 순서대로 조회
SELECT carrid connid seats
  FROM sflight
  INTO TABLE @lt_sflight
  ORDER BY PRIMARY KEY.
" 결과: carrid 오름차순, 동일 carrid 내에서는 connid 오름차순 조회
```


### 4-2) SELECT DISTINCT
- 중복을 제거하고 유일한 값만 조회
```abap
SELECT DISTINCT <필드1> <필드2> …
  FROM <테이블>
  INTO TABLE @<내부테이블>
  WHERE <조건>.
```
```abap
DATA: gt_flight TYPE TABLE OF sflight.

SELECT DISTINCT carrid connid
  FROM sflight
  INTO TABLE @gt_flight
  WHERE seatsocc > 200.
" 결과: seatsocc > 200인 항공편 중 carrid+connid 조합이 중복 없이 조회
```
</br>
</br>

### 5) DELETE ADJACENT DUPLICATES
- 정렬된 내부 테이블에서 연속된 중복 레코드를 삭제
- 중복 기준 필드를 지정 가능
- `<내부테이블>` → 중복을 제거할 내부 테이블
- `COMPARING` → 특정 필드 기준으로 중복 제거 (생략하면 전체 구조 기준)
```abap
DELETE ADJACENT DUPLICATES FROM <내부테이블>
  [COMPARING <필드1> <필드2> ...].
```
```abap
DATA: it_numbers TYPE TABLE OF i,
      wa_number  TYPE i.

APPEND 10 TO it_numbers.
APPEND 10 TO it_numbers.
APPEND 20 TO it_numbers.
APPEND 20 TO it_numbers.
APPEND 30 TO it_numbers.

DELETE ADJACENT DUPLICATES FROM it_numbers.
```
</br>
</br>

### 6) cl_demo_output=>display
- 내부 테이블 또는 구조를 간단히 화면에 출력
```abap
cl_demo_output=>display( <itab> ).
```
```abap
IF sy-subrc = 0.
  cl_demo_output=>display( gt_result ).
ENDIF.
```

</br>
</br>

---

</br>

## < ABAP 개념 정리 >
</br>

### Selection Screen 주요 특징
- 실행 버튼 누르면 DB 테이블에서 조건에 맞는 데이터 추출
- 다국어 처리 지원
- 입력 값 타입 자동 체크 (예: 숫자, 날짜, 문자열)
- 입력 값 저장 및 재사용 가능
- 복잡한 조건(범위, 다중 선택 등) 처리 가능
- 입력 값 범위 및 형식 제한 기능 (F4 도움말 등)
</br>

### 파라미터 선언 예시 및 특징
- `TYPE` 뒤에 올 수 있는 타입은 표준 타입 혹은 데이터 딕셔너리 필드 타입
- 파라미터는 단일 입력값 받음
- 입력 필드의 데이터 타입이 자동 적용됨 (숫자, 문자열 등)
```abap
PARAMETERS: pa_car TYPE s_carr_id.
PARAMETERS: pa_car TYPE spfli-carrid.
```
</br>

### Select-Options 관련 주요 사항
- 선언 시 `TYPE`이 아니라 `FOR` 키워드 사용
```abap
SELECT-OPTIONS: so_car FOR spfli-carrid.
```
- FOR 뒤에는 이미 선언된 데이터 오브젝트나 DDIC 필드명을 사용
- Select-options는 내부적으로 테이블(ITAB) 구조를 가짐
- Select-options 로 입력된 범위값을 사용할 때는 IN 키워드 사용
- 만약 so_car가 빈 값이면 조건 없이 전체 조회됨
```abap
SELECT * FROM spfli WHERE carrid IN so_car.
```
</br>

### ITAB 필드 정의

| 필드명 | 의미 |
|--------|------|
| SIGN   | 포함(I, Include) 또는 제외(E, Exclude) |
| OPTION | 연산자 (EQ = 같음, BT = 범위, GE = 이상 등) |
| LOW    | 범위 시작값 (From) |
| HIGH   | 범위 끝값 (To, BT 연산자에서 사용) |

- 예시

| 조건 설명                          | SIGN | OPTION | LOW  | HIGH |
|-----------------------------------|------|--------|------|------|
| LH 값만 포함                        | I    | EQ     | LH   |      |
| AA부터 DL까지 포함                  | I    | BT     | AA   | DL   |
| BA 값 제외                          | E    | EQ     | BA   |      |

</br>
</br>

---

</br>

## < 실습 코드 >
</br>

### 실습 1
- SELECT-OPTIONS와 SELECT 이용해서 LOOP로 출력하기
```abap
DATA: gs_data TYPE SBOOK,
      gt_data LIKE TABLE OF gs_data.

PARAMETERS: pa_car TYPE S_CARR_ID DEFAULT 'AZ',
            pa_con TYPE S_CONN_ID DEFAULT '0555'.

SELECT-OPTIONS: so_dat FOR gs_data-FLDATE.


SELECT * FROM SBOOK
  INTO CORRESPONDING FIELDS OF TABLE gt_data
  WHERE CARRID = pa_car
    AND CONNID = pa_con
    AND FLDATE IN so_dat.

LOOP AT gt_data INTO gs_data.
  WRITE:/ gs_data-CARRID, gs_data-CONNID, gs_data-FLDATE,
          gs_data-BOOKID, gs_data-CUSTOMID, gs_data-CUSTTYPE.
ENDLOOP.
```
</br>
</br>

### 실습 2
- FOR ALL ENTRIES IN 사용해서 출력
```abap
DATA: gt_data TYPE TABLE OF sflight,
      gt_result TYPE TABLE OF sflight.

SELECT carrid
  FROM sflight
  INTO CORRESPONDING FIELDS OF TABLE gt_data
  WHERE carrid IN ('AA', 'AZ', 'LH').
  " carrid가 'AA', 'AZ', 'LH'에 포함되는 레코드만 조회

IF gt_data IS INITIAL.
  SORT gt_data BY carrid.   " carrid 오름차순 정렬
  " gt_data에 carrid가 중복된 레코드는 삭제
  " => 중복 레코드가 존재하면, 자동 제거되지 않고 DB 요청이 들어감
  " => 그만큼 속도가 늦어지는 것이기 때문에 SELECT 전애
  " => 정렬 및 중복제거를 해주는 것이 좋다.
  DELETE ADJACENT DUPLICATES FROM gt_data COMPARING carrid.

  SELECT * FROM sflight
    INTO CORRESPONDING FIELDS OF TABLE gt_result
    FOR ALL ENTRIES IN gt_data
    WHERE carrid = gt_data-carrid.
      " AND connid = gt_data-connid. 여러 필드 가능

    " 주의! FOR ALL ~ 로 사용하는 gt_data가 비어있으면
    " 테이블 전체를 조회하므로. 대량 데이터의 Table일 경우
    " 시스템이 다운될 수 있음. 따라서 gt_data가 있는 경우를
    " 체크해주는 것이 안전하다.

  IF sy-subrc = 0.
    cl_demo_output=>display( gt_result ).
  ENDIF.
ENDIF.
```
</br>
</br>

### 실습 3
- FOR ALL ENTRIES IN 사용해서 조회된 항공사 목록을 이용해 항공편 목록 출력
```abap
DATA: gs_data   TYPE scarr,
      gt_data   LIKE TABLE OF gs_data,
      gt_result TYPE TABLE OF sflight.

SELECT-OPTIONS: so_car FOR gs_data-carrid.

SELECT * FROM scarr
  INTO CORRESPONDING FIELDS OF TABLE gt_data
  WHERE carrid IN so_car.

SELECT * FROM sflight
  INTO CORRESPONDING FIELDS OF TABLE gt_result
  FOR ALL ENTRIES IN gt_data
  WHERE carrid = gt_data-carrid.

cl_demo_output=>display( gt_result ).
```
</br>
</br>

### 실습 4
