# 프로그래핑 문법과 로직 (11.14)
</br>

### SAP GUI 기본 구성 요소
1. Command Field (커맨드필드)
   
   - TCODE(트랜잭션 코드) 입력하는 칸
2. Title Bar (타이틀바)
   - 현재 화면의 제목 표시
3. Application Toolbar (어플리케이션 툴바)
   - 프로그램 기능 버튼들이 위치하는 영역
</br>

<img width="463" height="363" alt="image" src="https://github.com/user-attachments/assets/cd48b735-5b5d-4984-9c00-e7dc92999f3f" />

</br>
</br>

### TCODE / 명령어
- `/N` : 현재 TCODE 정료
- `/NXXXX` : 현재 창에서 TCODE 종료
- `/ON` : 새창 열기
- `/OXXXX` : 새창열고 TCODE 실행
- `/ne` : 모든 창닫고 로그오프
- `/nend` : 팝업으로 확인 후 닫고 로그오프
- `/i` : 현재 화면 닫기
</br>

### TCODE 생성 방법
- `SE93` 검색 -> Create (생성) 버튼을 클릭 -> `Program and selection screen (report transaction)`을 선택함
  - `Program and dynpro` : 화면(Screen/Dynpro) 번호를 지정하여, 그 화면부터 상호작용을 시작
  - `Program and selection screen` : 선택 화면(Selection Screen)을 먼저 띄워서 사용자에게 조건을 입력받고 결과를 출력
  - `Method of a class`: ABAP Class의 특정 메서드(Method)를 실행하여 비즈니스 로직을 시작
  - `Transaction with parameters` : 기존 TCODE를 실행하되, 특정 파라미터를 미리 세팅하여 자동 실행
- 생성한 TCODE를 창에 입력하면 이동. ex) `YPROGB03_ASSIGNMENT1`
    
  <img width="370" height="368" alt="image" src="https://github.com/user-attachments/assets/c0b9c4cf-b765-4e4a-b6f5-02971aa88c8d" />

</br>
</br>

### SAP Input Help
- 특정 입력 필드에서 값 목록을 보여주는 기능을 총칭
- 모두 같은 개념으로 F4 키를 누르면 뜨는 팝업
  
- 1) Search Help
  2) Value Help
  3) Possible Entry
  4) F4 Help
  5) Input Help
</br>

### ABAP 기본 개념
- SAP 시스템에서 사용하는 프로그래밍 언어
- 초기에는 COBOL 기반의 절차지향 언어, 이후 객체지향(OOP) 기능 추가
- 소문자 구분 없음 → 내부적으로는 대문자로 처리
- 단, 문자열(‘HQ0’) 내부의 값은 자동 대문자 변환이 되지 않음 → 직접 대문자로 입력해야 함
- 옵션을 통해 소문자 값 전달도 가능
</br>

### SAP ERP란?
- 기업의 다양한 데이터와 프로세스를 통합하여 관리하는 시스템
</br>

### SAP 주요 모듈
- FI(financial accounting) : 재무회계 관리를 위한 모듈. 회사 데이터 처리와 재무 보고서 작성
-	CO(controlling) : 내부 회계 및 경영 회계를 관리, 비용관리/수익성분석/예산처리
-	MM (matrials managements) : 자재 관리하는 모듈, 구매/입고/조회를 관리함
-	PP(product planning) : 제조 및 생산과정을 관리하고 계획
-	SD(sales and distribution) : 판매와 유통관리를 위한 모듈, 주문/배송/물류 관리
-	HR(Human Resource) : 인사관리를 위한 모듈. 인사정보/급여. 교육관리
</br>

### SAP 시스템 버전
1. SAP ECC (ERP Central Component)
   
   - 기존 SAP Business Suite의 핵심 ERP
   - R/3 기반 ERP 시스템
3. SAP S/4 HANA (2015~)
   
   - SAP의 최신 ERP 제품
   - In-Memory DB인 SAP HANA 기반으로 성능 대폭 향상
   - 실시간 분석 및 처리 가능
</br>

### SAP 3-Tier 구조
1) Presentation Layer (프레젠테이션 계층)
   
   - 사용자가 SAP를 사용하는 화면(UI)
   - SAP GUI, 웹(Fiori) 등이 해당

3) Application Layer (애플리케이션 계층)
   - ABAP 프로그램이 실행되는 계층
   - 비즈니스 로직 처리 (주문 생성, 재고 계산 등)
   - Presentation ↔ Database 사이에서 중간 역할

3) Database Layer (데이터베이스 계층)
   - 모든 SAP 데이터를 저장하는 곳
   - HANA, Oracle 등 DBMS 사용
</br>

### SAP Client 구성
- SAP는 여러 Client를 두어 데이터를 독립적으로 관리
- 일반 Client 번호 예시:
  
  - 100 : 개발(DEV)
  - 200 : 품질(QAS)
  - 300 : 운영(PRD)
- Cross-Client(800번): 개발·품질 공용 설정, 클라이언트 구분 없이 적용
</br>

### SAP Object 종류
- Standard Object: SAP에서 제공하는 기본 오브젝트(프로그램, 테이블 등)
- CBO (Customer Bolt-On): 고객사 개발 오브젝트(프로그램, 테이블, 기타)
  
  - CBO(Customer Bolt-On) 네이밍 규칙
    
    - SAP에서 새로 개발하는 오브젝트는 Z 또는 Y로 시작 (이관 가능)

      - Z: 일반 커스텀 오브젝트
      - Y: 회사 내부 표준 오브젝트
   - 예시
     - 패키지: ZPACB##_01
     - 프로그램: /OSE09, /NSE09
       
       - O : 새로운 SAP GUI 창(세션)을 열고 트랜잭션 실행
       - N : 현재 세션에서 트랜잭션 실행
</br>

### 패키지(Package)와 로컬 객체(Local Object)
1) Package
   
   - 이관 대상 Object를 담는 패키지
   - 개발 완료 후 다른 서버(QAS, PRD)로 이관 가능

2) Local Object ($TMP)
   
   - 개인 계정에서 사용하는 임시 패키지
   - 이관 불가, 개인 테스트용
</br>

### SAP 주요 개발 툴 (T-Code)
- SAP 개발 시 자주 사용하는 트랜잭션 코드(T-Code)와 기능 정리

| T-Code | 기능 |
|--------|-------|
| **SE51** | Screen Painter (화면 개발) |
| **SE41** | Menu Painter (메뉴 개발) |
| **SE38** | ABAP Editor (프로그램 작성) |
| **SE37** | Function Builder (함수 모듈 개발) |
| **SE24** | Class Builder (클래스 개발) |
| **SE11** | ABAP Dictionary – **가장 중요** (테이블, 도메인, 뷰 등 데이터 정의) |
| **SE80** | Object Navigator (ABAP Workbench) – **가장 중요**, 오브젝트 통합 관리 |
| **SE93** | 트랜잭션 코드(T-Code)를 생성·조회·관리하는 화면 |

</br>

### Transport(이관) 흐름
- 개발 → 품질 → 운영 순으로 안전하게 이동
- **Tip:** STMS(Transaction Management System)에서 **안쪽 오브젝트부터 순서대로 릴리즈** 후 이관
- 릴리즈 = 이관하기 전에 ‘개발 완료’라고 확정하는 버튼

| 흐름 | 설명 | 도구 |
|------|------|------|
| 개발(DEV) → 품질(QAS) | 개발 완료 후 기능 검증 | CTS (Change and Transport System) |
| 품질(QAS) → 운영(PRD) | 테스트 완료 후 실제 업무 환경 적용 | CTS |
<img width="451" height="231" alt="image" src="https://github.com/user-attachments/assets/da843ad7-23e0-42f0-ae7e-474d71d2361f" />

</br>
</br>

- 순서대로 코드 문법 체크 => 활성화(activate) => 디버그
<img width="508" height="43" alt="image" src="https://github.com/user-attachments/assets/552be000-918d-4fbd-a0cd-735d7deef1bd" />
</br>
</br>

- 상위 레벨에 어디에 들어가 있는지 파악 가능
<img width="506" height="47" alt="image" src="https://github.com/user-attachments/assets/3e423dce-8130-46d1-8f1a-a9f0e6a42f96" />
</br>
</br>
</br>
</br>


### ABAP 프로그램 유형
- SAP에서 자주 사용하는 ABAP 프로그램 유형(Type)과 특징 정리

| Type | 용도 | 특징 |
|------|------|------|
| **1 (Report Program)** | 조회용(R) | 데이터를 조회하고 리포트 출력 (R 기능) |
| **M (Screen Program)** | 화면 기반 CRUD | 생성, 조회, 수정, 삭제 기능 가능 |
</br>

---
</br>

## < ABAP 기본 문법 >
- 모든 문장은 마지막에 마침표(.)
- 문자열은 반드시 홑따옴표 `' '` 사용
  
  - `" "`(쌍따옴표)는 문자열 아님 → 주석
</br>

**1) PARAMETERS**
- 사용자로부터 입력값을 받기 위한 키워드
- 타입을 안 적으면 기본 타입은 C(문자) 길이 1
- 옵션들은 대부분 순서에 상관없이 쓸 수 있음
```abap
PARAMETERS <변수명> TYPE <데이터타입>.
```
```abap
PARAMETERS pa_name TYPE string.  " 문자열 입력값 받음
PARAMETERS pa_num  TYPE I.       " 정수형 입력값 받음
PARAMETERS pa_num  TYPE C LENGTH 4.
PARAMETERS pa_num(4)  TYPE C.      " 위와 같은 코드
```
</br>

**1-1) PARAMETERS 옵션 - OBLIGATORY**
- 필수 입력값. 사용자가 값을 입력하지 않으면 프로그램 실행 불가.
```abap
PARAMETERS pv_data TYPE c OBLIGATORY.      " pv_data는 반드시 입력해야 함
```
</br>

**1-2) PARAMETERS 옵션 - DEFAULT '값'**
- 해당 파라미터가 처음 실행될 때 자동으로 기본값을 넣어줌.
```abap
PARAMETERS pv_data TYPE c DEFAULT 'Hi'.      " 프로그램 실행 시 pv_data에 자동으로 'Hi' 값이 들어감
```
</br>

**1-3) PARAMETERS 옵션 - LOWER CASE**
- 소문자 입력 허용.
- 기본적으로 PARAMETERS는 입력값을 대문자로 변환함 → LOWER CASE 사용 시 그대로 유지.
```abap
PARAMETERS pv_data2 TYPE c LOWER CASE.
```
</br>

**1-4) PARAMETERS 옵션 - VISIBLE LENGTH n**
- 입력필드가 화면에 표시되는 길이만 제한.
- 실제 필드 길이와 화면 표시 길이는 다르게 설정 가능.
```abap
PARAMETERS pv_data2(10) TYPE c VISIBLE LENGTH 2.      " 데이터 길이는 10이지만 화면에는 입력창이 2칸만 보임
```
</br>
</br>

**2) WRITE**
- 화면에 값을 출력하는 키워드
```abap
WRITE <값>. 또는 WRITE: <값1>, <값2>.
```
```abap
WRITE 'Hello World!'.       " 문자열 출력
WRITE: 'Hello', pa_name.    " 문자열과 변수 값 함께 출력
WRITE: 'YOUR input: ', pa_num.
WRITE: 'Result: ', gv_result.

WRITE:/ 'Result: ',
      / gv_result,
      / pa_num.             " / + 띄어쓰기 : 줄바꿈 효과가 남
```
</br>
</br>

**3) NEW-LINE**
- 화면 출력 시 줄바꿈
```abap
NEW-LINE.
```
</br>
</br>

**4) DATA**
- 변수를 선언하는 키워드
```abap
DATA <변수명> TYPE <데이터타입>.
```
```abap
DATA gv_result TYPE I.  " 정수형 변수 선언
```
</br>
</br>

**5) MOVE**
- 값을 다른 변수에 할당
```abap
MOVE <원본> TO <대상>.
```
```abap
MOVE pa_num TO gv_result.  " pa_num 값을 gv_result에 복사
```
</br>
</br>

**6) ADD**
- 산술 연산으로 값을 더함
```abap
ADD <숫자/변수> TO <변수>.
```
```abap
ADD 1 TO gv_result.  " gv_result에 1 더하기
```
</br>
</br>

**7) RADIOBUTTON GROUP**
- 동일한 그룹 안에서 하나만 선택 가능한 옵션 버튼
```abap
PARAMETERS pv_rad1 RADIOBUTTON GROUP rad1.      " pv_rad1과 pv_rad2는 같은 그룹(rad1)
PARAMETERS pv_rad2 RADIOBUTTON GROUP rad1.      " 둘 중 한 개만 'X' 값을 가질 수 있음

pv_rad1 RADIOBUTTON GROUP rad1 DEFAULT 'X'.      " 실행 시 기본으로 pv_rad1이 선택됨
```   
</br>
</br>

**8) AS CHECKBOX**
- 체크박스 형태 입력.
- 체크됨 → `'X'`, 체크 안됨 → `' '` (공백)
```abap
PARAMETERS pv_chk AS CHECKBOX.
```
</br>
</br>

**9) 주석(Comment)**
- `"` 또는 `*` 사용
  
  - `"` : 한 줄의 끝까지 주석
  - `*` : 라인 맨 앞에 쓰면 전체 라인을 주석 처리
```abap
PARAMETERS pa_num TYPE I. " 숫자타입 pa_num 입력값 받음
DATA gv_result TYPE I.    " 변수 선언
```
</br>
</br>

---
</br>

## < 실습 코드 >
### 실습 1
```abap
REPORT ZPROGB03_0001.
PARAMETERS pa_num TYPE I. " 숫자타입 pa_num 입력값 받음
DATA gv_result TYPE I.  " 숫자타입 gv_result 변수 선언

MOVE pa_num TO gv_result. " pa_num 값을 gv_result에 넣음

ADD 1 TO gv_result.   " gv_result에 1을 더함

WRITE: 'YOUR input: ', pa_num.  " 문자와 pa_num 값 함께 출력

NEW-LINE. " 줄바꿈

WRITE: 'Result: ', gv_result.   " 문자와 gv_result 값 함께 출력
```
</br>
</br>

### 실습 2
```abap
REPORT ZBC400_03_HELLO.

PARAMETERS pa_name TYPE string.

WRITE 'Hello World!'.

NEW-LINE.

WRITE: 'Hello', pa_name.
```
</br>
</br>

### 실습 3
```abap
REPORT yprogb03_0002.

PARAMETERS input TYPE I.
ADD 10 TO input.
WRITE input.
```
</br>
</br>

### 실습 4
```abap
PARAMETERS: pv_data(10)  TYPE c OBLIGATORY  DEFAULT 'Hi',
            pv_data2(10) TYPE c LOWER CASE VISIBLE LENGTH 2.

" OBLIGATORY : 필수값 처리
" LOWER CASE : 소문자 허용
" DEFAULT : 기본값 적용
" VISIBLE LENGTH : 화면에 보여지는 입력필드의 길이 저장

PARAMETERS: pv_rad1
            RADIOBUTTON GROUP rad1 DEFAULT 'X',
            pv_rad2
            RADIOBUTTON GROUP rad1,
            pv_chk  AS CHECKBOX.

WRITE: pv_data, pv_data2.

NEW-LINE.

WRITE: 'Radio, Check', pv_rad1, pv_rad2, pv_chk.
```

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (11.17).md
</br>

### 데이터 요소(Data Element) 타입으로 올 수 있는 3가지 종류
- `DATA`는 메모리와 값을 갖는 변수 생성, `TYPE`은 값 없이 타입만 정의
  
#### 1) Standard Data Type
   - SAP가 제공하는 기본 데이터 타입
      #### 1-1) Complete Type
      | Type       | 설명                                                                 |
      |------------|----------------------------------------------------------------------|
      | D          | 날짜(Date)                                                             |
      | T          | 시간(Time)                                                             |
      | I          | 4바이트 정수(Integer 4)                                               |
      | INT8       | 8바이트 정수(Integer 8)                                               |
      | F          | 부동 소수점(Float)                                                     |
      | STRING     | 가변 길이 문자열(Variable-length string), 사용자가 입력하는 만큼 동적 할당됨 |
      | XSTRING    | 가변 길이 이진(Binary) 문자열, 사용자가 입력하는 만큼 동적 할당됨      |
      | DECFLOAT16 | 16자리 부동 소수점(decimal floating)                                  |
      | DECFLOAT34 | 34자리 부동 소수점(decimal floating)                                  |
      
      #### 1-2) Incomplete Type
      | Type | 설명                                                      |
      |------|-----------------------------------------------------------|
      | C    | 문자(Character), 길이 지정 필요                            |
      | N    | 숫자형 문자(Numeric character), 길이 지정 필요              |
      | X    | 16진수(Hexadecimal), 길이 지정 필요                       |
      | P    | 고정소수점. Packed Decimal(BCD), 소수점 위치 지정 필요                 |
     
        - P TYPE
        - `총 자릿수 = LENGTH * 2 - 1`
          - LENGTH : P 타입 선언 시 지정하는 바이트 수
          - *2 → 1바이트 = 2자리 숫자를 저장
          - -1 → 마지막 절반 바이트는 부호(+, -)용
          - 총 자릿수가 DECIMALS 자릿수보다 작으면 에러
          
            ```abap
            DATA lv_amount TYPE P LENGTH 5 DECIMALS 2.
            ```
            </br>
      
#### 2) Local Type
   - 특정 프로그램 내에서 정의하여 사용하는 타입
   - 다른 프로그램에서는 사용할 수 없음
       #### 2-1) TYPES
       - 로컬 타입을 정의할 때 사용하는 키워드, 실제 변수를 만드는 것이 아님
        </br>
         
       ```abap
       TYPES <타입명> TYPE <데이터타입/구조>.
       ```
       ```abap
       TYPES tv_c_type TYPE C LENGTH 8.
       TYPES tv_n_type TYPE N LENGTH 5.
       TYPES tv_p_type TYPE P LENGTH 3 DECIMALS 2.
    
       TYPES ty_employee TYPE string.         " 문자열 타입 정의
       DATA lv_emp_name TYPE ty_employee.     " 타입 사용 변수 선언
       ```

       #### 2-2) LIKE
       - 기존 변수나 데이터 요소의 타입과 속성을 그대로 가져와 새로운 변수 선언
        </br>
         
       ```abap
       DATA <새변수> LIKE <기존변수|데이터요소>.
       ```
       ```abap
       DATA gv_amount TYPE P LENGTH 7 DECIMALS 2.   " 기존 변수 선언
       DATA lv_amount LIKE gv_amount.               " gv_amount와 같은 타입으로 선언
       ```
     </br>
  
#### 3) Global Data Type
   - SE11에서 정의되어 모든 프로그램에서 사용 가능한 타입
   - 데이터 요소, 구조, 테이블 타입 등으로 활용 가능

     #### 3-1) Data Element Type
      - 하나의 값(필드 하나)을 표현하는 타입
      - 길이/형식 같은 기본 속성을 정의함
   
      #### 3-2) Structure Type
      - 여러 필드가 모여 하나의 덩어리를 이루는 타입
      - 하나의 레코드(행) 같은 구조
        
      #### 3-3) Table Type (Internal Table)
      - 동일한 구조를 여러 개 담는 “내부 테이블”을 위한 타입
      - 여러 행을 저장하는 컬렉션 형태

</br>
</br>

### ABAP 변수와 타입 선언: 초기값 vs 기본값 정리
#### 1) 초기값 (Initial Value)
- 모든 변수에는 타입에 따라 자동으로 존재하는 값
- 변수 값을 초기화하면 이 값으로 초기값이 변경됨
```abap
DATA gv_count TYPE I.   " 초기값 0 자동 존재
DATA gv_char  TYPE C.   " 초기값 공백
```

#### 2) 기본값 (Default Value)
- 변수 선언 시 임의로 지정한 값
- 초기값과 달리 개발자가 지정한 값으로 변수 시작
```abap
DATA gv_count TYPE I VALUE 10.  " 기본값 10
DATA gv_name  TYPE C LENGTH 5 VALUE 'ABAP'.  " 기본값 'ABAP'
```
</br>
</br>

---

</br>

## < ABAP 기본 문법 >
#### 1) VALUE
- 변수를 선언하면서 초기값을 지정할 때 사용
</br>
 
```abap
DATA <변수명> TYPE <데이터타입> VALUE <초기값>.
```
```abap
DATA gv_count TYPE I VALUE 10.               " 정수형 변수 초기값 10
DATA lv_name  TYPE string VALUE 'ABAP'.      " 문자형 변수 초기값 'ABAP'
```
</br>

#### 2) CONSTANTS
- 변하지 않는 값(상수)을 선언할 때 사용
- 선언 후 값 변경 불가
```abap
CONSTANTS <상수명> TYPE <데이터타입> VALUE <값>.
```
```abap
CONSTANTS: gc_str TYPE string VALUE 'OKOK',
           gc_num TYPE I VALUE 100.
```
</br>

#### 3) WRITE
- (필드) : 필드 길이에 맞춰 출력
- text-001 : SE51에서 정의한 텍스트 요소, 자리 표시자(&1, &2) 사용 가능
- text-001 다국어 처리 방법 : `Goto → Translation 선택 -> 원하는 언어(EN/KO) 문자열 입력 → 저장 -> 실행 시 환경 언어에 맞춰 자동 출력`
```abap
WRITE: 'My selected variable : '(GRE),
       gc_num,
       text-001.
```
- WRITE 구문에서 필드 길이 지정
- (n) : 출력 시 지정한 길이만큼 공간 확보
```abap
WRITE: (10) gv_data,   " gv_data 값을 10자리 폭으로 출력
       (8)  gv_data2.  " gv_data2 값을 8자리 폭으로 출력
```
</br>

#### 4) MOVE
- 값을 다른 변수에 대입할 때 사용하는 구문(현재는 `=` 와 동일하게 동작)
```abap
MOVE <source> TO <target>.
```
```abap
DATA gv_num1 TYPE I VALUE 10.
DATA gv_num2 TYPE I.

MOVE gv_num1 TO gv_num2.     " gv_num2 = 10
```
</br>

#### 5) CLEAR
- 변수 또는 내부 테이블의 값을 초기값으로 리셋할 때 사용 (타입별 초기값으로 설정됨)
```abap
CLEAR <변수명>.
```
```abap
DATA gv_num TYPE I VALUE 10.
DATA gv_text TYPE c LENGTH 5 VALUE 'ABAP'.

CLEAR gv_num.    " 결과: 0
CLEAR gv_text.   " 결과: '     ' (공백)
```
</br>

#### 6) STRLEN
- 문자열의 길이(문자 수)를 구할 때 사용
```abap
<변수> = STRLEN( <문자열> ).
```
```abap
DATA gv_text TYPE string VALUE 'ABAP'.
DATA gv_len  TYPE i.

gv_len = STRLEN( gv_text ).     " 결과: 4
```
</br>

#### 7) IF문
- 조건에 따라 코드 블록을 실행할 때 사용
- 괄호 양 옆에 띄어쓰기 필수
  
  - 비교 연산자 : EQ (=), NE (≠), GT (>), LT (<), GE (≥), LE (≤), = (같다), <> (같지 않다), > (크다), < (작다), >= (크거나 같다), <= (작거나 같다)
  - 논리 연산자 : AND (그리고), OR (또는), NOT (부정)
  - 초기값 확인 : IS INITIAL (초기값인지 확인), IS NOT INITIAL (초기값이 아닌지 확인)
```abap
IF <조건1> AND <조건2>.
    " 두 조건 모두 참일 때 실행
ELSEIF <조건1> OR <조건3>.
    " 조건1 또는 조건3 중 하나라도 참이면 실행
ELSEIF NOT gv_flag.
    " gv_flag가 FALSE일 때 실행
ELSEIF gv_var IS NOT INITIAL.
    " gv_var가 초기값이 아닐 때 실행
ELSE.
    " 위 조건이 모두 아니면 실행
ENDIF.
```
```abap
DATA gv_num1 TYPE i VALUE 10.
DATA gv_num2 TYPE i VALUE 0.
DATA gv_flag TYPE abap_bool VALUE abap_false.
DATA gv_text TYPE string.

IF gv_num1 > 5 AND gv_num2 = 0.
    WRITE '조건 1과 2 모두 만족'.
ELSEIF gv_num1 = 5 OR gv_num2 = 1.
    WRITE '조건 1 또는 2 만족'.
ELSEIF NOT gv_flag.
    WRITE 'gv_flag가 FALSE'.
ELSEIF gv_text IS NOT INITIAL.
    WRITE 'gv_text 값 있음'.
ELSE.
    WRITE '모든 조건 불만족'.
ENDIF.
```
</br>

#### 8) CASE문
- 하나의 변수 값에 따라 여러 경우를 처리할 때 사용
```abap
CASE <변수>.
    WHEN <값1>.
        <실행문>.
    WHEN <값2>.
        <실행문>.
    WHEN OTHERS.
        <실행문>.
ENDCASE.
```
```abap
DATA gv_code TYPE c LENGTH 1 VALUE 'B'.

CASE gv_code.
    WHEN 'A'.
        WRITE 'Apple'.
    WHEN 'B'.
        WRITE 'Banana'.
    WHEN OTHERS.
        WRITE 'Unknown'.
ENDCASE.
```
</br>

#### 9) MESSAGE
- 프로그램 실행 중 사용자에게 알림, 경고, 오류 등을 출력
```abap
MESSAGE '<메시지 내용>' TYPE '<메시지 타입>'.
```
```abap
MESSAGE '나이를 입력해주세요' TYPE 'E'.  " 오류 메시지
```

</br>
</br>

---
</br>

## < 연산자(Operators) >
- ABAP에서 사용되는 기본 산술 연산자
```abap
+   : 더하기
-   : 빼기
*   : 곱하기
/   : 나누기
**  : 지수(제곱) → 2 ** 3 = 8
DIV : 정수 나눗셈의 몫
MOD : 나머지
```
```abap
DATA a TYPE i VALUE 10.
DATA b TYPE i VALUE 3.
DATA r TYPE i.

r = a + b.      " 13
r = a ** b.     " 1000 (10의 3승)
r = a DIV b.    " 3   (몫)
r = a MOD b.    " 1   (나머지)
```
</br>

### 내장함수
- `abs()` : 숫자의 절대값을 반환
- `strlen()` : 문자열 길이를 반환
- `sqrt()` : 숫자의 제곱근을 반환
- `ipow()` : 정수 거듭제곱 계산 (base^exp)
```abap
DATA: gv_num TYPE I,
      gv_len TYPE string,
      gv_sqrt TYPE I,
      gv_ipow TYPE I.

gv_num = abs( -20 ).
gv_len = strlen( 'Hello World' ).
gv_sqrt = sqrt( abs( 9 ) ).
gv_ipow = ipow( base = 5 exp = 3 ).

write:/ '절대값 abs : ', gv_num,     " 20
      / '문자열길이 len : ', gv_len,  " 11
      / '제곱근 sqrt : ', gv_sqrt,   " 3
      / '지수 ipow : ', gv_ipow.    " 125
```
</br>

### 문자열 처리 함수
- `&&` : 두 문자열을 간단히 이어 붙일 때 사용.
- `CA` : 왼쪽 문자열에 오른쪽 문자열의 문자 중 하나라도 포함되어 있으면 TRUE. 대소문자 구분함.
- `CONCATENATE` : 여러 문자열을 순서대로 연결. `SEPARATED BY`로 각 문자열 사이에 넣을 구분자 지정 가능.
```abap
DATA lv_result TYPE string.
lv_result = 'Hello' && ' World'.    " 결과: 'Hello World'

DATA lv_str TYPE string.
lv_str = 'ABC123'.
IF lv_str CA '123'.
  WRITE: / '숫자를 포함함'.
ENDIF.

DATA: lv_text1 TYPE string VALUE '여기는 서울',
      lv_text2 TYPE string VALUE '날씨가 맑습니다',
      result   TYPE string.
CONCATENATE lv_text1 '이고' lv_text2 '입니다'
INTO result SEPARATED BY space.
WRITE: / result.
" 결과: '여기는 서울 이고 날씨가 맑습니다 입니다'
```
</br>
</br>

---

</br>

## < 실습 코드 >
### 실습 1
```abap
" 변수 선언 시
" => gv_ 글로벌 Data obj
" => lv_ 로컬 Data obj
" 타입 선언 시
" => tv_ : Type value
" 파라미터 선언 시
" => pv_ : 첫 글자에 Parameter 약자 P
" 상수 선언 시
" => gc_ : 첫 글자에 Constants 약자

" 연습
TYPES: tv_char(10) TYPE C,
       tv_dec TYPE P LENGTH 3 DECIMALS 2.

PARAMETERS: pv_data TYPE C LENGTH 3 DEFAULT 'HI'.

DATA: gv_dec TYPE tv_dec,
      gv_date TYPE D,
      gv_char2 TYPE tv_char,
      gv_num TYPE I VALUE 20,
      gv_carrname TYPE S_CARRNAME,
      gv_conn TYPE S_CONN_ID.
DATA: gv_carrname2 LIKE gv_carrname VALUE 'TEST'.

CONSTANTS: gc_str TYPE string VALUE 'OKOK',
           gc_num TYPE I VALUE 100.

WRITE: 'My selected variable : '(GRE),
       gc_num,
       text-001.

" Message Class / Text symbols 를 사용하여 메세지 관리를 하는데,
" Text symbols 에서는 변수 사용할 수 없음
" 변수 사용하려면 Message Class를 사용하자
```
</br>
</br>

### 실습 2
```abap
PARAMETERS name(10) TYPE C.
WRITE: name, 'trainee can learn ABAP programming.'(GRE).

" GRE 더블클릭해서 Text symbols의 값 trainee can learn ABAP programming. 로 설정 -> Translation 선택 -> 원하는 언어(EN/KO) 문자열 입력 → 저장
```
</br>
</br>

### 실습 3
```abap
PARAMETERS: pa_num1 TYPE i,
            pa_num2 TYPE i.

DATA: gv_result TYPE i.

gv_result = pa_num1 + pa_num2.    " 5 + 2 = 7
gv_result = pa_num1 - pa_num2.    " 5 - 2 = 3
gv_result = pa_num1 * pa_num2.    " 5 + 2 = 7
gv_result = pa_num1 / pa_num2.    " 5 / 2 = 3 -> 정수끼리 나눗셈 후 반올림
gv_result = pa_num1 ** pa_num2.   " 5 ** 2 = 25
gv_result = pa_num1 DIV pa_num2.  " 5 DIV 2 = 2 -> 반올림 없음
gv_result = pa_num1 MOD pa_num2.  " 5 MOD 2 = 1

WRITE:/ gv_result.
*Pretty printer(코드정리) 사용시 Shift + F1
```
</br>
</br>

### 실습 4
```abap
PARAMETERS pa_age TYPE I.

IF pa_age IS INITIAL.
    MESSAGE '나이를 입력해주세요' TYPE 'E'.

ELSEIF pa_age GE 8 AND pa_age LE 13.
    WRITE '초등학생입니다.'.

ELSEIF pa_age GT 13 AND pa_age LE 16.
    WRITE '중학생입니다.'.

ELSEIF pa_age GT 16 AND pa_age LT 20.
    WRITE '고등학생입니다.'.

ELSE.
    WRITE '성인입니다.'.
ENDIF.
```
</br>
</br>

### 실습 5
```abap
PARAMETERS pa_curr TYPE C LENGTH 3.

CASE pa_curr.
  WHEN 'USD'.
    WRITE: '달러를 선택하였습니다.'.
  WHEN 'EUR'.
    WRITE: '유로를 선택하였습니다.'.
  WHEN 'KRW'.
    WRITE: '한화를 선택하였습니다.'.
  WHEN OTHERS.
    MESSAGE 'USD, EUR, KRW 중 하나를 입력하세요' TYPE 'E'.
ENDCASE.
```
</br>
</br>

### 실습 6
```abap
PARAMETERS: pa_check AS CHECKBOX.

CASE 'X'.
  WHEN pa_check.  " 체크박스에 체크 됐을 때
    WRITE: '체크되었습니다'.
  WHEN OTHERS.    " 체크박스에 체크가 안됐을 때
    WRITE: '체크되지 않았습니다.'.
ENDCASE.
```
</br>
</br>

### 실습 7
```abap
PARAMETERS score TYPE I.
PARAMETERS pa_check AS CHECKBOX.

IF ( score LE 100 AND score GE 80 ).
  IF ( pa_check EQ 'X' ).
    WRITE '성적 : A 우수상'.
  else.
    WRITE '성적 : A'.
  ENDIF.
ELSEIF ( score LT 80 AND score GE 60 ).
  WRITE '성적 : B'.
ELSEIF ( score LT 60 AND score GE 40 ).
  WRITE '성적 : C'.
ELSE.
  WRITE '성적 : F'.
ENDIF.
```
```abap
PARAMETERS score TYPE I.
PARAMETERS pa_check AS CHECKBOX.

IF ( score <= 100 AND score >= 80 ).
  IF pa_check EQ 'X'.
    WRITE '성적 : A 우수상'.
  else.
    WRITE '성적 : A'.
  ENDIF.
ELSEIF ( score < 80 AND score >= 60 ).
  WRITE '성적 : B'.
ELSEIF ( score < 60 AND score >= 40 ).
  WRITE '성적 : C'.
ELSE.
  WRITE '성적 : F'.
ENDIF.
```
</br>
</br>

### 실습 8
```abap
PARAMETERS: pa_int1 TYPE i,
            pa_int2 TYPE i,
            pa_op   TYPE c.

TYPES: ty_result TYPE p LENGTH 16 DECIMALS 2.

DATA gv_result TYPE ty_result.


CASE pa_op.
  WHEN '+'.
    gv_result = pa_int1 + pa_int2.
  WHEN '-'.
    gv_result = pa_int1 - pa_int2.
  WHEN '*'.
    gv_result = pa_int1 * pa_int2.
  WHEN '/'.
    IF ( pa_int1 = 0 OR pa_int2 = 0 ).
      MESSAGE '0을 나눌 순 없습니다.' TYPE 'E'.
    ENDIF.
    gv_result = pa_int1 / pa_int2.
  WHEN '%'.
    PERFORM CALC_PERCENTAGE USING pa_int1 pa_int2 CHANGING gv_result.
  WHEN OTHERS.
    MESSAGE '타당하지 않는 연산자입니다.' TYPE 'E'.
ENDCASE.

WRITE: gv_result.

FORM CALC_PERCENTAGE USING VALUE(PV_ACT) TYPE I
                           VALUE(PV_MAX) TYPE I
                     CHANGING VALUE(CV_RESULT) TYPE ty_result.
  IF ( PV_MAX = 0 ).
    MESSAGE '0이 들어올 수 없습니다.' TYPE 'E'.
  ELSE.
    CV_RESULT = ( PV_ACT / PV_MAX ) * 100.
  ENDIF.
ENDFORM.
```

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (11.18).md
</br>

# 반복문

## 📌 ABAP 반복문 관련 시스템 변수

| 시스템 변수 | 기능 / 의미 | 반복문과의 관계 |
|-------------|------------|----------------|
| **sy-subrc** | ABAP 문법 실행 결과 코드 <br> - 0: 성공 / 데이터 존재 <br> - 4: 조건에 맞는 데이터 없음 <br> - 8: 키 조합 오류 | SELECT, 함수, 조건문 실행 후 결과 확인 |
| **sy-dbcnt** | SELECT … ENDSELECT 루프 인덱스 (몇 번째 DB 레코드를 읽었는지) | SELECT 루프에서 자동 증가 |
| **sy-tabix** | 내부 테이블 LOOP 행 번호 | LOOP AT 내부 테이블 반복 시 현재 행 번호 |
| **sy-index** | DO / WHILE 반복문 인덱스 | 일반 반복문(DO, DO n TIMES, WHILE)에서 반복 횟수 |
</br>
</br>

### 1) DO … ENDDO
- 반복 횟수를 지정하지 않으면 무한 반복
- `EXIT`나 `CHECK` 등으로 빠져나와야 함
- `sy-index` 사용 가능
```abap
DO.
  " 반복 코드
ENDDO.
```
```abap
PARAMETERS: pa_cnt TYPE i.

DO.
  IF SY-INDEX > pa_cnt.
    EXIT.
  ENDIF.
  WRITE:/ sy-index.
ENDDO.
```
```abap
DATA lv_cnt TYPE i VALUE 0.

DO.
  lv_cnt = lv_cnt + 1.
  IF lv_cnt > 3.
    EXIT.
  ENDIF.
ENDDO.
```
</br>

### 2) DO n TIMES … ENDDO
- 지정한 n번 반복
- 반복 횟수는 sy-index에 자동 저장됨(1부터 시작)
- `sy-index` 사용 가능
```abap
DO n TIMES.
  " 반복 코드
ENDDO.
```
```abap
PARAMETERS: pa_cnt TYPE i.

DO pa_cnt TIMES.
  WRITE:/ sy-index.
ENDDO.
```
```abap
DO 5 TIMES.
  WRITE: / '횟수:', sy-index.
ENDDO.
```
</br>

### 3) WHILE … ENDWHILE
- 조건이 TRUE일 동안 반복
- 조건이 FALSE가 되면 종료
- `sy-index` 사용 가능
```abap
WHILE 조건.
  " 반복 코드
ENDWHILE.
```
```abap
PARAMETERS: pa_cnt TYPE i.

WHILE sy-index < pa_cnt.
  WRITE:/ sy-index.
ENDWHILE.
```
```abap
DATA lv_i TYPE i VALUE 1.

WHILE lv_i <= 5.
  WRITE: / lv_i.
  lv_i = lv_i + 1.
ENDWHILE.
```
</br>

### 4) SELECT … ENDSELECT
- DB를 row-by-row 방식으로 조회
- SELECT된 각 레코드를 반복 처리
- `sy-dbcnt` 사용 가능
```abap
SELECT <필드목록>                  " <필드목록> : 가져올 컬럼 이름 (예: carrid, connid)
  FROM <테이블명>                  " <테이블명> : DB 테이블 이름 (예: sflight)
  INTO <워크에어리어 변수>          " <워크에어리어 변수> : 데이터를 담을 ABAP 변수/구조
  [WHERE <조건문>]                 " WHERE : 선택 조건 (선택 사항)
  [ORDER BY <정렬필드>].            " ORDER BY : 정렬 조건 (선택 사항)
  
  " 처리 로직 작성 (레코드 하나씩 처리)
  
ENDSELECT.
```
```abap
DATA: gv_carrid TYPE scarr-carrid. " S_CARR_ID랑 동일
" Transparent Table 이라 세부적으로 들어갈 수 있음

" 만약 조건이 없으면 테이블의 전체 건수 만큼 루프문 실행
" 조건이 있으면 조건에 맞는 데이터를 가져옴
SELECT carrid
  INTO gv_carrid
  FROM scarr
  WHERE carrid='AA'.
    " 여기서 데이터 처리 로직 구현
    WRITE:/ sy-dbcnt, gv_carrid.
ENDSELECT.
```
```abap
DATA: wa_sflight TYPE sflight.  " 작업 영역 선언

" sflight 테이블 전체 레코드를 하나씩 읽어서 처리
SELECT * 
  FROM sflight
  INTO wa_sflight.

  WRITE: / wa_sflight-carrid, wa_sflight-connid, wa_sflight-fldate.

ENDSELECT.
```
</br>

### 5) LOOP AT … ENDLOOP
- 내부 테이블을 한 행씩 반복 처리
- 현재 행 번호는 sy-tabix
- `sy-tabix` 사용 가능
- `TABLE OF` : 특정 구조나 타입을 가지는 내부 테이블을 선언할 때 사용
- `LINE OF` : 내부 테이블에서 한 행(row)의 타입을 가져올 때 사용
```abap
LOOP AT <internal_table> INTO <work_area> [FROM <시작행>] [TO <끝행>] [WHERE <조건>].

  " 반복 처리 로직 작성 (각 행마다 실행)

ENDLOOP.
```
```abap
DATA: gs_sflight TYPE BC400_S_FLIGHT,      " Structure
      gt_sflight LIKE TABLE OF gs_sflight. " gt : 글로벌 테이블
" DATA: gs_sflight2 LIKE LINE OF gt_sflight. " Structure

SELECT * FROM SFLIGHT
  INTO CORRESPONDING FIELDS OF TABLE @gt_sflight  " DB 테이블에서 데이터 가져와서 internal 테이블에 넣음
  WHERE CARRID = 'AA'
    AND CONNID = '0017'.

IF sy-subrc = 0. " 만약 데이터 조회 성공한다면 (데이터 존재시)
  " Internal Table에 조회한 데이터들이 들어와 있는 상황
  " gt_flight를 한 건씩 돌면서 처리. 이 때 gs_flight 에 담아서 처리
  LOOP AT gt_sflight INTO gs_sflight. " Work-area라고 부름
    " gt_sflight 와 gs_sflights 는 필드 구조가 동일해야함.
    WRITE:/ sy-tabix,
            gs_sflight-carrid,
            gs_sflight-connid,
            gs_sflight-fldate.
  ENDLOOP.
ENDIF.
```
```abap
DATA: lt_data TYPE TABLE OF sflight,
      wa_data TYPE sflight.

SELECT * FROM sflight INTO TABLE lt_data.

LOOP AT lt_data INTO wa_data.
  WRITE: / wa_data-carrid, wa_data-connid.
ENDLOOP.
```
</br>
</br>

---

</br>

# ABAP Message Class (SE91) & 메시지 타입 정리
### 1) Message Class (SE91)
- 메시지를 번호로 관리하는 저장소. 이름은 Z나 Y로 시작.
- WITH 뒤에 메시지의 & 자리에 들어갈 값 지정
- 메시지는 `&` 로 변수 값을 받을 수 있음. 최대 4개까지 가능 → &1, &2, &3, &4 또는 단순 & 순서대로.
- 다국어(번역) 지원 → SAP 로그인 언어에 따라 자동으로 해당 언어 메시지 표시됨
</br>

### 2) 메시지 타입 정리

| 타입 | 이름 | 동작 | 상세 설명 |
|------|------|------|------------|
| **I** | Information | 팝업 메시지 표시 | 단순 정보 안내. OK 누르면 계속 진행 |
| **S** | Success | 상태바(하단)에 녹색 메시지 | 성공 메시지. 실행 계속됨 |
| **W** | Warning | **하단 상태바에 노란색 경고 메시지 표시** | 엔터 누르면 계속 진행. 단, *입력 화면(Selection-Screen)* 안에서만 유효 |
| **E** | Error | **하단 상태바에 빨간색 에러 메시지 표시 후 처리 중단** | AT SELECTION-SCREEN에서는 입력 화면으로 돌아감. 프로그램 실행 중에는 현재 이벤트 종료 |
| **A** | Abort | 비정상 종료 | 메시지 출력 후 프로그램 즉시 종료 |
| **X** | Exception | Short Dump 발생 | 시스템 덤프 생성(SAP 오류 강제 발생) |
</br>

### 3) MESSAGE-ID 미사용
- <메시지클래스> 반드시 명시해야 함
```abap
MESSAGE <type><번호>(<메시지클래스>) WITH 값1 값2 ...
```
```abap
REPORT ZPROGB03_0006.

PARAMETERS: pa_name TYPE string.
CONSTANTS: gc_const TYPE string VALUE 'CODE'.
MESSAGE i002(ZMCB03) WITH pa_name gc_const.
```
</br>

### 4) MESSAGE-ID 사용
- 프로그램 가장 위( REPORT 문 뒤 ) 선언
- 메시지 호출 시 클래스 이름 생략 가능
```abap
REPORT <프로그램명> MESSAGE-ID <메시지클래스>.
```
```abap
REPORT ZPROGB03_0006 MESSAGE-ID ZMCB03.          " MESSAGE-ID 사용

PARAMETERS: pa_name TYPE string.
CONSTANTS: gc_const TYPE string VALUE 'CODE'.
MESSAGE i002 WITH pa_name gc_const.              " 생략
```
</br>
</br>

---
</br>

## 디버깅
1. 소스코드에 BREAK-POINT. 키워드
2. 커멘드필드창에 /h 입력
3. 소스코드의 특정 라인 선택
</br>

### 디버깅 창에서 application toolbar의 버튼 4개

1. F5 한줄씩 실행 (메서드 안쪽까지 들어감)
2. F6 함수 블럭을 넘기고 다음 라인 실행. 함수 내부에서 실행 시 F5와 같이 동작함.
3. F7 함수 블럭 안에서, 메인 소스의 현재 위치 바로 다음줄로 이동
4. F8 다음 Break Point로 이동
```abap
BREAK-POINT.
```
</br>
</br>

---

</br>

## < 실습 코드 >
### 실습 1
- 숫자 2개 사이 값의 홀수 출력
```abap
PARAMETERS: pa_num1 TYPE I,   " 입력받은 두 숫자
            pa_num2 TYPE I.
DATA: gv_num TYPE I,
      gv_num1 LIKE gv_num,
      gv_num2 LIKE gv_num.           " 출력할 숫자 검사를 시작할 변수 선언

IF ( pa_num1 > pa_num2 ).     " 앞에 숫자 값이 더 클 때
  gv_num = pa_num2 + 1.
  gv_num1 = pa_num1.
  gv_num2 = pa_num2.
ELSE.
  gv_num = pa_num1 + 1.
  gv_num1 = pa_num2.
  gv_num2 = pa_num1.
ENDIF.

DO.
  IF ( sy-index > gv_num1 - gv_num2 - 1 ).
    EXIT.
  ENDIF.
  IF ( gv_num MOD 2 = 1 ).
    WRITE / gv_num.
  ENDIF.
  gv_num = gv_num + 1.
ENDDO.
```
</br>
</br>

### 실습 2
- 두 숫자 사이 3의 배수 구하기
```abap
PARAMETERS: pa_small TYPE I, pa_big TYPE I.
CONSTANTS: gc_const TYPE I VALUE 3.

IF ( ( pa_small IS INITIAL ) OR ( pa_big IS INITIAL ) ).
  MESSAGE TEXT-001 TYPE 'E'.
ENDIF.

IF ( pa_big <= pa_small ).
  MESSAGE TEXT-002 TYPE 'E'.
ENDIF.

DO.
  IF ( pa_small > pa_big ).
    EXIT.
  ELSEIF ( pa_small MOD gc_const = 0 ).
    WRITE / pa_small.
  ENDIF.
  pa_small = pa_small + 1.
ENDDO.
```
</br>
</br>

### 실습 3
```abap
PARAMETERS: pa_int1 TYPE I,
            pa_int2 TYPE I,
            pa_op TYPE C.

DATA gv_result TYPE P LENGTH 16 DECIMALS 2.


CASE pa_op.
  WHEN '+'.
    gv_result = pa_int1 + pa_int2.
  WHEN '-'.
    gv_result = pa_int1 - pa_int2.
  WHEN '*'.
    gv_result = pa_int1 * pa_int2.
  WHEN '/'.
    IF ( pa_int1 = 0 OR pa_int2 = 0 ).
      MESSAGE '0을 나눌 순 없습니다.' TYPE 'E'.
    ENDIF.
    gv_result = pa_int1 / pa_int2.
  WHEN OTHERS.
    MESSAGE '타당하지 않는 연산자입니다.' TYPE 'E'.
ENDCASE.

WRITE: gv_result.
```

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (11.19).md
</br>

# ABAP 모듈화(Modularization)
- 코드를 따로 만들어 놓고 필요할 때 호출해서 쓰는 것
- 가독성 ↑, 재사용성 ↑, 유지보수 ↑
</br>

**1) Local Modularization (로컬 모듈화)**
- 현재 프로그램 안에서만 사용 가능, 재사용성 낮음
- Subroutine (FORM), Local Class

**2) Global Modularization (전역 모듈화)**
- SAP 전체 프로그램이 공용으로 사용 가능, 어디서든 호출 가능, 재사용성 매우 좋음.
- Function Group / Function Module, Global Class (SE24) / Method
</br>

### 데이터 캡슐화
- 객체 내부 데이터를 숨기고(PRIVATE) 외부에서는 메서드(PUBLIC)로만 접근하도록 제한하는 것
- 데이터 보호 + 잘못된 접근 방지를 위한 객체지향의 기본 원칙
</br>

--- 

</br>

# 모듈화 기술 함수

## 1) Subroutine (FORM … ENDFORM)
- 로컬 모듈화 방식: 같은 프로그램 안에서만 호출 가능
- 글로벌 변수 사용 가능하지만 최소화하여 독립적·재사용 가능하게 작성

- 파라미터
  - `Formal Parameter` : 서브루틴/함수 선언 시 정의되는 변수
  - `Actual Parameter` : 호출 시 전달되는 값
  - **파라미터에 인터널 테이블을 쓸 수 있지만 `LIKE` 나 `TYPE` 을 이용해 명시해줘야함**
- 호출 방식
  - `CALL BY VALUE` : 호출 시 값만 복사해서 전달, 호출부 값은 바뀌지 않음.
  - `CALL BY VALUE AND RESULT` : 값 전달 후, 서브루틴에서 수정된 값을 호출부로 반환.
  - `CALL BY REFERENCE` : 변수의 메모리 주소를 공유, 서브루틴에서 바꾸면 호출부 값도 바로 바뀜.
- `USING`이나 `CHANGING` 파라미터에서 길이(LENGTH)를 지정하면 FORM 문법상 오류
```abap
* -------------------------------
* Subroutine 호출부
* -------------------------------
PERFORM <subroutine_name> 
        USING <param1> VALUE <param2> 
        CHANGING <param3> <param4>.

* -------------------------------
* Subroutine 선언부
* -------------------------------
FORM <subroutine_name> 
     USING VALUE(<param1>) VALUE(<param2>) 
     CHANGING <param3> <param4>.
  " 처리 로직 작성
ENDFORM.
```
</br>

### < ABAP 서브루틴 파라미터 전달 방식 정리 >
- USING / CHANGING 키워드와 VALUE() 사용 여부에 따른 호출 방식 표

| 키워드    | VALUE() 사용 여부 | 호출 방식                  | 특징                       | 호출부 반영 여부                |
|-----------|----------------|---------------------------|----------------------------|-------------------------------|
| USING     | VALUE()         | Call by Value             | 값만 전달                  | 호출부 변수 변경 안됨          |
| USING     | 없음            | Call by Reference         | 값 전달 + 수정 가능        | 호출부 변수 변경됨             |
| CHANGING  | VALUE()         | Call by Value and Result  | 값 전달 + 결과 반환        | 호출부 변수 변경됨             |
| CHANGING  | 없음            | Call by Reference         | 값 전달 + 수정 가능        | 호출부 변수 변경됨             |
- `USING VALUE(fa)` → 값만 전달, 호출부 변수 변경 안됨  
- `USING fa` → 값 전달 + 호출부 변수 공유  
- `CHANGING VALUE(fd)` → 값 전달 후 수정 결과 반환  
- `CHANGING fd` → 호출부 변수 공유, 바로 수정
```abap
DATA: gv_a TYPE C VALUE 'A',
      gv_b TYPE C VALUE 'B',
      gv_c TYPE C VALUE 'C',
      gv_d TYPE C VALUE 'D'.

PERFORM test USING gv_a gv_b
             CHANGING gv_c gv_d.

NEW-LINE.
WRITE: 'PERFORM IN : ', gv_a, gv_b, gv_c, gv_d.

FORM test  USING    VALUE(fa)
                    fb
           CHANGING VALUE(fc)
                    fd.
  fa = 'W'.
  fb = 'X'.
  fc = 'Y'.
  fd = 'Z'.
  WRITE: 'PERFORM END : ', fa, fb, fc, fd.

ENDFORM.
```
</br>
</br>

## 2) Function Module (FM)
- SE37 (Function Builder): SAP에서 Function Module을 생성, 수정, 테스트할 수 있는 트랜잭션 코드.
- Function Module(FM) 은 Function Group(FG) 안에 소속됨.
- Function Group = 하나의 프로그램처럼 동작.
- Function Module 가져올 때 끌어오거나 pattern 클릭 후 가져올 수 있음

</br>
  
- FG 내부 변수들은 FG 안의 Function Module끼리만 접근 가능, 일반 ABAP 프로그램에서는 직접 접근 불가
  - FM의 파라미터(interface)를 통해서만 값 전달·수정 가능.
- 하나의 FG 안에는 여러 개의 Function Module이 들어갈 수 있음.
```abap
* Function Module 호출

CALL FUNCTION '<FUNCTION_MODULE_NAME>'.
```

**RAISE**
- Function Module 내부에서 예외(Exception)를 발생시킬 때 사용
```abap
" function module 에서

FUNCTION zfm_test.

  IF iv_carrid IS INITIAL.
    RAISE invalid_carrid.
  ENDIF.

ENDFUNCTION.
```
```abap
" 프로그램에서

CALL FUNCTION 'ZFM_TEST'
  EXPORTING
    iv_carrid = ''
  EXCEPTIONS
    invalid_carrid = 1.
```
</br>
</br>

### < Function Module 파라미터 >
**1) Function Module 파라미터 옵션**
1) OPTIONAL
   - 체크하면 해당 파라미터를 전달하지 않아도 FM 호출 가능 (선택값)
   - 체크하지 않으면 필수값, 반드시 전달해야 함
     
2) Pass by Value / Reference
   - Pass by Value (체크 O) : FM에 값만 전달, FM 내부에서 변경해도 호출부 변수는 영향 없음
   - Pass by Reference (체크 X) : FM과 호출부 변수가 같은 메모리 주소를 공유, FM 내부 변경 시 호출부에도 반영

3) EXCEPTIONS (예외 처리)
   - FM 실행 중 발생할 수 있는 오류 상황을 처리
   - 호출부에서 특정 예외를 감지하고 대응 가능
</br>
</br>

**2) Function Module 파라미터 종류 (Interface)**
- FM에서 파라미터 영역을 **Interface**라고 부름
  - 프로그램과 FM이 값을 주고받는 통로
  
| 파라미터 종류 | 의미 |
|---------------|------------------------------------------------|
| **IMPORT**    | 프로그램 → FM 값 전달 |
| **EXPORT**    | FM → 프로그램 값 반환 |
| **CHANGING**  | 양방향 데이터 전달 (주고받기) |
| **EXCEPTIONS**| 예외 처리 |
</br>
</br>

**3) 프로그램 ↔ Function Module 파라미터 대응표**
- 프로그램이 **EXPORTING** 으로 보내면 FM에서는 반드시 **IMPORTING** 으로 받아야 함.

| 프로그램에서 전달 | Function Module에서 받음 |
|------------------|---------------------------|
| **EXPORTING**    | **IMPORTING** |
| **IMPORTING**    | **EXPORTING** |
| **CHANGING**     | **CHANGING** |
| **Tables**     | **Tables** |
| **sy-subrc**     | **Exceptions** |

</br>
</br>

### < Function Module 선언 (SE37에서 생성) >
```abap
FUNCTION <function_module_name>.
*"----------------------------------------------------------------------
*"*" Local Interface:
*"  IMPORTING
*"     VALUE(<import_param1>) TYPE <type>
*"  EXPORTING
*"     VALUE(<export_param1>) TYPE <type>
*"  CHANGING
*"     VALUE(<changing_param1>) TYPE <type>
*"  EXCEPTIONS
*"      <exception_name1> 1
*"      <exception_name2> 2
*"----------------------------------------------------------------------

  " 처리 로직 작성
  <export_param1> = <import_param1> + 10.

ENDFUNCTION.
```
</br>

### <Function Module 호출 (프로그램에서) >
```abap
DATA: lv_result TYPE i.

CALL FUNCTION '<function_module_name>'
  EXPORTING
    <import_param1> = 5
  IMPORTING
    <export_param1> = lv_result
  CHANGING
    <changing_param1> = lv_result
  EXCEPTIONS
    <exception_name1> = 1
    OTHERS = 2.

IF sy-subrc <> 0.
  WRITE: '예외 발생'.
ELSE.
  WRITE: / '결과: ', lv_result.
ENDIF.
```

</br>
</br>

---

</br>

## < ABAP 추가적인 문법 >
</br>

**1) ULINE**
- 화면에 ————— (라인) 을 출력하는 명령
- WRITE 없이 단독으로 사용 가능
```abap
ULINE.
```
</br>

**2) WRITE: 숫자(숫자) → 출력 위치 + 필드 길이 지정**
```abap
WRITE: position(length) <값>.
```
```abap
WRITE: 5(10) pa_num, '단 :'.    " 5(10) → 화면 5번째 칼럼부터 10칸 공간 확보
```
</br>

---
</br>

## < 실습 코드 >
### 실습 1
```abap
PARAMETERS pa_num TYPE I.
DATA gv_result TYPE I.

IF ( pa_num <= 1 ).
  MESSAGE '2 이상을 입력하세요' TYPE 'E'.
ELSEIF ( pa_num >= 10 ).
  MESSAGE '9 이하를 입력하세요' TYPE 'E'.
ELSE.
  DO 9 TIMES.
    gv_result = pa_num * sy-index.
    WRITE:/ pa_num, ' * ', sy-index, ' = ', gv_result.
  ENDDO.
ENDIF.
```
```abap
PARAMETERS: pa_num TYPE I.
DATA: gv_result TYPE I.

IF pa_num < 2 OR pa_num > 9.
  MESSAGE '2 이상 9 이하의 숫자를 입력하세요.' TYPE 'I'.
  ELSE.
    WRITE: 5(10) pa_num, '단 :'.
    ULINE.

    DO 9 TIMES.
      gv_result = pa_num * sy-index.
      WRITE:
        10(2) pa_num,
        12(2) '*',
        14(2) sy-index,
        16(2) '=',
        18(2) gv_result.
      NEW-LINE.
    ENDDO.
ENDIF.
```
</br>
</br>

### 실습 2
```abap
PARAMETERS: gv_num1 TYPE i,
            gv_op   TYPE c LENGTH 1,
            gv_num2 TYPE i.

DATA: gv_result TYPE i.

PERFORM get_compute USING gv_num1 gv_num2 gv_op
                    CHANGING gv_result.

WRITE: gv_result.

* 서브루틴 정의
FORM get_compute USING VALUE(p_pa_num1)
                       VALUE(p_pa_num2)
                       VALUE(p_pa_op)
                 CHANGING VALUE(p_pa_result).
  CASE p_pa_op.
    WHEN '+'.
      p_pa_result = p_pa_num1 + p_pa_num2.
    WHEN '-'.
      p_pa_result = p_pa_num1 - p_pa_num2.
    WHEN '*'.
      p_pa_result = p_pa_num1 * p_pa_num2.
    WHEN '/'.
      p_pa_result = p_pa_num1 / p_pa_num2.
    WHEN OTHERS.
  ENDCASE.

ENDFORM.
```
</br>
</br>

### 실습 3
```abap
PARAMETERS: pa_int1 TYPE i,
            pa_int2 TYPE i,
            pa_op   TYPE c.

DATA gv_result TYPE p LENGTH 16 DECIMALS 2.


CASE pa_op.
  WHEN '+'.
    gv_result = pa_int1 + pa_int2.
  WHEN '-'.
    gv_result = pa_int1 - pa_int2.
  WHEN '*'.
    gv_result = pa_int1 * pa_int2.
  WHEN '/'.
    IF ( pa_int1 = 0 OR pa_int2 = 0 ).
      MESSAGE '0을 나눌 순 없습니다.' TYPE 'E'.
    ENDIF.
    gv_result = pa_int1 / pa_int2.
  WHEN '%'.
    PERFORM CALC_PERCENTAGE USING pa_int1 pa_int2 CHANGING gv_result.
  WHEN OTHERS.
    MESSAGE '타당하지 않는 연산자입니다.' TYPE 'E'.
ENDCASE.

WRITE: gv_result.

FORM CALC_PERCENTAGE USING VALUE(PV_ACT) TYPE I 
                           VALUE(PV_MAX) TYPE I
                     CHANGING VALUE(CV_RESULT).
  IF ( PV_MAX = 0 ).
    MESSAGE '0이 들어올 수 없습니다.' TYPE 'E'.
  ELSE.
    CV_RESULT = ( PV_ACT / PV_MAX ) * 100.
  ENDIF.
ENDFORM.
```

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (11.20).md
</br>

## < SE11 ABAP Dictionary에서 정의하는 타입 >
**1) 데이터필드 (단일 필드 데이터 타입)**
- 숫자 1개, 문자열 1개 등 값 하나만 저장하는 타입
```abap
DATA 변수명 TYPE 데이터타입.
```
```abap
DATA gv_price TYPE p DECIMALS 2.
DATA gv_name  TYPE char20.
```
</br>
</br>

**2-1) Structure 타입**
- 여러 개의 필드(컴포넌트)를 묶은 하나의 "작업공간(Work Area)"
- SE11에서 Structure 로 정의된 타입 사용 가능
- 또는 LOCAL TYPES 로 직접 선언 가능
```abap
DATA 구조체변수명 TYPE 글로벌_구조체명.
```
```abap
DATA gs_flight TYPE bc400_s_flight.
```
</br>

**2-2) Local Structure 정의 후 사용**
- 프로그램 안에서만 쓰는 로컬 구조체를 직접 만드는 것
- SE11(글로벌 타입) 안 쓰고, TYPES 로 구조체를 만들고 DATA 로 변수 생성
```abap
TYPES: BEGIN OF 구조체타입명,
         필드명 TYPE 데이터타입,
         필드명 TYPE 데이터타입,
       END OF 구조체타입명.

DATA 구조체변수명 TYPE 구조체타입명.
```
```abap
TYPES: BEGIN OF ts_flight,
         carrid   TYPE s_carr_id,
         connid   TYPE s_conn_id,
         fldate   TYPE s_date,
       END OF ts_flight.

DATA gs_flight TYPE ts_flight.
```
</br>

**2-3) Local Structure + INCLUDE TYPE (구조체 확장)**
- 기존 글로벌 Structure를 포함하고, 프로그램 전용 필드를 추가하여 로컬 구조체 확장
```abap
DATA: BEGIN OF <로컬구조체변수명>.
        INCLUDE TYPE <글로벌Structure명>.
DATA: <추가필드명1> TYPE <데이터타입>,
      <추가필드명2> TYPE <데이터타입>,
      END OF <로컬구조체변수명>.
```
```abap
DATA: BEGIN OF gs_flight.
        INCLUDE TYPE BC400_S_FLIGHT.  " 글로벌 Structure 포함
DATA: custom1 TYPE CHAR1,
      custom2 TYPE CHAR1,
      END OF gs_flight.

gs_flight-carrid = 'AA'.       " 글로벌 필드
gs_flight-custom1 = 'X'.       " 로컬 필드

WRITE: / gs_flight-carrid, / gs_flight-custom1.
```
</br>

**2-4) CUKY / CURR, UNIT / QUAN 주의**
- `CUKY / CURR` : 금액과 통화키 필드는 항상 짝
- `UNIT / QUAN` : 수량과 단위 필드도 항상 짝 맞춰야 함
- 짝이 맞지 않으면 런타임 에러 발생 가능

<img width="509" height="183" alt="image" src="https://github.com/user-attachments/assets/322a985b-def8-4c42-b439-837586fc4215" />
</br>
</br>

- currency/quantity 에서 수정해야 함
<img width="510" height="196" alt="image" src="https://github.com/user-attachments/assets/0d875068-b49d-4bc5-916d-7d8c099c26fe" />

</br>
</br>
</br>
</br>

**3) DB Table 기반 구조체**
- SE11에서 정의된 Transparent Table을 기준으로 변수를 만들면
  - `DATA gs_scarr TYPE scarr.` → 구조체 (Work Area, 테이블 한 행)
  - `DATA gv_carrid TYPE scarr-carrid.` → 단일 필드 (Work Area 아님)
- 테이블 컬럼이 그대로 구조체 필드로 생성됨
```abap
DATA gs_scarr TYPE scarr.       " 구조체: 테이블 한 행을 담음
DATA gv_carrid TYPE scarr-carrid. " 단일 필드
```
</br>
</br>

**4) MOVE-CORRESPONDING**
- 구조체/테이블 간 필드 이름이 같은 것만 복사
- MOVE와 달리 필드 위치 상관없이 안전하게 매핑
- `MOVE` → 메모리 구조 그대로 복사 (위험), `MOVE-CORRESPONDING` → 동일 이름 필드만 안전하게 복사
```abap
MOVE-CORRESPONDING 원본변수 TO 대상변수.
```
```abap
DATA gs_flight    TYPE zsflight_b03.
DATA gs_b_flight  TYPE bc400_s_flight.

MOVE-CORRESPONDING gs_flight TO gs_b_flight.
```

</br>
</br>

---
</br>

## < ABAP 추가적인 문법 >

**1) CONCATENATE**
- 여러 문자열을 하나로 이어 붙임
- `SEPARATED BY` → 문자열 사이에 넣을 구분자(공백, 콤마 등)
```abap
CONCATENATE <문자1> <문자2> <문자3> ... INTO <결과변수>
             [SEPARATED BY <구분자>].
```
- CONCATENATE 의 INTO절에 RESPECTING BLANKS 추가 시, 빈칸을 허용함
```abap
CONCATENATE 문자1 문자2 문자3 INTO lv_result RESPECTING BLANKS.
```
```abap
DATA gv_result TYPE string.
PERFORM getToday CHANGING gv_result.
WRITE: gv_result.

FORM getToday CHANGING VALUE(p_result).
  CONCATENATE '오늘은' sy-datum+0(4) '년' sy-datum+4(2) '월' sy-datum+6(2) '일 입니다' INTO p_result.
ENDFORM.
```
</br>
</br>

**2) sy-datum**
- 현재 시스템 날짜가 자동으로 들어 있는 SAP 시스템 필드
```abap
sy-datum  →  YYYYMMDD (8자리 날짜)
```
- `+숫자(숫자)` 는 문자열에서 원하는 위치(offset)와 길이(length)만큼 잘라오는 부분 문자열 표현
- `<offset>` 위치부터 `<length>` 길이만큼 부분 문자열(substring) 을 잘라서 가져오는 문법
```abap
<변수>+<offset>(<length>)
```
</br>

---
</br>

## < 실습 코드 >
### 실습 1
- FROM 함수 이용한 날짜 출력
```abap
DATA gv_result TYPE string.
PERFORM getToday CHANGING gv_result.
WRITE: gv_result.

FORM getToday CHANGING VALUE(p_result).
  CONCATENATE '오늘은' sy-datum+0(4) '년' sy-datum+4(2) '월' sy-datum+6(2) '일 입니다' INTO p_result.
ENDFORM.
```
</br>
</br>

### 실습 2
- function group과 function module 이용
  
**1) function group 생성**

<img width="510" height="298" alt="image" src="https://github.com/user-attachments/assets/6df20037-fa62-4ad6-916a-7e099d4ff48f" />
</br>
</br>

**2) function module 생성**

<img width="531" height="135" alt="image" src="https://github.com/user-attachments/assets/db2e443c-dc3f-4e7f-8a91-4de7d08aca43" />
</br>
</br>

**3) importing, exporting, exceptions 표 채우기**

<img width="506" height="98" alt="image" src="https://github.com/user-attachments/assets/093db934-1818-4570-8cb7-ee485303aa09" />
</br>

<img width="509" height="98" alt="image" src="https://github.com/user-attachments/assets/691cef49-9590-451f-94ac-154a8eb7a623" />
</br>

<img width="510" height="119" alt="image" src="https://github.com/user-attachments/assets/bba68691-5626-47db-8631-e231139dab62" />
</br>
</br>

**4) function module 코드 수정**
```abap
FUNCTION z_bc400_03_comp_percentage.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(IV_ACT) TYPE  BC400_ACT
*"     REFERENCE(IV_MAX) TYPE  BC400_MAX
*"  EXPORTING
*"     REFERENCE(EV_PERCENTAGE) TYPE  BC400_PERC
*"  EXCEPTIONS
*"      DIVISION_BY_ZERO
*"----------------------------------------------------------------------

  IF iv_max = 0.
    ev_percentage = 0.
    RAISE division_by_zero.
  ELSE.

  ENDIF.

ENDFUNCTION.
```
</br>

**5) program 코드 수정**
```abap
*&---------------------------------------------------------------------*
*& Report ZBC400_03_COMP
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
REPORT ZBC400_03_COMP.

TYPES tv_result TYPE p LENGTH 16 DECIMALS 2.

PARAMETERS:
  pa_int1  TYPE i,
  pa_op    TYPE c LENGTH 1,
  pa_int2  TYPE i.

DATA gv_result TYPE tv_result.

IF ( pa_op = '+' OR
     pa_op = '-' OR
     pa_op = '*' OR
     pa_op = '/' AND pa_int2 <> 0 OR
     pa_op = '%' OR
     pa_op = 'P' ).

  CASE pa_op.
    WHEN '+'.
      gv_result = pa_int1 + pa_int2.
    WHEN '-'.
      gv_result = pa_int1 - pa_int2.
    WHEN '*'.
      gv_result = pa_int1 * pa_int2.
    WHEN '/'.
      gv_result = pa_int1 / pa_int2.
    WHEN '%'.
      PERFORM calc_percentage
        USING
          pa_int1
          pa_int2
        CHANGING
          gv_result.

      CALL FUNCTION 'Z_BC400_03_COMP_PERCENTAGE'
        EXPORTING
          iv_act = pa_int1
          iv_max = pa_int2
        IMPORTING
          EV_PERCENTAGE          = gv_result
        EXCEPTIONS
          DIVISION_BY_ZERO       = 1
          OTHERS = 2.

      IF sy-subrc <> 0.
        MESSAGE 'error!' TYPE 'E'.
      ENDIF.

    WHEN 'P'.
      CALL FUNCTION 'BC400_MOS_POWER'
        EXPORTING
          iv_base               = pa_int1
          iv_power              = pa_int2
        IMPORTING
          ev_result             = gv_result
        EXCEPTIONS
          power_value_too_high  = 1
          result_value_too_high = 2
          OTHERS                = 3.
      CASE sy-subrc.
        WHEN 0.
*         no action needed
        WHEN 1.
          WRITE 'Max value of power is 4'(mvp).
        WHEN 2.
          WRITE 'Result value too high'(rvh).
        WHEN 3.
          WRITE 'Unknown error'(uer).
      ENDCASE.
  ENDCASE.

  WRITE: 'Result:'(res), gv_result.

ELSEIF  pa_op = '/'  AND  pa_int2 = 0.
  WRITE: 'No division by zero!'(dbz).
ELSE.
  WRITE: 'Invalid operator!'(iop).
ENDIF.

FORM calc_percentage  USING    pv_act TYPE i
                               pv_max TYPE i
                      CHANGING cv_result TYPE tv_result.

*Simple Error Handling
  IF pv_max = 0.
    cv_result = 0.
    WRITE 'Error in percentage calculation'(epc).
  ELSE.
*Calculate result
    cv_result = pv_act / pv_max * 100.
  ENDIF.

ENDFORM.                    " calc_percentage
```
</br>
</br>

### 실습 3
- Structure 이용
  
**1) 글로벌 구조체 타입(SE11 Structure)을 이용해 Work Area 생성**
```abap
" Structure: 여러개의 컴포넌트로 구성된 Work Area (작업공간)
" Global data type을 사용하여 structure 변수 생성

DATA: gs_data   TYPE bc400_s_flight,
      gs_data2  LIKE gs_data,
      gs_flight TYPE zsflight_b03,
      gs_scarr  TYPE zscarr_b03.

gs_scarr-carrid = 'AA'.
gs_scarr-carrname = 'Hello'.
gs_scarr-currcode = 'KRW'.
gs_scarr-url = 'www.naver.com'.    " 하나의 structure에 데이터를 넣음

WRITE:/ gs_scarr-carrid,
      / gs_scarr-carrname.
```
</br>

**2) 프로그램 내에서만 사용하는 로컬 구조체 선언 + Work Area 생성**
```abap
* Local type structure
TYPES: BEGIN OF ts_flight,
          CARRID TYPE S_CARR_ID,
          CONNID TYPE S_CONN_ID,
          FLDATE TYPE S_DATE,
          CITYFROM TYPE S_FROM_CIT,
          CITYTO TYPE S_TO_CITY,
       END OF ts_flight.

DATA: gs_flight TYPE ts_flight.

gs_flight-carrid = 'AA'.
gs_flight-connid = '0017'.

WRITE:/ gs_flight-carrid,
      / gs_flight-connid.
```
</br>

**3) 글로벌 Structure를 가져와 로컬 필드를 추가한 구조체 만들기**
```abap
* DB Table을 가지고 변수 생성 시 Structure 타입의 변수가 됨.
* => 구조체를 가지고 만든 것이기 때문

**********************************************************************

* 기존 global structure 에다가 custom component 추가하여
* Local Structure 생성

DATA: BEGIN OF gs_flight.
  INCLUDE TYPE BC400_S_FLIGHT.
DATA: custom TYPE CHAR1,
      custom2 TYPE CHAR1,
      END OF gs_flight.

BREAK-POINT.

WRITE: 'okok'.
```
</br>

**4) 최종 실습**
```abap
* 1단계
DATA: gs_flight TYPE ZSFLIGHT_B03.
gs_flight-carrid = 'AA'.
gs_flight-connid = '0017'.
gs_flight-fldate = sy-datum.
gs_flight-cityfrom = 'Incheon'.
gs_flight-cityto = 'Seoul'.

WRITE:/ gs_flight-carrid,
      / gs_flight-connid,
      / gs_flight-fldate,
      / gs_flight-cityfrom,
      / gs_flight-cityto.

** 2단계
DATA: gs_b_flight TYPE BC400_S_FLIGHT.
MOVE-CORRESPONDING gs_flight TO gs_b_flight.

WRITE:/ gs_b_flight-carrid,
      / gs_b_flight-connid,
      / gs_b_flight-fldate.
```

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (11.21).md
</br>

## < Internal Table (화면 출력/데이터 처리용 메모리 테이블) >
- Internal 테이블은 프로그램 안에서 임시로 데이터를 저장·처리하는 메모리상의 테이블
- 일반 테이블은 DB에 실제로 저장되어 여러 사용자와 프로그램이 공유하는 영구 테이블
</br>

**1) Line Type**
- 내부 테이블 한 줄(Row)의 구조
- Structure 또는 Dictionary 테이블 구조를 기반으로 함
</br>

**2) Primary Key**
- key = 내부 테이블에서 검색/행 식별에 사용되는 기준 필드
  - `components` → 어떤 필드들이 키인지
  - `uniqueness` → 중복 허용 여부 (UNIQUE / NON-UNIQUE)
  - `sequence` → 정렬 여부 (Sorted 테이블에서만 의미 있음)
</br>

**3) Table Kind**
- 내부 테이블의 정렬 방식, 중복 가능 여부, 검색 성능을 결정
- 종류:
  - Standard Table (Index Table)
  - Sorted Table
  - Hashed Table
</br>
</br>

**< ABAP Internal Table 비교 >**

| 구분 | STANDARD TABLE | SORTED TABLE | HASHED TABLE |
|------|----------------|--------------|--------------|
| **Table Kind** | Standard Table | Sorted Table | Hashed Table |
| **Index Access** | ✔ 가능 | ✔ 가능 | ❌ 불가능 |
| **Key Access** | ✔ 가능 | ✔ 가능 | ✔ 가능 |
| **Key Uniqueness** | NON-UNIQUE (중복 허용) | UNIQUE / NON-UNIQUE (중복 허용/불가 둘 다 가능) | UNIQUE (중복 불가) |
| **Use In** | Mainly Index Access (주로 인덱스 접근) | Mainly Key Access (주로 키 기반 검색) | Only Key Access (키 기반 초고속 검색 전용) |

</br>
</br>

---
</br>

## < Internal Table 선언 3가지 방식 >
</br>

**1) Table Type 기반 (Global Type)**
- 이미 정의된 Table Type을 사용하여 Internal Table 선언
- Table Type에 Line Type, Table Kind, Key 등이 미리 정의되어 있어 코드가 간결
```abap
DATA <internal_table_name> TYPE <table_type>.
```
```abap
DATA gt_flights TYPE BC400_T_FLIGHTS.
DATA gt_flights TYPE tt_flights.
```
</br>
</br>
</br>

**2) Table Kind + Key 직접 정의 (Local Type)**
- Table Type 없이 Internal Table 종류(Standard/Sorted/Hashed)와 Key를 직접 지정
- Table Type 없이 바로 선언 가능, Key 조건도 자유롭게 지정
```abap
DATA <internal_table_name> TYPE <table_kind> TABLE OF <structure_type>
     WITH [UNIQUE | NON-UNIQUE] KEY <field1> <field2> ... .
```
```abap
DATA gt_iteb1 TYPE STANDARD TABLE OF BC400_S_FLIGHT WITH DEFAULT KEY.
DATA gt_item2 TYPE STANDARD TABLE OF BC400_S_FLIGHT WITH NON-UNIQUE KEY CARRID CONNID.
DATA gt_item4 TYPE SORTED TABLE OF BC400_S_FLIGHT WITH NON-UNIQUE KEY CARRID CONNID.
DATA get_item6 TYPE HASHED TABLE OF BC400_S_FLIGHT WITH UNIQUE KEY CARRID CONNID.
```
</br>
</br>
</br>

**3) 단순 Table of Structure**
- Key를 지정하지 않고 단순히 Table of Structure 선언
- 간단하게 선언 가능, Standard Table 기본
```abap
DATA <internal_table_name> TYPE TABLE OF <structure_type>.
```
```abap
DATA gt_flight2 TYPE TABLE OF BC400_S_FLIGHT.
DATA gt_flight3 TYPE TABLE OF SCARR.
DATA gt_item3 TYPE TABLE OF BC400_S_FLIGHT.
```
</br>
</br>
</br>

## < ABAP Internal Table 및 Structure 선언과 사용 예제 >
</br>

**1) Internal Table 선언 (Table Type / Structure 기반)**
- `gt_flight` : 이미 정의된 Table Type을 기반으로 Internal Table 생성.
- `gt_flight2` : Global Structure를 기반으로 Internal Table 생성.
- `gt_flight3` : DB Transparent Table 구조를 그대로 Internal Table로 선언.
- `gt_flight4` : 기존 Table gt_flight3의 구조와 동일하게 선언(LIKE 사용).
```abap
DATA: gt_flight TYPE BC400_T_FLIGHTS,   " Table type 사용
      gt_flight2 TYPE TABLE OF BC400_S_FLIGHT,   " Global structure 사용
      gt_flight3 TYPE TABLE OF SCARR, " DB Table (Transparent table) 사용
      gt_flight4 LIKE gt_flight3. " LIKE 사용해서 Internal Table 사용
```
</br>
</br>
</br>

**2) Standard Internal Table 선언**
- `gt_iteb1` : 기본 키를 가지는 표준 Internal Table.
- `gt_item2` : 지정한 필드(CARRID, CONNID)를 기준으로 비유니크 키를 가지는 표준 Internal Table.
- `gt_item3` : 키를 명시하지 않은 표준 Internal Table.
```abap
" Standard internal table
DATA: gt_iteb1 TYPE STANDARD TABLE OF BC400_S_FLIGHT
               WITH DEFAULT KEY,
      gt_item2 TYPE STANDARD TABLE OF BC400_S_FLIGHT
               WITH NON-UNIQUE KEY CARRID CONNID,
      gt_item3 TYPE TABLE OF BC400_S_FLIGHT.
```
</br>
</br>
</br>

**3) Sorted Internal Table 선언**
- `gt_item4` : 지정된 키 기준으로 항상 정렬되는 Internal Table, 중복 키 허용.
- `gt_itab5` : 지정된 키 기준으로 정렬, 중복 키 불가.
```abap
" Sorted internal table
DATA: gt_item4 TYPE SORTED TABLE OF BC400_S_FLIGHT
               WITH NON-UNIQUE KEY CARRID CONNID, " key는 띄어쓰기로 구분
      gt_itab5 TYPE SORTED TABLE OF BC400_S_FLIGHT
               WITH UNIQUE KEY CARRID CONNID.
```
</br>
</br>
</br>

**4) Hashed Internal Table 선언**
- `get_item6` : Key 기반 Hash 구조를 사용, 빠른 검색 가능, 반드시 UNIQUE KEY 필요.
```abap
* Hashed internal table
DATA: get_item6 TYPE HASHED TABLE OF BC400_S_FLIGHT
                WITH UNIQUE KEY CARRID CONNID.
```
</br>
</br>
</br>

**5) Structure 변수 선언**
```abap
" Glocal structure type
DATA gs_flight TYPE BC400_S_FLIGHT.

" transparent table 가지고도 스트럭처 변수 생성 가능
DATA gs_flight2 TYPE SCARR.

" Table type의 Line type 정보로 스트럭처 변수 생성 가능
DATA gs_flight3 TYPE LINE OF BC400_T_FLIGHTS.

" 위에서 선언한 Internal table에서 Line type만 복사하여 생성
DATA gs_flight4 LIKE LINE OF gt_iteb1.
```
</br>
</br>
</br>

**6) 기타 Table/Structure 선언**
- `aa` : Table Type 기반 Internal Table.
- `bb` : Table Type의 Table 선언.
- `cc` : Table Type의 한 행(Line Type) 구조 변수.
- `dd` : bb Table 라인과 동일한 구조 변수(LIKE LINE OF).
- `ee` : 단일 Structure 변수.
- `ff` : dd와 같은 구조의 Internal Table(LIKE TABLE OF).
```abap
DATA: aa TYPE BC400_T_CONNECTIONS,
      " Table Type 위에 또 TABLE OF를 붙일 수 없음
      bb TYPE TABLE OF BC400_T_CONNECTIONS,    " bb TYPE aa 로 바꾸기
      cc TYPE LINE OF BC400_T_CONNECTIONS,
      dd LIKE LINE OF bb,
      ee TYPE S_CARR_ID,
      ff LIKE TABLE OF dd.
```
</br>
</br>
</br>

---
</br>

## < ABAP 인터널 테이블 CRUD 명령어 >
- INDEX 사용 시 대부분 Table 이름 뒤에 TABLE 키워드 생략 가능
- INSERT만 예외적으로 `INTO TABLE` 또는 `INTO itab` 둘 다 가능

**단건 CRUD**
| 기능 | 키워드 |
|------|---------|
| 조회 (READ) | `READ TABLE itab INTO wa WITH KEY ...` |
| 추가 (CREATE) | `APPEND wa TO itab` / `INSERT wa INTO itab INDEX idx` |
| 변경 (UPDATE) | `MODIFY itab FROM wa` |
| 삭제 (DELETE) | `DELETE itab INDEX idx` / `DELETE itab WHERE ...` |

**다건 CRUD**
| 기능 | 키워드 |
|------|---------|
| 조회 (READ) | `LOOP AT itab INTO wa WHERE ...` / `LOOP AT itab FROM idx1 TO idx2` |
| 추가 (CREATE) | `APPEND LINES OF itab_src TO itab_tgt` / `INSERT LINES OF itab_src INTO itab_tgt INDEX idx` |
| 변경 (UPDATE) | `LOOP AT itab INTO wa ...` → `MODIFY itab FROM wa` |
| 삭제 (DELETE) | `DELETE itab WHERE ...` / `DELETE itab FROM idx1 TO idx2` |
</br>
</br>
</br>

**1-1) APPEND – 인터널 테이블 끝에 값 추가**
- 인터널 테이블의 맨 끝에 데이터를 추가
- Standard Table 기준 → 삽입 순서 그대로 유지
```abap
APPEND <추가할_행> TO <인터널_테이블>.
```
```abap
DATA: flight TYPE BC400_S_FLIGHT,
      flights_table TYPE STANDARD TABLE OF BC400_S_FLIGHT.

flight-carrid = 'AA'.
flight-connid = '001'.

APPEND flight TO flights_table.
```
</br>

**1-2) APPEND LINES OF – 다른 테이블의 여러 행 끝에 추가**
- `<소스_테이블>`의 여러 행을 `<대상_테이블>` 끝에 추가
```abap
APPEND LINES OF <source_table> 
       [FROM <start> [TO <end>]]    " 범위 지정 (Standard Table 전용)
       [WHERE <field1> = <value1> 
              <field2> = <value2> …]  " 조건 지정
       TO <target_table>.           " 추가할 테이블
```
```abap
APPEND LINES OF flights_table1 WHERE carrid = 'AA' TO flights_table2.
```
</br>
</br>
</br>

**2-1) INSERT – 특정 위치 또는 조건에 값 삽입**
- 조건 생략 → 맨 끝에 추가 (APPEND와 동일)
- 조건/인덱스 지정 가능 → 원하는 위치에 삽입
- INSERT 구문에는 WHERE 절은 지원되지 않음
```abap
INSERT <작업_영역> INTO <내부_테이블> [INDEX <번호>].
```
```abap
INSERT flight INTO TABLE flights_table INDEX 2.
INSERT flight INTO TABLE flights_table.  " 맨 끝
```
</br>

**2-2) INSERT LINES OF – 다른 테이블의 여러 행 삽입**
- `<소스_테이블>`의 여러 행을 `<대상_테이블>`에 삽입
```abap
INSERT LINES OF <source_table> 
       [FROM <start> [TO <end>]]        " 범위 지정 (Standard Table 전용)
       [WHERE <field1> = <value1> 
              <field2> = <value2> …]  " 조건 필터링
       INTO TABLE <target_table>       " 데이터를 삽입할 테이블
       [INDEX <n>].                    " 삽입 위치 지정
```
```abap
INSERT LINES OF flights_table1 WHERE carrid = 'AA' INTO TABLE flights_table2.
```
</br>
</br>
</br>

**3) READ – 특정 조건/위치의 값 조회**
- 조건에 맞는 첫 번째 행을 가져옴
- 성공 → `sy-subrc` = 0, 실패 → `sy-subrc` <> 0
```abap
READ TABLE <인터널_테이블> INTO <행> 
     [WITH KEY <필드1> = <값1> <필드2> = <값2> …] 
     [INDEX <위치>].
```
```abap
READ TABLE flights_table INTO flight WITH TABLE KEY carrid = 'AA' connid = '001'.
IF sy-subrc = 0.
  WRITE: / 'Flight found:', flight-carrid.
ENDIF.
```
</br>
</br>
</br>

**4) MODIFY – 기존 값 수정**
- 조건에 맞는 행을 덮어씀
- Standard Table 기준 → 조건에 맞는 여러 행이 있어도, 그 중에서 가장 먼저 나오는 한 행만 수정
- INDEX 지정 시 → 해당 위치 행만 변경
- TRANSPORTING <필드> → 지정한 필드만 수정
```abap
MODIFY <인터널_테이블> 
       FROM <행_데이터> 
       [INDEX <위치>] 
       [TRANSPORTING <필드1> <필드2> ...] 
       [WHERE <조건>].
```
```abap
flight-cityfrom = 'Seoul'.
MODIFY TABLE flights_table FROM flight.

flight-price = 20000.
MODIFY flights_table FROM flight TRANSPORTING price WHERE carrid = 'AA'.

flight-price = 15000.
MODIFY flights_table FROM flight INDEX 2.
```
</br>
</br>
</br>

**5) DELETE – 행 삭제**
- `INDEX` → 특정 위치 삭제
- `WHERE` → 조건에 맞는 행 삭제
- `FROM` → 구조체와 동일한 행 삭제
```abap
DELETE <internal_table> 
       [INDEX <n>]                 " 단일 행 삭제 (Standard Table만)
       [FROM <start> [TO <end>]]   " 범위 지정 삭제 (Standard Table 전용)
       [WHERE <field1> = <value1> <field2> = <value2> ...] 
       [FROM <work_area>] 
       [TABLE <internal_table> WHERE <condition>].
```
```abap
DELETE flights_table WHERE carrid = 'AA'.
DELETE flights_table INDEX 1.
```
</br>
</br>
</br>

**6) LOOP AT – 테이블 반복 처리**
- 인터널 테이블의 모든 행 또는 조건에 맞는 행을 반복 처리
- `WHERE` 조건 생략 시 → 테이블 전체를 반복
```abap
LOOP AT <인터널_테이블> INTO <행> [WHERE <조건>].
  " 반복하면서 처리할 코드
ENDLOOP.
```
```abap
DATA: flight TYPE BC400_S_FLIGHT,
      flights_table TYPE STANDARD TABLE OF BC400_S_FLIGHT.

* 데이터 예시
* flight_table = [
*   {carrid='AA', connid='001'},
*   {carrid='BB', connid='002'},
*   {carrid='AA', connid='003'}
* ]

LOOP AT flights_table INTO flight WHERE carrid = 'AA'.
  WRITE: / flight-carrid, flight-connid.
ENDLOOP.
```

</br>
</br>
</br>

---

</br>

## < 실습 코드 >
### 실습 1
- global structure 생성하기
<img width="1520" height="660" alt="image" src="https://github.com/user-attachments/assets/d533af41-58cf-459f-a95e-12c8662a9c39" />
</br>

<img width="1556" height="668" alt="image" src="https://github.com/user-attachments/assets/44bebdb1-9117-4787-b7bd-0146e8df7f5d" />
</br>

```abap
DATA: gs_flight TYPE ZSCLB03_DEMO.

BREAK-POINT.
gs_flight-carrid = 'AA'.

WRITE:/ gs_flight-carrid.
```
</br>
</br>

### 실습 2
**1) Standard Table에 APPEND, READ, LOOP 사용**
```abap
TYPES: BEGIN OF ty_line,
        carrid TYPE sflight-carrid,
        connid TYPE sflight-connid,
        carrname TYPE scarr-carrname,
       END OF ty_line.

**********************************************************************

* Standard table 선언
DATA: lt_tab1 TYPE STANDARD TABLE OF ty_line
              WITH DEFAULT KEY,
      lt_tab2 TYPE STANDARD TABLE OF ty_line
              WITH NON-UNIQUE KEY CARRID CONNID.

DATA: ls_line TYPE ty_line. " work-area (wa)
ls_line-carrid = 'AA'.
ls_line-connid = '0017'.
ls_line-carrname = 'Add Data'.
APPEND ls_line TO lt_tab2.

ls_line-carrid = 'BB'.
ls_line-connid = '0064'.
ls_line-carrname = 'Add Data 2'.
APPEND ls_line TO lt_tab2.

ls_line-carrid = 'AA'.
ls_line-connid = '0017'.
ls_line-carrname = 'Add Data 3'.
APPEND ls_line TO lt_tab2.  " 키 중복

LOOP AT lt_tab2 INTO ls_line.
  WRITE:/ ls_line-carrid,
          ls_line-connid,
          ls_line-carrname.
ENDLOOP.

CLEAR ls_line.  "위에서 한번 사용했으니 초기화
READ TABLE lt_tab2 INTO ls_line
     WITH KEY CARRID = 'AA' CONNID = '0017'.
WRITE:/ 'Standard table: ',
      / ls_line-carrid, ls_line-carrname.
```
</br>
</br>
</br>

**2) Sorted Table에 INSERT, READ, LOOP 사용**
```abap
TYPES: BEGIN OF ty_line,
        carrid TYPE sflight-carrid,
        connid TYPE sflight-connid,
        carrname TYPE scarr-carrname,
       END OF ty_line.

**********************************************************************

* Sorted table 선언
DATA: lt_sort TYPE SORTED TABLE OF ty_line
              WITH NON-UNIQUE KEY CARRID CONNID.

" 데이터 추가
DATA: ls_line TYPE ty_line.
ls_line-carrid ='ZZ'.
ls_line-connid = '0017'.
ls_line-carrname = 'First Data'.
INSERT ls_line INTO TABLE lt_sort.

ls_line-carrid ='AA'.
ls_line-connid = '0017'.
ls_line-carrname = 'Second Data'.
* APPEND ls_line to lt_sort. "덤프 발생
INSERT ls_line INTO TABLE lt_sort.

READ TABLE lt_sort INTO ls_line INDEX 1.

IF sy-subrc = 0.
  WRITE:/ 'Sorted 결과: ',
          ls_line-carrid, ls_line-connid.
ENDIF.

LOOP AT lt_sort INTO ls_line.
  WRITE:/ ls_line-carrid,
          ls_line-connid,
          ls_line-carrname.
ENDLOOP.
```
</br>
</br>
</br>

**3) Hashed Table에 INSERT와 READ TABLE(키 기준) 사용**
```abap
TYPES: BEGIN OF ty_line,
        carrid TYPE sflight-carrid,
        connid TYPE sflight-connid,
        carrname TYPE scarr-carrname,
       END OF ty_line.

**********************************************************************

" Hashed Internal Table
DATA: lt_hash TYPE HASHED TABLE OF ty_line
              WITH UNIQUE KEY CARRID CONNID.
DATA: ls_line TYPE ty_line.
ls_line-carrid = 'AA'.
ls_line-connid = '0017'.
ls_line-carrname = 'Add Data'.
INSERT ls_line INTO TABLE lt_hash.

CLEAR ls_line.
*READ TABLE lt_hash INTO ls_line INDEX 1. " 에러 (해쉬테이블에는 인덱스 x)
READ TABLE lt_hash INTO ls_line
     WITH KEY CARRID = 'AA' CONNID = '0017'.
IF sy-subrc = 0.
  WRITE:/ 'Hashed 결과: ',
          ls_line-carrid, ls_line-connid.
ENDIF.
```
</br>
</br>
</br>

**4) DB 테이블 데이터를 Internal Table에 SELECT, LOOP 사용**
```abap
DATA: gt_flight TYPE TABLE OF SFLIGHT,
      gs_flight TYPE SFLIGHT.

SELECT *
  INTO TABLE gt_flight
  FROM sflight
  WHERE carrid = 'AA'
    AND CONNID = '0017'.

LOOP AT gt_flight INTO gs_flight.
  WRITE:/ gs_flight-carrid,
          gs_flight-connid,
          gs_flight-fldate.
ENDLOOP.
```
</br>
</br>
</br>

**5) Internal Table에 APPEND, INSERT, LOOP 사용**
```abap
DATA: gs_flight TYPE SFLIGHT,
      gt_flight LIKE TABLE OF gs_flight.

gs_flight-carrid = 'AA'.
gs_flight-connid = '0017'.
gs_flight-fldate = '20250501'.
gs_flight-price = '10000'.
gs_flight-currency = 'USD'.
gs_flight-seatsmax = 400.
gs_flight-seatsocc = 200.
APPEND gs_flight TO gt_flight.

gs_flight-carrid = 'BB'.
gs_flight-connid = '0027'.
gs_flight-fldate = '20260501'.
gs_flight-price = '1000'.
gs_flight-currency = 'EUR'.
gs_flight-seatsmax = 550.
gs_flight-seatsocc = 20.
APPEND gs_flight TO gt_flight.

gs_flight-carrid = 'AB'.
gs_flight-connid = '0064'.
gs_flight-fldate = '20270501'.
gs_flight-price = '2500'.
gs_flight-currency = 'EUR'.
gs_flight-seatsmax = 300.
gs_flight-seatsocc = 250.
INSERT gs_flight INTO TABLE gt_flight.

gs_flight-carrid = 'AC'.
gs_flight-connid = '0224'.
gs_flight-fldate = '20280501'.
gs_flight-price = '3000'.
gs_flight-currency = 'EUR'.
gs_flight-seatsmax = 60.
gs_flight-seatsocc = 5.
INSERT gs_flight INTO gt_flight INDEX 1.

LOOP AT gt_flight INTO gs_flight.
  WRITE:/ gs_flight-carrid,
          gs_flight-connid,
          gs_flight-fldate,
          gs_flight-price,
          gs_flight-currency,
          gs_flight-seatsmax,
          gs_flight-seatsocc.
ENDLOOP.
```
</br>
</br>
</br>

**6) Standard Table에 APPEND, INSERT, LOOP 사용**
```abap
DATA: gs_tab TYPE TABLE OF ZSCLB03_DEMO,    " 그냥 TABLE OF 하면 standard
      gs_line TYPE ZSCLB03_DEMO.

gs_line-CARRID = 'AA'.
gs_line-CARRNAME = '김예원'.
gs_line-CONNID = '0017'.
gs_line-CITYFROM = '인천'.
gs_line-CITYTO = '서울'.
APPEND gs_line TO gs_tab.

gs_line-CARRID = 'BB'.
gs_line-CARRNAME = '김예원'.
gs_line-CONNID = '0016'.
gs_line-CITYFROM = '광주'.
gs_line-CITYTO = '철원'.
INSERT gs_line INTO TABLE gs_tab.

gs_line-CARRID = 'CC'.
gs_line-CARRNAME = '김예원'.
gs_line-CONNID = '0015'.
gs_line-CITYFROM = '부산'.
gs_line-CITYTO = '인천'.
INSERT gs_line INTO gs_tab INDEX 1.

CLEAR gs_line.
LOOP AT gs_tab INTO gs_line.
  WRITE:/ gs_line-CARRID,
          gs_line-CARRNAME,
          gs_line-CONNID,
          gs_line-CITYFROM,
          gs_line-CITYTO.
ENDLOOP.
```
</br>

**7) Standard Table에서 READ, MODIFY, DELETE, LOOP 사용**
```abap
DATA: gs_flight TYPE SFLIGHT,
      gt_flight LIKE STANDARD TABLE OF gs_flight
      WITH NON-UNIQUE KEY CARRID CONNID FLDATE.

gs_flight-carrid = 'AA'.
gs_flight-connid = '0017'.
gs_flight-fldate = '20250501'.
gs_flight-price = '10000'.
gs_flight-currency = 'USD'.
gs_flight-seatsmax = 400.
gs_flight-seatsocc = 200.
APPEND gs_flight TO gt_flight.

gs_flight-carrid = 'BB'.
gs_flight-connid = '0027'.
gs_flight-fldate = '20260501'.
gs_flight-price = '1000'.
gs_flight-currency = 'EUR'.
gs_flight-seatsmax = 550.
gs_flight-seatsocc = 20.
APPEND gs_flight TO gt_flight.

gs_flight-carrid = 'AB'.
gs_flight-connid = '0027'.
gs_flight-fldate = '20260501'.
gs_flight-price = '1000'.
gs_flight-currency = 'EUR'.
gs_flight-seatsmax = 550.
gs_flight-seatsocc = 20.
APPEND gs_flight TO gt_flight.

gs_flight-carrid = 'BZ'.
gs_flight-connid = '0027'.
gs_flight-fldate = '20260501'.
gs_flight-price = '1000'.
gs_flight-currency = 'EUR'.
gs_flight-seatsmax = 550.
gs_flight-seatsocc = 20.
APPEND gs_flight TO gt_flight.

READ TABLE gt_flight INTO gs_flight
     WITH TABLE KEY CARRID = 'AA' CONNID = '0017' FLDATE = '20250501'.

*READ TABLE gt_flight INTO gs_flight
*     INDEX 1.

" 스트럭처의 값 변경
gs_flight-price = '9500'.
gs_flight-seatsmax = 555.

" 변경된 스트럭처를 Internal table의 첫번째 레코드에 적용(변경)
*MODIFY gt_flight FROM gs_flight INDEX 1.
MODIFY TABLE gt_flight FROM gs_flight.
*MODIFY gt_flight FROM gs_flight TRANSPORTING PRICE
*  WHERE CARRID = 'AA'.
MODIFY gt_flight FROM gs_flight INDEX 1 TRANSPORTING PRICE.

CLEAR gs_flight.
" READ TABLE 구분으로 Itab의 1번째 레코드 읽어서 gs_flight에 담는다
READ TABLE gt_flight INTO gs_flight INDEX 1.

  " 읽어온 1번째 레코드 gs_flight를 출력
*  WRITE:/ gs_flight-carrid,
*          gs_flight-connid,
*          gs_flight-fldate,
*          gs_flight-price,
*          gs_flight-seatsmax.

* Internal table에서 데이터 삭제
* => DALETE <itab> <condition>
*DELETE gt_flight INDEX 1.
*DELETE gt_flight FROM 3. " 3 이후부터 전부 삭제
*DELETE gt_flight TO 2.
*DELETE gt_flight FROM 2 TO 4. " 범위 지정하여 삭제
DELETE gt_flight WHERE carrid = 'AA'
                       AND connid = '0017'
                       AND fldate = '20250501'.

LOOP AT gt_flight INTO gs_flight.
  WRITE:/ gs_flight-carrid,
          gs_flight-connid,
          gs_flight-fldate,
          gs_flight-price,
          gs_flight-currency,
          gs_flight-seatsmax,
          gs_flight-seatsocc.
ENDLOOP.
```
</br>

**8) Standard Table에서 APPEND/INSERT LINES, MODIFY, DELETE, LOOP 사용**
```abap
TYPES: BEGIN OF ty_person,
         fname TYPE s_fname,
         lname TYPE s_lname,
       END OF ty_person.

DATA: gs_data  TYPE ty_person,
      gt_itab1  TYPE TABLE OF ty_person,
      gt_itab2 LIKE gt_itab1.

gs_data-fname = 'Hong'.
gs_data-lname = 'Gildong'.
APPEND gs_data TO gt_itab1.

gs_data-fname = 'Kim'.
gs_data-lname = 'donggu'.
APPEND gs_data TO gt_itab1.

" itab1의 전체 레코드를 itab2에 추가
APPEND LINES OF gt_itab1 TO gt_itab2.
INSERT LINES OF gt_itab1 INTO TABLE gt_itab2.

" 범위값 지정하여 여러 건의 레코드를 테이블에 추가
APPEND LINES OF gt_itab1 FROM 1 TO 2 TO gt_itab2.
INSERT LINES OF gt_itab1 FROM 2 INTO TABLE gt_itab2.
INSERT LINES OF gt_itab1 TO 2 INTO TABLE gt_itab2.

" Loop문으로 돌면서 modify
LOOP AT gt_itab2 INTO gs_data.
  gs_data-fname = '변경'.
  MODIFY gt_itab2 FROM gs_data.
ENDLOOP.

" Modify 적용 후, 적용된 Internal table을 Loop 사용하여 출력해보기
LOOP AT gt_itab2 INTO gs_data.
  WRITE:/ sy-tabix,
          gs_data-fname,
          gs_data-lname.
ENDLOOP.

ULINE.

" 범위값 지정하여 삭제
DELETE gt_itab2 WHERE lname = 'Gildong'.

" LOOP AT gt_itab2 INTO gs_data WHERE lname = 'Yewon'.
LOOP AT gt_itab2 INTO gs_data.
  WRITE:/ sy-tabix,
          gs_data-fname,
          gs_data-lname.
ENDLOOP.
```

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (11.24).md
</br>

# Internal Table 정리
</br>

**1) MOVE-CORRESPONDING**
- 동일한 이름을 가진 필드끼리 자동으로 값 복사
- 워크에어리어나 내부 테이블 행 단위로 사용 가능
```abap
MOVE-CORRESPONDING <source> TO <target>.
```
</br>
</br>

**2) SORT**
- 내부 테이블의 데이터를 지정 필드 기준으로 정렬
- Standard Table 기준, Sorted/Hashed Table에서는 일부 옵션 불가
```abap
SORT <itab>.                                " Table의 키 필드 기준 오름차순
SORT <itab> BY <field>.                     " 특정 필드 기준 오름차순(생략 시 기본)
SORT <itab> BY <field1> DESCENDING
               <field2> ASCENDING.            " field1 내림차순, field2 오름차순(생략 시 기본)
SORT <itab> BY <field1> <field2> DESCENDING. `" field1 오름차순(생략 시 기본), field2 내림차순
```
```abap
DATA: gt_flight TYPE TABLE OF flight.

" 기본 키 기준 정렬
SORT gt_flight.

" 단일 필드 기준 정렬
SORT gt_flight BY carrid.

" 다중 필드 정렬
SORT gt_flight BY carrid DESCENDING connid ASCENDING.
SORT gt_flight BY carrid connid DESCENDING.
```
</br>
</br>

**3) WITH HEADER LINE**
- 내부 테이블 안에 자동으로 한 줄(row)을 나타내는 구조를 생성
- 테이블 이름과 동일한 구조가 만들어져 별도 워크에어리어 없이 한 줄 데이터를 바로 사용 가능
  - `itab[]` → 테이블 전체
  - `itab` → 테이블의 헤더라인(한 줄)
```abap
DATA: <itab> TYPE TABLE OF <structure> WITH HEADER LINE.
```
```abap
DATA: gt_flight TYPE TABLE OF flight WITH HEADER LINE.

" 헤더라인 사용 예시
gt_flight-carrid = 'AA'.
APPEND gt_flight.
```
</br>
</br>

**4) REFRESH**
- 내부 테이블 내용 초기화
- 테이블이 존재하면 바디(데이터: `itab[]`)만 삭제, 구조와 타입은 유지
- 테이블이 없으면 생성 후 초기화
```abap
REFRESH <itab>.
```
```abap
DATA: gt_flight TYPE TABLE OF flight.

" 내부 테이블 내용 삭제
REFRESH gt_flight.
```
</br>
</br>

**5) CLEAR**
- 변수/워크에어리어를 초기화
- 숫자는 0, 문자형은 공백, 구조는 내부 필드별 초기화
- 단일 필드 또는 전체 구조 초기화 가능
```abap
CLEAR <variable>.
```
```abap
DATA: ls_flight TYPE flight.

CLEAR ls_flight.
" 모든 필드 0/공백으로 초기화
```
</br>
</br>

**6) FREE**
- 내부 테이블의 메모리까지 완전히 해제
- REFRESH와 달리 테이블 자체 메모리 공간도 반환
```abap
FREE <itab>.
```
```abap
DATA: gt_flight TYPE TABLE OF flight.

FREE gt_flight.
" 내부 테이블 삭제 + 메모리 해제
```
</br>
</br>
</br>

---
</br>

## < ABAP 추가 문법 >
</br>

**1) SELECT**
- `SELECT` = DB 조회, `LOOP` = 내부 테이블 순회
- ABAP 프로그램에서 데이터베이스 테이블의 데이터를 읽어오는 SQL 명령어
- `<field>`와 `<target>`의 구조가 동일해야 함
```abap
SELECT <field1> <field2> ...
  FROM <table>
  [INTO <target>]
  [WHERE <condition>]
  [ORDER BY <field>].
```
```abap
DATA: lt_flight TYPE TABLE OF sflight,
      ls_flight TYPE sflight.

" 모든 데이터 조회
SELECT * FROM sflight INTO TABLE lt_flight.

" 조건 조회
SELECT carrid connid
  FROM sflight
  INTO TABLE lt_flight
  WHERE carrid = 'AA'
  ORDER BY connid.
```
</br>
</br>

**2) Single (1건 조회)**
- 조건에 맞는 단일 레코드를 조회할 때 사용
- 부분 필드 조회 시 나머지 필드는 초기화됨
```abap
SELECT SINGLE <field1> <field2> ...
  FROM <table>
  INTO <target>
  WHERE <condition>.
```
```abap
DATA: ls_flight TYPE sflight.

" 단일 레코드 조회
SELECT SINGLE carrid connid
  FROM sflight
  INTO ls_flight
  WHERE carrid = 'AA' AND connid = '0017'.

WRITE: / ls_flight-carrid, ls_flight-connid.
```
</br>
</br>

**3) CORRESPONDING FIELDS OF**
- 이름이 같은 필드만 매핑
- 나머지 필드는 기존값 유지
```abap
<target_structure> = CORRESPONDING FIELDS OF <source_structure>.
```
- CORRESPONDING FIELDS OF 사용했을 때
```abap
DATA: ls_flight TYPE sflight.
ls_flight-cityfrom = 'Seoul'.  " 기존 값

SELECT SINGLE seatmax seatsocc
  FROM sflight
  INTO CORRESPONDING FIELDS OF ls_flight
  WHERE carrid = 'AA' AND connid = '0017'.

" 결과:
" ls_flight-seatmax = DB 값
" ls_flight-seatsocc = DB 값
" ls_flight-cityfrom = 'Seoul' (기존 값 그대로)
```
- CORRESPONDING FIELDS OF 사용하지 않았을 때
```abap
DATA: ls_flight TYPE sflight.
CLEAR ls_flight.

SELECT SINGLE seatmax seatsocc
  FROM sflight
  INTO ls_flight
  WHERE carrid = 'AA' AND connid = '0017'.

" 결과:
" ls_flight-seatmax = DB 값
" ls_flight-seatsocc = DB 값
" ls_flight-cityfrom = 초기화 (빈 값)
```
</br>
</br>

**4) SELECT … ENDSELECT (Row-by-Row)**
- 한 줄씩 DB에서 읽어오고, 읽을 때마다 바로 처리하는 방식 (다 건 SELECT 반복 조회)
- DB를 한 줄 가져올 때마다 계속 DB를 다시 호출하는 방식 → 느림
- 반면에, `LOOP AT`은 DB에서 한 번에 전체 데이터를 가져온 뒤 메모리에서 반복 → 빠름
- `sy-dbcnt` 사용 가능
```abap
SELECT <필드목록>                  " <필드목록> : 가져올 컬럼 이름 (예: carrid, connid)
  FROM <테이블명>                  " <테이블명> : DB 테이블 이름 (예: sflight)
  INTO <워크에어리어 변수>          " <워크에어리어 변수> : 데이터를 담을 ABAP 변수/구조
  [WHERE <조건문>]                 " WHERE : 선택 조건 (선택 사항)
  [ORDER BY <정렬필드>].            " ORDER BY : 정렬 조건 (선택 사항)
  
  " 처리 로직 작성 (레코드 하나씩 처리)
  
ENDSELECT.
```
```abap
DATA: ls_connect TYPE spfli.

SELECT *
  FROM spfli
  INTO ls_connect
  WHERE carrid = 'AA'.

  WRITE: / ls_connect-connid.
ENDSELECT.
```
</br>
</br>

**5) SELECT … INTO TABLE (Array Fetch)**
- 조건에 맞는 데이터 전체를 한 번에 인터널 테이블로 가져옴
- 한 번에 전체 레코드 Fetch → 빠름
```abap
SELECT <필드목록>
  FROM <테이블명>
  INTO [CORRESPONDING FIELDS OF] TABLE <인터널테이블>
  [WHERE <조건>].
```
```abap
DATA: lt_connect TYPE TABLE OF spfli.

SELECT *
  FROM spfli
  INTO TABLE lt_connect
  WHERE carrid = 'AA'.

LOOP AT lt_connect INTO DATA(ls_connect).
  WRITE: / ls_connect-connid.
ENDLOOP.
```
</br>
</br>

**6) SELECT-OPTIONS**
- 사용자가 입력한 범위나 조건을 DB 조회용으로 저장하는 ABAP 키워드
- 내부적으로 테이블 구조로 만들어지며, 단일 값, 범위, 제외 조건까지 처리 가능
- FOR 뒤에는 `데이터 오브젝트(필드)`가 들어가야 함.
```abap
SELECT-OPTIONS: <옵션이름> FOR <필드> [DEFAULT <값>].
```
```abap
DATA: gt_connect TYPE TABLE OF spfli,
      gs_connect TYPE spfli.

PARAMETERS: pa_car TYPE s_carr_id DEFAULT 'AA'.

" 사용자 입력 범위 생성 (connid 17이 기본값)
SELECT-OPTIONS: so_con FOR gs_connect-connid DEFAULT '17'.

" 조회 시 SELECT-OPTIONS 범위 적용
SELECT *
  FROM spfli
  INTO CORRESPONDING FIELDS OF TABLE gt_connect
  WHERE carrid = pa_car
    AND connid IN so_con.

LOOP AT gt_connect INTO gs_connect.
  WRITE:/ gs_connect-carrid,
        gs_connect-connid,
        gs_connect-cityfrom.
ENDLOOP.
```
</br>
</br>
</br>

---
</br>

## < ABAP 데이터 모델과 데이터베이스 관계 이해 >
**1) ABAP Dictionary (SE11)**
- 데이터 구조를 논리적으로 정의하는 곳
- 테이블, 뷰, 구조, 데이터 요소 등을 설계하지만, 실제 데이터는 저장하지 않음
- 프로그램에서 사용할 데이터의 설계도 역할을 합니다.
- Transparent Table로 정의하면 DB에 1:1 매핑됩니다.
</br>
</br>

**2) Relational Database (DB)**
- 실제 데이터를 물리적으로 저장하는 공간
- Dictionary에서 정의한 테이블 구조를 기반으로 DB에 생성
- 데이터가 존재하며, 프로그램에서 읽고 쓸 수 있음
</br>
</br>

**3) Transparent Table**
- Dictionary에서 정의하면 DB에 1:1 매핑되는 테이블
- 구조를 알 수 있기 때문에 프로그램에서는 DATA <structure>로 선언하여 바로 사용 가능합니다.
- MANDT(Client) 필드는 항상 포함되어야 하는 필수 필드
  - 다중 클라이언트 환경에서 데이터 구분용
  - SAP 시스템에서 클라이언트를 식별하는 역할
  - 예: `MANDT = client`

 </br>
 
  <img width="559" height="378" alt="image" src="https://github.com/user-attachments/assets/a577c609-6dbb-4d44-8da5-3c0d9f6978bd" />

</br>
</br>
</br>

## < ABAP 3티어 구조와 Open SQL 처리 흐름 >
</br>

### ABAP 3티어 구조
1) Application Layer (애플리케이션 서버)
   - ABAP 프로그램이 실행되는 곳
   - 비즈니스 로직 처리
2) Database Layer (DB 서버)
   - 실제 데이터를 저장하는 곳
   - RDBMS (Oracle, HANA 등)
3) Presentation Layer (UI)
   - 사용자와 시스템이 상호작용하는 인터페이스
</br>


### SQL 사용 방식
**1) Native SQL**
- 특정 DB에 맞는 SQL 문을 직접 작성
- DB 고유 기능 활용 가능
- 다른 DB로 변경하면 SQL 문도 수정해야 함

**2) Open SQL**
- ABAP에서 표준 SQL 문법 사용
- Database Interface를 거쳐 DB에 맞게 변환
- DB 종류가 바뀌어도 프로그램 수정 없이 그대로 사용 가능
</br>


### Database Interface 역할
1. Open SQL 문법 체크
2. Open SQL → Native SQL 변환
3. 결과를 버퍼에 저장
   
<img width="498" height="341" alt="image" src="https://github.com/user-attachments/assets/c440c952-b86d-4e29-a5c5-9b86499b082a" />
</br>

<img width="478" height="310" alt="image" src="https://github.com/user-attachments/assets/1e2b9d76-178b-4210-9fca-a5d5d0f38ca8" />

</br>
</br>

---

</br>

## < 실습 코드 >

### 실습 1
- LOOP AT 반복문과 MODIFY, Header Line, Sort를 이용하여 결과 출력
```abap
DATA: gs_data TYPE bc400_s_flight,
      gt_data TYPE TABLE OF bc400_s_flight.

" Header Line이 포함된 인터널 테이블 변수 선언
" => 아래에서 사용한 gs_data/gt_data를 gt_hline으로 바꿔보는걸로..
DATA: gt_data2 TYPE TABLE OF bc400_s_flight WITH HEADER LINE.

SELECT carrid connid fldate seatsmax seatsocc
  FROM sflight
  INTO TABLE gt_data
  WHERE carrid = 'AA'.

" 1) 만약 sy-subrc가 0 이라면
" gt_data를 LOOP 돌면서 Percentage 계산하여 MODIFY를 이용해 반영한다.
" 계산식 : percentage = seatsocc * 100 / seatmax

IF ( sy-subrc = 0 ).
  LOOP AT gt_data INTO gs_data.
    gs_data-percentage = gs_data-seatsocc * 100 / gs_data-seatsmax.
    MODIFY gt_data FROM gs_data.
  ENDLOOP.
ENDIF.

SORT gt_data BY connid ASCENDING
                percentage DESCENDING.

" 2) percentage 반영된 itab을 LOOP 돌면서,
"    percentage 가 80을 초과하는 레코드만 출력한다. (출력필드는 전체필드 기준)

CLEAR gs_data.
LOOP AT gt_data INTO gs_data WHERE percentage > 80.
  WRITE:/ gs_data-carrid,
          gs_data-connid,
          gs_data-fldate,
          gs_data-seatsmax,
          gs_data-seatsocc,
          gs_data-percentage.
ENDLOOP.
```
</br>
</br>
</br>

### 실습 2
- function module로 carrid, connid를 받으면 spfli에서 1건 조회하여 반환하는 로직 구현
  
**1) Import 표 채우기**

<img width="599" height="127" alt="image" src="https://github.com/user-attachments/assets/356d3c61-3fff-442c-a3d2-f36c32fd3eb8" />

</br>

**2) Export 표 채우기**

<img width="599" height="108" alt="image" src="https://github.com/user-attachments/assets/e7aaadb5-08f8-42f9-b6a3-24d1c4c268ba" />

</br>

**3) Exceptions 표 채우기**

<img width="599" height="130" alt="image" src="https://github.com/user-attachments/assets/1e247174-54a7-465d-b975-cc45e696f5c0" />

</br>
</br>

**4) Function Module 코드**
```abap
FUNCTION z_bc400_03_connection_get.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(IV_CARRID) TYPE  S_CARR_ID
*"     REFERENCE(IV_CONNID) TYPE  S_CONN_ID
*"  EXPORTING
*"     REFERENCE(ES_CONNECTION) TYPE  BC400_S_CONNECTION
*"  EXCEPTIONS
*"      NO_DATA
*"----------------------------------------------------------------------

  SELECT SINGLE carrid connid cityfrom airpfrom cityto airpto fltime deptime
    FROM spfli
    INTO es_connection
    WHERE carrid = iv_carrid AND connid = iv_connid.

  IF sy-subrc <> 0.
    RAISE no_data.
  ENDIF.

ENDFUNCTION.
```
</br>

**5) Program 코드**
```abap
PARAMETERS: p_carrid TYPE c LENGTH 3,
            p_connid TYPE n LENGTH 4.
DATA: gs_data TYPE bc400_s_connection.

CALL FUNCTION 'Z_BC400_03_CONNECTION_GET'
  EXPORTING
    iv_carrid     = p_carrid
    iv_connid     = p_connid
  IMPORTING
    es_connection = gs_data
  EXCEPTIONS
    no_data       = 1
    OTHERS        = 2.

IF sy-subrc <> 0.
  MESSAGE '데이터가 없습니다.' TYPE 'E'.
ELSE.
  WRITE:/ gs_data-carrid, gs_data-connid,
          gs_data-cityfrom, gs_data-airpfrom,
          gs_data-cityto, gs_data-airpto,
          gs_data-fltime, gs_data-deptime,
          gs_data-arrtime.
ENDIF.
```
</br>
</br>
</br>

### 실습 3
- select 세 가지 종류
  
**1) Single Select (단 건 조회)**
```abap
* SELECT LOOP
DATA: ls_connect  TYPE BC400_s_connection,
      lt_connects LIKE TABLE OF ls_connect.

PARAMETERS: pa_car TYPE s_carr_id.

SELECT *
  FROM spfli
  INTO CORRESPONDING FIELDS OF ls_connect
  WHERE carrid = pa_car.
  " 참고) 여기선 sy-dbcnt로 index를 얻을 수 있음
    APPEND ls_connect TO lt_connects.
  WRITE: ls_connect-arrtime.
ENDSELECT.

IF sy-subrc <> 0.
  MESSAGE 'Data is not exist' TYPE 'E'.
ELSE.
  cl_demo_output=>display( lt_connects ).
ENDIF.
```
</br>

**2) SELECT ~ ENDSELECT (다 건 반복 조회)**
```abap
FUNCTION z_bc400_03_flightlist_get.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(IV_CARRID) TYPE  S_CARR_ID
*"     REFERENCE(IV_CONNID) TYPE  S_CONN_ID
*"  EXPORTING
*"     REFERENCE(ET_FLIGHTS) TYPE  BC400_T_FLIGHTS
*"  EXCEPTIONS
*"      NO_DATA
*"----------------------------------------------------------------------
  DATA: ls_flight TYPE bc400_s_flight.

  SELECT carrid connid fldate seatsmax seatsocc
    FROM sflight
    INTO ls_flight
    WHERE carrid = iv_carrid AND connid = iv_connid.
      ls_flight-percentage = ( ls_flight-seatsmax / ls_flight-seatsocc ) * 100.
      APPEND ls_flight TO et_flights.
  ENDSELECT.

  IF sy-subrc <> 0.
    RAISE no_data.
  ELSE.
    SORT et_flights BY percentage DESCENDING.
  ENDIF.

ENDFUNCTION.
```
</br>

**3) SELECT ~ INTO TABLE (다 건 한번에 조회)**
```abap
FUNCTION Z_BC400_03_FLIGHTLIST_GET_OPT.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(IV_CARRID) TYPE  S_CARR_ID
*"     REFERENCE(IV_CONNID) TYPE  S_CONN_ID
*"  EXPORTING
*"     REFERENCE(ET_FLIGHTS) TYPE  BC400_T_FLIGHTS
*"  EXCEPTIONS
*"      NO_DATA
*"----------------------------------------------------------------------

DATA: ls_flight TYPE bc400_s_flight.

SELECT carrid connid fldate seatsmax seatsocc
  FROM sflight
  INTO TABLE et_flights
  WHERE carrid = iv_carrid AND connid = iv_connid.

IF sy-subrc <> 0.
    RAISE no_data.
  ELSE.
    LOOP AT et_flights INTO ls_flight.
      ls_flight-percentage = ( ls_flight-seatsmax / ls_flight-seatsocc ) * 100.
      MODIFY et_flights FROM ls_flight INDEX sy-tabix TRANSPORTING percentage.
    ENDLOOP.

    SORT et_flights BY percentage DESCENDING.
  ENDIF.

ENDFUNCTION.
```
</br>

**4) SELECT-OPTIONS**
```abap
DATA: gs_connect TYPE BC400_S_CONNECTION,
      gt_connect TYPE BC400_T_CONNECTIONS.
DATA: gv_dt TYPE S_DATE.

PARAMETERS: pa_car TYPE s_carr_id DEFAULT 'AA'.

SELECT-OPTIONS: so_con FOR gs_connect-connid DEFAULT '17',
                so_fdt FOR gv_dt.
*SELECT-OPTIONS: so_con2 FOR S_CONN_ID. " 오류!
* => FOR 뒤에는 TYPE이 들어오는게 아니라 DATA Object

SELECT *
  INTO CORRESPONDING FIELDS OF TABLE gt_connect
  FROM spfli
  WHERE carrid = pa_car
    AND connid IN so_con.

LOOP AT gt_connect INTO gs_connect.
  WRITE:/ gs_connect-carrid,
        gs_connect-connid,
        gs_connect-cityfrom.
ENDLOOP.
```

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (11.25).md
</br>

## < SELECT 관련 함수 >

### 1) SELECT 집계 함수
- 데이터베이스 테이블의 값을 요약/통계 내는 함수
- 단일 값 계산, 그룹별 계산 가능
- `COUNT`, `MIN`, `MAX`, `SUM`, `AVG`
```abap
SELECT COUNT(*) AS <별칭_총레코드수>,
       MIN(<필드>) AS <별칭_최소값>,
       MAX(<필드>) AS <별칭_최대값>,
       SUM(<필드>) AS <별칭_합계>,
       AVG(<필드>) AS <별칭_평균>
  FROM <테이블>
  INTO <워크에어리어 또는 내부테이블>
  WHERE <조건>            "선택적
  GROUP BY <필드>          "필요 시
  HAVING <조건>           "필요 시
```
```abap
DATA: lt_flightocc TYPE TABLE OF sflight_occ.

SELECT carrid,
       COUNT(*) AS total_flights,
       MIN(seatsocc) AS min_seats,
       MAX(seatsocc) AS max_seats,
       SUM(seatsocc) AS sum_seats,
       AVG(seatsocc) AS avg_seats
  FROM sflight
  INTO TABLE @lt_flightocc
  GROUP BY carrid
  HAVING COUNT(*) >= 5.

" 각 carrid별 항공편 수, 좌석 최소/최대/합계/평균 조회
" 항공편 5개 이상인 carrid만 포함
```
- `COUNT( DISTINCT 필드명 )` : 중복이 제거된 필드의 갯수
```abap
" 전체 유니크 항공사 수
SELECT COUNT(DISTINCT carrid) 
  FROM sflight 
  INTO @DATA(total).
```
</br>
</br>

### 2) SELECT - GROUP BY + HAVING
- `GROUP BY` → 특정 필드 기준으로 레코드를 그룹화
- `HAVING` → 그룹화된 결과에 조건 적용 (WHERE는 개별 행 조건, HAVING은 그룹 조건)
```abap
SELECT <그룹필드1> <그룹필드2> …,
       <집계함수1> AS <별칭1>,
       <집계함수2> AS <별칭2>
  FROM <DB 테이블>
  INTO <워크에어리어 또는 내부 테이블>
  WHERE <조건>           "선택적
  GROUP BY <그룹필드1> <그룹필드2> …
  HAVING <조건>.         "그룹 조건
```
```abap
SELECT carrid,
       COUNT(*) AS total_flights
  FROM sflight
  INTO TABLE @lt_flight
  GROUP BY carrid
  HAVING COUNT(*) >= 5.      " 항공편 수가 5개 이상인 carrid만 포함
```
</br>
</br>

### 3) SELECT - WHERE 조건
- 조건에 맞는 데이터만 조회할 때 사용
- `%` : 0개 이상 문자 대체, `_` : 정확히 1글자 대체
  
| 연산자 | 설명 |
|---|---|
| `=`, `<`, `>`, `<=`, `>=`, `<>` | 비교 연산자 (같다, 크다, 작다 등) |
| `IN (dobj1, dobj2, …)` | 값 목록에 포함 여부 |
| `BETWEEN dobj1 AND dobj2` | 범위 내 값 포함 |
| `LIKE dobj1` | 패턴 매칭 (`%`, `_` 사용) |
| `IN seltab` | 내부 테이블 값 포함 여부 |
| `IS [NOT] NULL` | NULL 여부 검사 |
| `AND`, `OR`, `NOT` | 논리 조건 결합 / 부정 |

</br>

```abap
DATA: lt_sflight TYPE TABLE OF sflight,
      lt_spfli   TYPE TABLE OF spfli.

SELECT * FROM sflight
  INTO TABLE @lt_sflight
  WHERE seats > 10.
" 결과 예시: seats가 11, 20, 50 등 10 초과인 항공편 조회

SELECT * FROM sflight
  INTO TABLE @lt_sflight
  WHERE carrid IN ('AA','LH').
" 결과 예시: carrid가 'AA' 또는 'LH'인 항공편 조회

SELECT * FROM spfli
  INTO TABLE @lt_spfli
  WHERE cityfrom LIKE 'S%O'.
" 결과 예시: cityfrom이 'S'로 시작하고 'O'로 끝나는 도시 조회
" 예: 'SEOUL', 'STOCKHOLM'

DATA: gt_carriers TYPE TABLE OF sflight-carrid.
" (gt_carriers 내부에 carrid 값이 들어있다고 가정)
SELECT * FROM sflight
  INTO TABLE @lt_sflight
  WHERE carrid IN @gt_carriers.
" 결과 예시: 내부 테이블 gt_carriers에 포함된 carrid의 항공편 조회

SELECT * FROM sflight
  INTO TABLE @lt_sflight
  WHERE seats IS NOT NULL.
" 결과 예시: seats 컬럼 값이 NULL이 아닌 모든 항공편 조회

SELECT * FROM sflight
  INTO TABLE @lt_sflight
  WHERE carrid = 'AA' AND seats > 10.
" 결과 예시: carrid가 'AA'이고 seats가 10 초과인 항공편 조회
```
</br>
</br>

### 4) SELECT … ORDER BY
- 조회 결과를 특정 필드 기준으로 정렬
```abap
SELECT <필드1> <필드2> … 
  FROM <테이블>
  INTO TABLE @<내부테이블>
  WHERE <조건>
  ORDER BY <필드> [ASCENDING|DESCENDING].
```
```abap
DATA: lt_sflight TYPE TABLE OF sflight.

" 프라이머리 키(CARRID + CONNID) 순서대로 조회
SELECT carrid connid seats
  FROM sflight
  INTO TABLE @lt_sflight
  ORDER BY PRIMARY KEY.
" 결과: carrid 오름차순, 동일 carrid 내에서는 connid 오름차순 조회
```
</br>
</br>

### 5) SELECT DISTINCT
- 중복을 제거하고 유일한 값만 조회
- `DISTINCT`는 DB 조회 시 중복 레코드 제거, `DELETE ADJACENT DUPLICATES`는 정렬된 내부 테이블에서 인접 중복만 제거
```abap
SELECT DISTINCT <필드1> <필드2> …
  FROM <테이블>
  INTO TABLE @<내부테이블>
  WHERE <조건>.
```
```abap
DATA: gt_flight TYPE TABLE OF sflight.

SELECT DISTINCT carrid connid
  FROM sflight
  INTO TABLE @gt_flight
  WHERE seatsocc > 200.
" 결과: seatsocc > 200인 항공편 중 carrid+connid 조합이 중복 없이 조회
```
</br>
</br>

---

</br>

## < ABAP 추가 문법 >
### 1) FOR ALL ENTRIES IN
- 내부 테이블의 값들을 기준으로 DB에서 데이터를 조회
- 다중 조건 가능
- 내부 테이블이 비어있으면 전체 조회되므로 체크 필요
- `FOR ALL ENTRIES IN <내부 테이블>` → 어떤 내부 테이블의 값들을 조건으로 쓸지 지정
- `WHERE <DB필드> = <내부테이블-필드>` → 실제 비교 조건 작성
```abap
SELECT <필드>
  FROM <DB 테이블>
  INTO <내부 테이블 또는 변수>
  FOR ALL ENTRIES IN <내부 테이블>
  WHERE <조건 = 내부테이블-필드>.
```
```abap
IF gt_data IS NOT INITIAL.
  SELECT *
    FROM sflight
    INTO TABLE @gt_result
    FOR ALL ENTRIES IN @gt_data
    WHERE carrid = @gt_data-carrid.
ENDIF.
```
</br>
</br>

### 2) DELETE ADJACENT DUPLICATES
- 정렬된 내부 테이블에서 연속된 중복 레코드를 삭제
- 중복 기준 필드를 지정 가능
- `<내부테이블>` → 중복을 제거할 내부 테이블
- `COMPARING` → 특정 필드 기준으로 중복 제거 (생략하면 전체 구조 기준)
```abap
DELETE ADJACENT DUPLICATES FROM <내부테이블>
  [COMPARING <필드1> <필드2> ...].
```
```abap
DATA: it_numbers TYPE TABLE OF i,
      wa_number  TYPE i.

APPEND 10 TO it_numbers.
APPEND 10 TO it_numbers.
APPEND 20 TO it_numbers.
APPEND 20 TO it_numbers.
APPEND 30 TO it_numbers.

DELETE ADJACENT DUPLICATES FROM it_numbers.
```
</br>
</br>

### 3) WITH HEADER LINE
- 내부 테이블 안에 자동으로 한 줄(row)을 나타내는 구조를 생성
- 테이블 이름과 동일한 구조가 만들어져 별도 워크에어리어 없이 한 줄 데이터를 바로 사용 가능
  - `itab[]` → 테이블 전체
  - `itab` → 테이블의 헤더라인(한 줄)
```abap
DATA: <itab> TYPE TABLE OF <structure> WITH HEADER LINE.
```
- INTO 절 생략 가능
```abap
LOOP AT gt_hline.
  WRITE: gt_hline-carrid.  "헤더 라인 사용 덕분에 INTO 생략 가능
ENDLOOP.
```
- MODIFY 시 자동 참조
```abap
gt_hline-percentage = gt_hline-seatsocc * 100 / gt_hline-seatsmax.
MODIFY gt_hline.  "워크 에어리어(gt_hline)를 테이블에 적용
```
- 실습
```abap
" Header Line이 있는 Internal table 선언
" gt_hline은 Structure, gt_hline[] 은 Itab 이 된다.
DATA: gt_hline TYPE TABLE OF bc400_s_flight WITH HEADER LINE.

SELECT carrid connid fldate seatsmax seatsocc
  FROM sflight
  INTO TABLE gt_hline[]
  WHERE carrid = 'AA'.

IF ( sy-subrc = 0 ).
  LOOP AT gt_hline.       " INTO 절 생략 가능
    gt_hline-percentage = gt_hline-seatsocc * 100 / gt_hline-seatsmax.
    MODIFY gt_hline.
  ENDLOOP.
ENDIF.

SORT gt_hline[] BY connid ASCENDING
                   percentage DESCENDING.

CLEAR gt_hline.
LOOP AT gt_hline WHERE percentage > 80.
  WRITE:/ gt_hline-carrid,
          gt_hline-connid,
          gt_hline-fldate,
          gt_hline-seatsmax,
          gt_hline-seatsocc,
          gt_hline-percentage.
ENDLOOP.
```
</br>
</br>

### 4) cl_demo_output=>display
- 내부 테이블 또는 구조를 간단히 화면에 출력
```abap
cl_demo_output=>display( <itab> ).
```
```abap
IF sy-subrc = 0.
  cl_demo_output=>display( gt_result ).
ENDIF.
```

</br>
</br>

---

</br>

## < ABAP 개념 정리 >
</br>

### Selection Screen 주요 특징
- 실행 버튼 누르면 DB 테이블에서 조건에 맞는 데이터 추출
- 다국어 처리 지원
- 입력 값 타입 자동 체크 (예: 숫자, 날짜, 문자열)
- 입력 값 저장 및 재사용 가능
- 복잡한 조건(범위, 다중 선택 등) 처리 가능
- 입력 값 범위 및 형식 제한 기능 (F4 도움말 등)
</br>

### 파라미터 선언 예시 및 특징
- `TYPE` 뒤에 올 수 있는 타입은 표준 타입 혹은 데이터 딕셔너리 필드 타입
- 파라미터는 단일 입력값 받음
- 입력 필드의 데이터 타입이 자동 적용됨 (숫자, 문자열 등)
```abap
PARAMETERS: pa_car TYPE s_carr_id.
PARAMETERS: pa_car TYPE spfli-carrid.
```
</br>

### Select-Options 관련 주요 사항
- 선언 시 `TYPE`이 아니라 `FOR` 키워드 사용
```abap
SELECT-OPTIONS: so_car FOR spfli-carrid.
```
- FOR 뒤에는 이미 선언된 데이터 오브젝트나 DDIC 필드명을 사용
- Select-options는 내부적으로 테이블(ITAB) 구조를 가짐
- Select-options 로 입력된 범위값을 사용할 때는 IN 키워드 사용
- 만약 so_car가 빈 값이면 조건 없이 전체 조회됨
```abap
SELECT * FROM spfli WHERE carrid IN so_car.
```
</br>

### SELECT-OPTIONS 필드 정의

| 필드명 | 의미 |
|--------|------|
| SIGN   | 포함(I, Include) 또는 제외(E, Exclude) |
| OPTION | 연산자 (EQ = 같음, BT = 범위, GE = 이상 등) |
| LOW    | 범위 시작값 (From) |
| HIGH   | 범위 끝값 (To, BT 연산자에서 사용) |

- 예시

| 조건 설명                          | SIGN | OPTION | LOW  | HIGH |
|-----------------------------------|------|--------|------|------|
| LH 값만 포함                        | I    | EQ     | LH   |      |
| AA부터 DL까지 포함                  | I    | BT     | AA   | DL   |
| BA 값 제외                          | E    | EQ     | BA   |      |

</br>
</br>

---

</br>

## < 실습 코드 >
</br>

### 실습 1
- SELECT-OPTIONS와 SELECT 이용해서 LOOP로 출력하기
```abap
DATA: gs_data TYPE SBOOK,
      gt_data LIKE TABLE OF gs_data.

PARAMETERS: pa_car TYPE S_CARR_ID DEFAULT 'AZ',
            pa_con TYPE S_CONN_ID DEFAULT '0555'.

SELECT-OPTIONS: so_dat FOR gs_data-FLDATE.


SELECT * FROM SBOOK
  INTO CORRESPONDING FIELDS OF TABLE gt_data
  WHERE CARRID = pa_car
    AND CONNID = pa_con
    AND FLDATE IN so_dat.

LOOP AT gt_data INTO gs_data.
  WRITE:/ gs_data-CARRID, gs_data-CONNID, gs_data-FLDATE,
          gs_data-BOOKID, gs_data-CUSTOMID, gs_data-CUSTTYPE.
ENDLOOP.
```
</br>
</br>

### 실습 2
- FOR ALL ENTRIES IN 사용해서 출력
```abap
DATA: gt_data TYPE TABLE OF sflight,
      gt_result TYPE TABLE OF sflight.

SELECT carrid
  FROM sflight
  INTO CORRESPONDING FIELDS OF TABLE gt_data
  WHERE carrid IN ('AA', 'AZ', 'LH').
  " carrid가 'AA', 'AZ', 'LH'에 포함되는 레코드만 조회

IF gt_data IS INITIAL.
  SORT gt_data BY carrid.   " carrid 오름차순 정렬
  " gt_data에 carrid가 중복된 레코드는 삭제
  " => 중복 레코드가 존재하면, 자동 제거되지 않고 DB 요청이 들어감
  " => 그만큼 속도가 늦어지는 것이기 때문에 SELECT 전애
  " => 정렬 및 중복제거를 해주는 것이 좋다.
  DELETE ADJACENT DUPLICATES FROM gt_data COMPARING carrid.

  SELECT * FROM sflight
    INTO CORRESPONDING FIELDS OF TABLE gt_result
    FOR ALL ENTRIES IN gt_data
    WHERE carrid = gt_data-carrid.
      " AND connid = gt_data-connid. 여러 필드 가능

    " 주의! FOR ALL ~ 로 사용하는 gt_data가 비어있으면
    " 테이블 전체를 조회하므로. 대량 데이터의 Table일 경우
    " 시스템이 다운될 수 있음. 따라서 gt_data가 있는 경우를
    " 체크해주는 것이 안전하다.

  IF sy-subrc = 0.
    cl_demo_output=>display( gt_result ).
  ENDIF.
ENDIF.
```
</br>
</br>

### 실습 3
- FOR ALL ENTRIES IN 사용해서 조회된 항공사 목록을 이용해 항공편 목록 출력
```abap
DATA: gs_data   TYPE scarr,
      gt_data   LIKE TABLE OF gs_data,
      gt_result TYPE TABLE OF sflight.

SELECT-OPTIONS: so_car FOR gs_data-carrid.

SELECT * FROM scarr
  INTO CORRESPONDING FIELDS OF TABLE gt_data
  WHERE carrid IN so_car.

SELECT * FROM sflight
  INTO CORRESPONDING FIELDS OF TABLE gt_result
  FOR ALL ENTRIES IN gt_data
  WHERE carrid = gt_data-carrid.

cl_demo_output=>display( gt_result ).
```
</br>
</br>

### 실습 4
- order by 실습
```abap
DATA: gs_sflight TYPE sflight,
      gt_sflight TYPE TABLE OF sflight.

* Key 값으로 정렬
SELECT *
  INTO CORRESPONDING FIELDS OF TABLE gt_sflight
  FROM SFLIGHT
  ORDER BY SEATSMAX DESCENDING.
* ORDER BY PRIMARY KEY.
* ORDER BY carrid DESCENDING, connid ASCENDING

IF sy-subrc = 0.
  cl_demo_output=>display( gt_sflight ).
*  LOOP AT gt_sflight INTO gs_sflight.
*    WRITE:/ gs_sflight-carrid,
*            gs_sflight-connid,
*            gs_sflight-fldate.
*  ENDLOOP.
ENDIF.
```
</br>
</br>

### 실습 5
- SELECT DISTINCT 실습습
```abap
DATA: gs_sflight TYPE sflight,
      gt_sflight TYPE TABLE OF sflight.

* Key 값으로 정렬
SELECT DISTINCT CARRID CONNID
  INTO CORRESPONDING FIELDS OF TABLE gt_sflight
  FROM SFLIGHT
  ORDER BY CARRID CONNID.

IF sy-subrc = 0.
  LOOP AT gt_sflight INTO gs_sflight.
    WRITE:/ gs_sflight-carrid,
            gs_sflight-connid.
  ENDLOOP.
ENDIF.
```
</br>
</br>

### 실습 6
- SELECT 집계함수 실습
```abap
* MIN, MAX, SUM, AVG, COUNT에 대한 내용
* 만약 COUNT( DISTINCT 필드명 ) 입력 시
* 중복이 제거된 필드의 갯수를 얻을 수 있음
DATA: BEGIN OF gs_data,
        MIN TYPE sflight-seatsocc,
        MAX TYPE sflight-seatsocc,
        SUM TYPE sflight-seatsocc,
        AVG TYPE F,
        CNT TYPE I,
      END OF gs_data.
DATA: gv_cnt TYPE I.

SELECT MIN( SEATSOCC ) MAX( SEATSOCC )
       SUM( SEATSOCC ) AVG( SEATSOCC )
       COUNT( * )
  FROM SFLIGHT
  INTO gs_data
  WHERE carrid = 'LH'
    AND connid = '0400'.

SELECT COUNT( DISTINCT connid )
  FROM SFLIGHT
  INTO gv_cnt
  WHERE carrid = 'AA'.

WRITE: 'gv_cnt', gv_cnt.

IF sy-subrc = 0.
  WRITE:/ 'MIN', 10 gs_data-MIN,
        / 'MAX', 10 gs_data-MAX,
        / 'SUM', 10 gs_data-SUM,
        / 'AVG', 10 gs_data-AVG,
        / 'CNT', 10 gs_data-CNT.
ENDIF.
```
</br>
</br>

### 실습 7
- GROUP BY + HAVING 절 실습
```abap
DATA: BEGIN OF gs_data,
        connid TYPE sflight-connid,
        minvar TYPE sflight-seatsocc,
        maxvar TYPE sflight-seatsocc,
        sumvar TYPE sflight-seatsocc,
        avgvar TYPE P LENGTH 3 DECIMALS 2,
      END OF gs_data.
DATA: gt_data LIKE TABLE OF gs_data.

SELECT CONNID MIN( seatsocc ) MAX( seatsocc )
       SUM( seatsocc ) AVG( seatsocc )
  FROM SFLIGHT
  INTO TABLE gt_data
  WHERE carrid = 'LH'   " carrid가 LH인 것만 조회해라
  GROUP BY connid       " 그 중, connid로 그룹화해라
  HAVING SUM( seatsocc ) >= 300.
  " 그룹화된 결과 데이터 중에, SUM( seatsocc )필드가 300 이상인 데이터만 조회해라

IF sy-subrc = 0.
  cl_demo_output=>display( gt_data ).
ENDIF.
```

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (11.26).md
</br>

## < Table Join 방법 >
### 1) Database View 이용
- DB 레벨에서 여러 테이블을 미리 조인하여 가상 테이블(View) 생성
- 재사용 가능, SQL 최적화, 코드 간결
- 조건 변경에는 유연하지 않음
```abap
SELECT <필드1> <필드2> ...
  FROM <DatabaseView>
  WHERE <조건>.
```
```
SELECT carrid connid carrname      
  FROM zabc        " zabc는 이미 여러 테이블을 조인해 만든 Database View
  WHERE carrid = 'LH'.
```
</br>

### 2) 프로그램에서 직접 조인
- ABAP 프로그램 안에서 SELECT문에서 직접 JOIN 수행
- 조건을 동적으로 처리 가능, 유연성 높음
- 코드 길어지고, DB 최적화는 View보다 어려움
</br>

- `INNER JOIN` : 두 테이블 모두에 있는 데이터만 반환 (교집합)
- `LEFT OUTER JOIN` : 왼쪽 테이블 기준, 오른쪽 테이블 없으면 NULL 포함
- `RIGHT OUTER JOIN` : 오른쪽 테이블 기준, 왼쪽 테이블 없으면 NULL 포함
</br>

- `-` : 필드 접근용 (JOIN 에서만 안씀)
- `~` : JOIN 사용 시에만 사용
```abap
SELECT <테이블1~필드>, <테이블2~필드>
  INTO TABLE <내테이블>
  FROM <테이블1>
  INNER JOIN <테이블2>
  ON <테이블1~키> = <테이블2~키>
  WHERE <조건>.
```
```abap
SELECT SCARR~CARRID
       SPFLI~CONNID
       SCARR~CARRNAME
       SPFLI~CITYFROM
  INTO TABLE lt_flight
  FROM SCARR as A INNER JOIN SPFLI as B
    ON SCARR~CARRID = SPFLI~CARRID      " spfli와 scarr 모두 존재하는 carrid만 결과에 포함
  WHERE SCARR~CARRID = 'AA'.

  IF sy-subrc = 0.
    cl_demo_output=>display( lt_flight ).
  ENDIF.
```
```abap
TYPES: BEGIN OF ts_data,
        CARRID TYPE SCARR-CARRID,
        CONNID TYPE SFLIGHT-CONNID,
        FLDATE TYPE SFLIGHT-FLDATE,
       END OF ts_data.

DATA: gs_data TYPE ts_data,
      gt_data TYPE TABLE OF ts_data.

SELECT C~CARRID F~CONNID F~FLDATE
  INTO TABLE gt_data
  FROM SCARR AS C INNER JOIN SFLIGHT AS F
    ON C~CARRID = F~CARRID
  WHERE C~CARRID = 'AA'.

  IF sy-subrc = 0.
    cl_demo_output=>display( gt_data ).
  ENDIF.
```
</br>
</br>

---

</br>

## < ABAP EVENT >
- 프로그램 실행 시점에 자동 호출되는 코드 블록
- 주요 이벤트
  - **INITIALIZATION**
    - 프로그램 시작 시 실행
    - 화면이나 변수의 초기값 설정
  - **AT SELECTION-SCREEN**
    - 사용자가 셀렉션 스크린에 입력한 값 처리
    - 입력값 검증이나 추가 처리 수행
  - **START-OF-SELECTION**
    - SAP에서 사전 정의된 이벤트
    - 프로그램 실행 시 자동 호출
    - 메인 처리 로직 수행 (데이터 조회, 주요 작업)
- 주의 및 특징
  - 동일 이벤트 중복 선언 불가
  - 모든 이벤트 작성 필요 없음 (필요한 것만 사용)
  - 이벤트 순서와 상관없이 호출 시점에 따라 실행됨
```abap
REPORT z_event_example.

" 초기값 설정
INITIALIZATION.
  gv_title = '항공편 조회 프로그램'.

" 셀렉션 스크린 입력값 검증
PARAMETERS: p_carrid TYPE spfli-carrid.

AT SELECTION-SCREEN.
  IF p_carrid IS INITIAL.
    MESSAGE '항공사를 입력하세요.' TYPE 'E'.
  ENDIF.

" 메인 처리 로직
START-OF-SELECTION.
  SELECT * FROM spfli
    WHERE carrid = p_carrid
    INTO TABLE @DATA(lt_spfli).

  LOOP AT lt_spfli INTO DATA(ls_spfli).
    WRITE: / ls_spfli-carrid, ls_spfli-connid, ls_spfli-cityfrom, ls_spfli-cityto.
  ENDLOOP.
```
</br>
</br>

---

</br>

## < Class 클래스 (SE24) >
- 객체를 만들기 위한 틀. 속성과 기능을 정의.
- 객체(인스턴스): 클래스에서 만들어진 실제 존재하는 개별 데이터 단위
- 클래스 구성
  - 속성(Attributes): 객체 상태 정보
  - 메서드(Methods): 객체가 수행하는 기능
- 접근 제한자
  - `public` : 외부에서 접근 가능
  - `private` : 외부에서 접근 불가
- 객체 특징
  - 각 객체는 독립적인 메모리 보유 → 속성/메서드 상태가 객체마다 다름 (`instance component`)
  - 모든 객체가 공통으로 접근하는 속성/메서드 → `static component`
- **Method 코드 형식**
```abap
METHOD <method_name>.
  " 로컬 변수 선언
  DATA <var_name> TYPE <type>.

  " 파라미터 체크 / 조건 처리
  IF <조건>.
    <출력 변수> = <값>.
    RAISE EXCEPTION TYPE <exception_type>.
  ELSE.
    " 계산 / 반복 / TRY-CATCH 가능
    TRY.
        <연산 로직>
      CATCH <exception_type>.
        <출력 변수> = <값>.
        RAISE EXCEPTION TYPE <exception_type>.
    ENDTRY.
  ENDIF.

ENDMETHOD.
```
- Program에서 Method 호출 형식
```abap
DATA gv_result TYPE <type>.

TRY.
    CALL METHOD <class_name>=><method_name>
      EXPORTING
        iv_param1 = <값>
        iv_param2 = <값>
      IMPORTING
        ev_result = gv_result
      .
  CATCH <exception_type>.
    " 예외 처리
ENDTRY.

WRITE: / gv_result.
```
</br>
</br>

---

</br>

## < ABAP 추가 문법 >
</br>

**1) APPENDING**
- SELECT 결과를 기존 내부 테이블 뒤에 이어서 추가
- 기존 데이터는 그대로 유지
- 필드명이 같은 컬럼끼리 자동 매칭
- 구문 비교:
  - `INTO TABLE itab` → 내부테이블 기존 내용 삭제 후 새 데이터
  - `APPENDING CORRESPONDING FIELDS OF TABLE itab` → 기존 데이터 유지 후 추가
```abap
SELECT <필드1> <필드2> ...
  FROM <테이블>
  APPENDING CORRESPONDING FIELDS OF TABLE <itab>  " `INTO` 대신 `APPENDING` 넣기
  WHERE <조건>.
```
</br>
</br>

**2) CLIENT SPECIFIED**
- SAP ABAP에서 일반적으로 SELECT는 현재 클라이언트(sy-mandt) 기준으로만 데이터 조회.
- CLIENT SPECIFIED를 사용하면 MANDT 값을 직접 지정하여 다른 클라이언트 데이터도 조회 가능.
- 주의: 잘못 사용하면 보안/데이터 일관성 문제 발생 가능.
```abap
SELECT fields
  INTO <TABLE|STRUCTURE>
  FROM dbtable
  CLIENT SPECIFIED
  WHERE mandt = '값'.
```
```abap
DATA: lt_scarr TYPE TABLE OF SCARR.

SELECT *
  INTO CORRESPONDING FIELDS OF TABLE lt_scarr
  FROM SCARR
  CLIENT SPECIFIED
  WHERE mandt BETWEEN '000' AND '800'.

IF sy-subrc = 0.
  cl_demo_output=>display( lt_scarr ).
ENDIF.
```
</br>
</br>

**3) AUTHORITY-CHECK (SU21)**
- 사용자가 특정 권한을 가지고 있는지 확인하는 ABAP 구문
- Role 부여: 특정 사용자에게 역할(Role)을 부여하면 해당 권한 획득
- 권한 객체(Object) + 필드(ID) + 액티비티(ACTVT) 기반으로 체크
- ACTVT(Activity): 수행 가능한 작업 지정
  - `01` = Create
  - `02` = Change
  - `03` = Display
- AUTHORITY-CHECK: ABAP에서 사용자 권한을 확인하는 구문
  - 성공 여부는 sy-subrc로 판단 (0 = 권한 있음, <>0 = 권한 없음)
```abap
AUTHORITY-CHECK OBJECT '<권한객체>'
  ID '<필드1>' FIELD <값1>
  ID '<필드2>' FIELD <값2>
  ...
IF sy-subrc = 0.
  " 권한 있음 처리
ELSE.
  " 권한 없음 처리
ENDIF.
```
```abap
AUTHORITY-CHECK OBJECT 'S_CARRID'
  ID 'CARRID' FIELD iv_carrid
  ID 'ACTVT' FIELD '03'.  " Display 권한 체크

IF sy-subrc = 0.
  " 권한 있음 → 데이터 조회
  SELECT * FROM spfli WHERE carrid = iv_carrid.
ELSE.
  " 권한 없음 → 메시지 처리
  MESSAGE '권한이 없습니다.' TYPE 'E'.
ENDIF.
```
</br>
</br>

**4) SELECT-OPTIONS + APPEND/CLEAR**
- SELECT-OPTIONS: 화면에서 범위 조건 입력용, 내부적으로 `SIGN / OPTION / LOW / HIGH` 구조
- `SELECT-OPTIONS`는 데이터베이스 테이블 필드를 직접 참조할 수 없고, 해당 필드가 포함된 이미 선언된 변수(Work Area 또는 Structure)의 필드를 통해 참조해야 함
- Select-options는 Header Line 있는 itab 이므로 APPEND 시 TO 절 생략 가능
- `APPEND` : 조건을 내부 테이블에 추가
- `CLEAR` : 헤더라인 초기화 → 다음 조건 입력 준비


| ABAP OPTION 값 | 의미 (Meaning) | LOW/HIGH 사용 | SQL 연산자 개념 |
| :---: | :--- | :---: | :---: |
| **`EQ`** | Equal (같음) | `LOW` 값만 사용 | `fieldName = LOW` |
| **`BT`** | Between (사이) | `LOW`와 `HIGH` 값 모두 사용 | `fieldName BETWEEN LOW AND HIGH` |
| **`GE`** | Greater or Equal (크거나 같음) | `LOW` 값만 사용 | `fieldName >= LOW` |
| **`LE`** | Less or Equal (작거나 같음) | `LOW` 값만 사용 | `fieldName <= LOW` |
| **`GT`** | Greater Than (초과) | `LOW` 값만 사용 | `fieldName > LOW` |
| **`LT`** | Less Than (미만) | `LOW` 값만 사용 | `fieldName < LOW` |
| **`CP`** | Contains Pattern (패턴 포함) | `LOW` 값만 사용 (`*`, `?` 등 사용) | `fieldName LIKE LOW` |
| **`NE`** | Not Equal (같지 않음) | `LOW` 값만 사용 | `fieldName != LOW` (또는 `NOT =`) |
| **`NP`** | Not Contains Pattern (패턴 불일치) | `LOW` 값만 사용 | `NOT (fieldName LIKE LOW)` |


```abap
" 1. SELECT-OPTIONS 선언
SELECT-OPTIONS: <so_name> FOR <field>.

" 2. 헤더라인 변수에 값 설정 후 APPEND
<so_name>-SIGN   = '<Include / Exclude>';   " 예: 'I' 또는 'E'
<so_name>-OPTION = '<연산자>';            " 예: 'EQ', 'BT', 'GE' 등
<so_name>-LOW    = '<시작값>';            " 범위 시작값
<so_name>-HIGH   = '<끝값>';              " 범위 끝값 (BT일 경우)
APPEND <so_name>.                           " 내부 테이블에 적용
CLEAR <so_name>.                            " 헤더라인 초기화 후 다음 조건 설정
```
```abap
DATA: gt_flight TYPE TABLE OF sflight,
      gs_flight TYPE sflight.

" SELECT-OPTIONS 선언 (구조 필드 기준)
SELECT-OPTIONS: so_conn FOR gs_flight-connid.

INITIALIZATION.
  " 포함 조건: 0400
  so_conn-SIGN   = 'I'.
  so_conn-OPTION = 'EQ'.
  so_conn-LOW    = '0400'.
  APPEND so_conn.
  CLEAR so_conn.

  " 제외 조건: 0401
  so_conn-SIGN   = 'E'.
  so_conn-OPTION = 'EQ'.
  so_conn-LOW    = '0401'.
  APPEND so_conn.
  CLEAR so_conn.

START-OF-SELECTION.
  " 조건 적용 SELECT
  SELECT *
    FROM sflight
    INTO TABLE gt_flight
    WHERE connid IN so_conn.

  cl_demo_output=>display( gt_flight ).      " 결과 : CONNID = 0400 만
```
</br>
</br>

---

</br>

## < ABAP 추가적인 개념 >
</br>

### Secondary Index
- 기본 키(primary key) 외에 추가로 만드는 검색용 인덱스
- 특정 필드 조합으로 데이터를 더 빠르게 찾기 위해 사용
- WHERE 조건에 인덱스 필드가 포함되면 → DB 검색 속도 향상
</br>

### Table Buffer (테이블 버퍼링)
- 자주 사용하는 테이블 데이터를 DB에서 읽지 않고 메모리(Buffer) 에 저장해두고 읽는 방식
- 버퍼에 있으면 DB 접근 없이 바로 조회 → 조회 속도 매우 빠름
- 읽기 중심 테이블에 적합, 변경이 잦은 테이블에는 비권장
- 테이블마다 `버퍼링 허용 여부`를 SAP Dictionary(SE11)에서 설정
</br>

### DB & 내부 테이블 연산 정리
- **INSERT** : 값 없을 때 새로 추가
- **UPDATE** : 값 있을 때 갱신
- **DELETE** : 값 삭제
- **MODIFY (DB)** : 값 있으면 UPDATE, 없으면 INSERT
- **MODIFY (ITAB)** : 조건에 맞는 행만 갱신, 값 없으면 추가되지 않음

</br>
</br>

---

</br>

## < 실습 코드 >
</br>

### 실습 1
- Event 함수 실습
```abap
DATA: gt_flight TYPE TABLE OF SFLIGHT,
      gs_flight LIKE LINE OF gt_flight.

SELECT-OPTIONS: so_con FOR gs_flight-connid.
PARAMETERS: pa_car TYPE sflight-carrid,
            pa_chk TYPE CHAR01 AS CHECKBOX DEFAULT 'X'.

INITIALIZATION.
  pa_car = 'LH'.
  so_con-SIGN = 'I'.
  so_con-OPTION = 'EQ'.
  so_con-LOW = '0400'.
  so_con-HIGH = '0402'.
  APPEND so_con. " 원래 APPEND SO_CON TO SO_SON 처럼
                 " TO~부분이 있어야 하지만, Select-options는
                 " Header Line 있는 itab 이므로 생략
  CLEAR so_con.  " Header(Structure)만 클리어

  so_con-SIGN = 'E'.
  so_con-OPTION = 'EQ'.
  so_con-LOW = '0400'.      " 0400 제외하고 조회
  APPEND so_con.
  CLEAR so_con.

AT SELECTION-SCREEN.
  IF pa_chk = 'X' AND pa_car IS INITIAL.
    MESSAGE 'carrid를 입력하세요~~~~' TYPE 'E'.
  ENDIF.

START-OF-SELECTION.
  SELECT *
    FROM SFLIGHT
    INTO CORRESPONDING FIELDS OF TABLE gt_flight
    WHERE CARRID = PA_CAR
      AND CONNID IN SO_CON.

  IF sy-subrc = 0.
    cl_demo_output=>display( gt_flight ).
  ENDIF.
```
</br>
</br>

### 실습 2
- Event 함수, Function Module 실습
```abap
PARAMETERS: pa_car TYPE S_CARR_ID.
DATA: gt_data TYPE BC400_T_CONNECTIONS.
" TABLE OF로 가져오고 싶으면 KEY 설정 맞추기
" DATA: gt_data TYPE STANDARD TABLE OF BC400_S_CONNECTION WITH NON-UNIQUE KEY CARRID CONNID. 

AT SELECTION-SCREEN.
  IF pa_car IS INITIAL.
    MESSAGE 'pa_car가 입력되지 않았습니다.' TYPE 'E'.
  ENDIF.

START-OF-SELECTION.
  CALL FUNCTION 'ZGET_CONNECT03'
    EXPORTING
      iv_carrid = pa_car
    IMPORTING
      ET_CONNECT = gt_data
    EXCEPTIONS
      NO_DATA   = 1
      OTHERS    = 2.

  IF sy-subrc <> 0.
    MESSAGE 'No Data error!' TYPE 'E'.
  ELSE.
    cl_demo_output=>display( gt_data ).
  ENDIF.
```
</br>
</br>

### 실습 3
- class/method 코드
```abap
METHOD get_power.
  DATA lv_power TYPE bc400_compute_power.

*Simple error handling
  IF iv_power >= 5 OR iv_power <= 0.
    ev_result = 0.
    RAISE EXCEPTION TYPE cx_bc400_power_too_high.
*Calculate result
  ELSEIF iv_power = 1.
    ev_result = iv_base.
  ELSE.
    TRY.
        ev_result = iv_base * iv_base.
        lv_power = iv_power - 1.

        WHILE sy-index < lv_power .
          ev_result =  ev_result * iv_base.
        ENDWHILE.
      CATCH cx_sy_arithmetic_overflow.
        ev_result = 0.
        RAISE EXCEPTION TYPE cx_bc400_result_too_high.
    ENDTRY.
  ENDIF.
ENDMETHOD.
```
- program 코드
```abap
TYPES tv_result TYPE P LENGTH 16 DECIMALS 2.

PARAMETERS: pa_int1 TYPE I,
            pa_int2 TYPE I.

DATA: gv_result TYPE tv_result.

TRY.
CALL METHOD cl_bc400_compute=>get_power
  EXPORTING
    iv_base  = pa_int1
    iv_power = pa_int2
  IMPORTING
   ev_result = gv_result
  .
  CATCH cx_bc400_power_too_high.
    MESSAGE 'Power too high!!' TYPE 'E'.
  CATCH cx_bc400_result_too_high.
    MESSAGE 'Result too high!!' TYPE 'E.'.
ENDTRY.

WRITE:/ gv_result.
```
</br>
</br>

### 실습 4
- class(method 가져오기) 실습
```abap
PARAMETERS: CARRID TYPE S_CARR_ID,
            CONNID TYPE S_CONN_ID.
DATA: gt_data TYPE BC400_T_FLIGHTS.

INITIALIZATION.
  CARRID = 'AA'.
  CONNID = '0017'.

AT SELECTION-SCREEN.
  IF ( CARRID IS INITIAL OR CONNID IS INITIAL ).
    MESSAGE 'CARRID 나 CONNID 가 빈 값입니다.' TYPE 'E'.
  ENDIF.

START-OF-SELECTION.
  TRY.
  CALL METHOD cl_bc400_flightmodel=>get_flights
    EXPORTING
      iv_carrid = CARRID
      iv_connid = CONNID
    IMPORTING
     et_flights = gt_data.

    CATCH cx_bc400_no_data.
      MESSAGE 'ERROR ! : No Data for Selection' TYPE 'E'.
    CATCH cx_bc400_no_auth.
      MESSAGE 'EEROR ! : No Authorization for Airline' TYPE 'E'.
  ENDTRY.

  cl_demo_output=>display( gt_data ).
```

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (11.27).md
</br>

## < Data Dictionary: Domain & Data Element >
- Domain과 Data Element는 `1 : N` 관계
- 1개의 Domain → 여러 Data Element에서 사용 가능
</br>

<img width="327" height="152" alt="image" src="https://github.com/user-attachments/assets/3bbba7ad-47a1-4fdf-8719-c13fc4627dbd" />

</br>
</br>
</br>

### Domain (도메인)
- 데이터의 타입과 속성을 정의하는 단위
  - 데이터 형식, 길이, 소수점, 문자/숫자 구분 등 속성을 정의
- 숫자 음수 사용 여부 지정 가능 → `Sign` 속성 체크 시 음수 입력 허용
- 소문자 사용 여부 지정 가능 → `Case` 속성 체크 시 소문자 입력 가능
  
<img width="492" height="328" alt="image" src="https://github.com/user-attachments/assets/dfebe42f-4966-4074-84fd-366c8a833528" />

</br>
</br>
</br>

### Data Element (데이터 요소)
- 실제 테이블 필드나 구조 필드에 사용되는 논리적 이름
- Domain 기반 생성 → Domain에서 정의된 형식을 그대로 사용
- Domain 선택은 선택 사항
  - Domain 사용 시: 타입, 길이, 음수 허용 여부, 소문자 허용 여부 등 속성을 한번에 관리 가능
    - Domain 속성을 수정하면 해당 Domain을 참조하는 모든 Data Element가 자동으로 변경
  - Domain 미사용 시: Built-in Type으로 직접 타입 지정 가능
- 도메인 1개를 여러 Data Element에서 재사용 가능

<img width="495" height="269" alt="image" src="https://github.com/user-attachments/assets/abb423ba-3983-4a1d-ad33-ab0b7cb7a437" />
</br>
</br>
</br>
</br>

- **`text Element -> Selelction Texts -> DDIC Reference` 하면 short description 뜸**
<img width="491" height="166" alt="image" src="https://github.com/user-attachments/assets/543260b8-6384-469e-a105-b218af963d6e" />

</br>
</br>

---

</br>

## < Structure Types (스트럭처 타입) >
### 1) Simple Structure (단순 구조)
- 일반적으로 사용하는 기본 스트럭처
- 필드 안에 또 다른 구조나 테이블이 없는 구조
```abap
TYPES: BEGIN OF ty_simple,
         name TYPE string,
         age  TYPE i,
       END OF ty_simple.
```
</br>
</br>


### 2) Nested Structure (중첩 구조)
- 어떤 필드 안에 또 다른 스트럭처가 포함된 구조
- 구조 안에 구조를 넣어 계층적으로 데이터 표현 가능
```abap
TYPES: BEGIN OF ty_address,
         city    TYPE string,
         zipcode TYPE string,
       END OF ty_address.

TYPES: BEGIN OF ty_person,
         name    TYPE string,
         age     TYPE i,
         address TYPE ty_address, "스트럭처 안 스트럭처
       END OF ty_person.
```
</br>
</br>


### 3) Deep Structure (딥 구조)
- 어떤 필드 안에 인터널 테이블 형태의 테이블 타입이 들어간 구조
- 구조 안에 테이블을 넣어 1:N 관계 데이터를 표현 가능
```abap
TYPES: BEGIN OF ty_order_item,
         item_id TYPE i,
         qty     TYPE i,
       END OF ty_order_item.

TYPES: ty_order_items TYPE STANDARD TABLE OF ty_order_item WITH DEFAULT KEY.

TYPES: BEGIN OF ty_order,
         order_id TYPE i,
         items    TYPE ty_order_items, "스트럭처 안 테이블
       END OF ty_order.
```
</br>
</br>
</br>
</br>

## < Structure와 INCLUDE 접근 방식 >

<img width="508" height="198" alt="image" src="https://github.com/user-attachments/assets/4686de91-e543-43d7-9c2f-78271a78a0a7" />

### 1) `.INCLUDE` 사용
- 스트럭처 안에 INCLUDE로 다른 구조체를 포함했을 때
- INCLUDE 안의 필드는 최상위 구조체 필드처럼 바로 접근 가능
```abap
TYPES: BEGIN OF ty_addr,
         street TYPE string,
         city   TYPE string,
       END OF ty_addr.

TYPES: BEGIN OF ty_person,
         name TYPE string,
         INCLUDE TYPE ty_addr, "포함
       END OF ty_person.

DATA person TYPE ty_person.

"접근
person-street = 'Main Street'.
person-city   = 'Seoul'.
```
</br>
</br>

### 2) 구조체 필드 이름으로 직접 포함(예: addr)
- 구조체 안에 필드명으로 다른 구조체를 선언했을 때
- 접근할 때는 상위 구조체 → 필드 → 하위 필드 형태로 접근
```abap
TYPES: BEGIN OF ty_person,
         name TYPE string,
         addr TYPE ty_addr,  "필드명으로 포함
       END OF ty_person.

DATA person TYPE ty_person.

"접근
person-addr-street = 'Main Street'.
person-addr-city   = 'Seoul'.
```
</br>
</br>
</br>
</br>

## < Line Type으로 설정 가능한 타입 (ABAP Table Type) >

| Line Type 종류                | 설명 |
|-------------------------------|------|
| **Data Element**              | 단일 필드(스칼라 타입)를 행 구조로 사용 |
| **Structure (Structure Type)**| 여러 필드로 이루어진 스트럭처를 행 타입으로 사용 |
| **Transparent Table**         | 투명 테이블의 한 Row 전체 구조를 행 타입으로 사용 |
| **Database View**             | 데이터베이스 뷰의 Row 구조를 행 타입으로 사용 |
| **Projection View**           | Projection View에서 노출된 필드 구조를 행 타입으로 사용 |

</br>
</br>

---

</br>

## < Type Group(타입 그룹) >
- 여러 TYPES, CONSTANTS, MACRO(DEFINE) 등을 한 묶음으로 모아놓은 그룹
- 프로그램에서 사용 시 `TYPE-POOL <이름>` 으로 로드
- 이름은 최대 5자리
**1) 타입 그룹 정의 형식(DIC에서 작성)**
- 타입 그룹 안의 객체 이름 형식: `<타입그룹명>_<오브젝트명>`
```abap
TYPE-POOL <타입그룹이름>.       "타입 그룹 선언

TYPES: <타입이름> TYPE <자료형>,     "타입 정의
       ...  

CONSTANTS: <상수이름> TYPE <자료형> VALUE <값>,   "상수 정의
           ...  
```
</br>

**2) Program 에서 사용 형식** 
```abap
TYPE-POOL <타입그룹이름>.          "타입 그룹 불러오기

DATA <변수명> TYPE <타입그룹이름>_<타입이름>.   "타입 그룹의 타입 사용
```
</br>
</br>

---

</br>

## < 실습 코드 >
### 실습 1
- 특정 필드에 대해 중복제거 및 정렬하여 조회하기
```abap
DATA: gs_data TYPE SFLIGHT,
      gt_data LIKE TABLE OF gs_data.

SELECT DISTINCT CARRID, CONNID, CURRENCY FROM SFLIGHT
  INTO CORRESPONDING FIELDS OF TABLE @gt_data
  ORDER BY CARRID DESCENDING, CONNID ASCENDING.

LOOP AT gt_data INTO gs_data.
  WRITE: / gs_data-CARRID, gs_data-CONNID, gs_data-CURRENCY.
ENDLOOP.
```
</br>
</br>

### 실습 2
- domain과 data element 실습
  
**1) domain 정의**

<img width="328" height="272" alt="image" src="https://github.com/user-attachments/assets/4a1d0680-2f2d-4c0f-92ce-4a0b3cfe5b44" />
</br>
</br>

**2) data element 정의**

<img width="457" height="270" alt="image" src="https://github.com/user-attachments/assets/6f183cf8-29d2-4be0-a69f-a1beaaecbce3" />
</br>
</br>

**3) program 코드**
```abap
PARAMETERS: pa_fname TYPE ZFIRSTNAME03,
            pa_lname TYPE ZLASTNAME03,
            pa_activ TYPE ZASSETS03,
            pa_liabs TYPE ZLIABILITIES03.
DATA: gv_result TYPE P LENGTH 10 DECIMALS 2.


gv_result = pa_activ - pa_liabs.
WRITE:/ 'FIrst Name: ', pa_fname,
      / 'Last Name: ', pa_lname,
      / 'Assets: ', pa_activ,
      / 'Liabilities: ', pa_liabs,
      / 'Assets - Liabilities : ', gv_result.
```
</br>
</br>

### 실습 2
- Nested Structure 실습 ( 스트럭처 ZSSCARR_B03을 스트럭처 ZSSPFLI_B03 안에 포함시키기 )

**1) ZSSCARR_B03 정의**

<img width="556" height="168" alt="image" src="https://github.com/user-attachments/assets/b699b62b-2738-4312-9793-d542f97f5bbd" />

</br>
</br>

**2)  ZSSPFLI_B03 정의**

<img width="553" height="226" alt="image" src="https://github.com/user-attachments/assets/ed083fa4-379b-49aa-9de4-9e1b36601205" />

</br>
</br>
</br>

### 실습 3
- Structure와 INCLUDE 접근 방식 실습
```abap
DATA: gs_person TYPE ZPERSON_B03.

gs_person-phone = '010-8952-0763'.
gs_person-name-fname = 'Kim'.   " 필드 안에 스트럭처
gs_person-name-lname = 'yewon'.
gs_person-street = 'Gangnam'.   " .Include 스트럭처
gs_person-city = 'Seoul'.

WRITE:/ gs_person-phone,
      / gs_person-name-fname,
      / gs_person-name-lname,
      / gs_person-street,
      / gs_person-city.
```
</br>
</br>

### 실습 4
- Deep Structure 실습 ( Structure 안에 Table 구조 )
```abap
DATA: ls_person TYPE ZPERSON_B03,
      ls_phone TYPE LINE OF ZPERSON_B03-PHONE.    " table 타입에서 line of 로 생성했으므로 structure 변수
" DATA: ls_phone TYPE STR_PHONE과 같음
" DATA: ls_phone LIKE LINE OF ls_phone-PHONE과 같음

ls_person-fname = 'Hong'.
ls_person-lname = 'Gildong'.
ls_person-street = 'Gangnam'.
ls_person-city = 'Seoul'.

ls_phone-p_type = 'TEL'.
ls_phone-p_number = '010-1234-5678'.
APPEND ls_phone TO ls_person-phone. " itab에 1건추가

ls_phone-p_type = 'FAX'.
ls_phone-p_number = '02-214-3456'.
APPEND ls_phone TO ls_person-phone.

ls_phone-p_type = 'MOB'.
ls_phone-p_number = '010-9876-5432'.
APPEND ls_phone TO ls_person-phone.

WRITE: 'OKOK'.
```
</br>
</br>

### 실습 5
- Deep Structure 실습 ( 다하고 디버깅으로 확인 )
```abap
PARAMETERS: pa_carr TYPE S_CARR_ID.

DATA: gs_scar TYPE SCARR,
      gt_spfli TYPE ZSSCARR_B03-SPFLIINFO.

SELECT SINGLE * FROM SCARR
  INTO gs_scar
  WHERE carrid = pa_carr.
  
BREAK-POINT.
  
SELECT * FROM SPFLI
  INTO CORRESPONDING FIELDS OF TABLE gt_spfli
  WHERE carrid = pa_carr.
  
BREAK-POINT.
```
</br>
</br>

### 실습 6
**1) 타입 그룹 정의 형식(DIC에서 작성)**
```abap
TYPE-POOL ZTB03 .

TYPES ztb03_percentage(3) TYPE P DECIMALS 2.
CONSTANTS ztb03_pi TYPE F VALUE '3.14'.
```
</br>

**2) Program 에서 사용 형식** 
- icon 그림 표 보고 싶을 때는 SE38 -> SHOWICON 쳐서 실행
- 색상 표 보고싶을 때는 SE38 -> DEMO_LIST_FORMAT_COLOR_1 쳐서 실행
```abap
TYPE-POOLS: ZTB03, COL, ICON.

DATA: gv_percent TYPE ztb03_percentage.

WRITE:/ 'BACKGROUND' COLOR COL_BACKGROUND,
      / 'HEADING' COLOR COL_HEADING,
      / 'NORMAL' COLOR COL_NORMAL,
      / 'TOTAL' COLOR COL_TOTAL,
      / 'KEY' COLOR COL_KEY,
      / 'POSITIVE' COLOR COL_POSITIVE,
      / 'NEGATIVE' COLOR COL_NEGATIVE,
      / 'GROUP' COLOR COL_GROUP.

WRITE:/ '5B' AS ICON,
        '5C' AS ICON,
        '5D' AS ICON.
```

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (11.28).md
</br>

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (12.01).md
</br>

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (12.02).md
</br>

</br>
</br>
</br>
</br>
