# Internal Table 정리
</br>

**1) MOVE-CORRESPONDING**
- 동일한 이름을 가진 필드끼리 자동으로 값 복사
- 워크에어리어나 내부 테이블 행 단위로 사용 가능
```abap
MOVE-CORRESPONDING <source> TO <target>.
```
</br>
</br>

**2) SORT**
- 내부 테이블의 데이터를 지정 필드 기준으로 정렬
- Standard Table 기준, Sorted/Hashed Table에서는 일부 옵션 불가
```abap
SORT <itab>.                                " Table의 키 필드 기준 오름차순
SORT <itab> BY <field>.                     " 특정 필드 기준 오름차순(생략 시 기본)
SORT <itab> BY <field1> DESCENDING
               <field2> ASCENDING.            " field1 내림차순, field2 오름차순(생략 시 기본)
SORT <itab> BY <field1> <field2> DESCENDING. `" field1 오름차순(생략 시 기본), field2 내림차순
```
```abap
DATA: gt_flight TYPE TABLE OF flight.

" 기본 키 기준 정렬
SORT gt_flight.

" 단일 필드 기준 정렬
SORT gt_flight BY carrid.

" 다중 필드 정렬
SORT gt_flight BY carrid DESCENDING connid ASCENDING.
SORT gt_flight BY carrid connid DESCENDING.
```
</br>
</br>

**3) WITH HEADER LINE**
- 내부 테이블 안에 자동으로 한 줄(row)을 나타내는 구조를 생성
- 테이블 이름과 동일한 구조가 만들어져 별도 워크에어리어 없이 한 줄 데이터를 바로 사용 가능
  - `itab[]` → 테이블 전체
  - `itab` → 테이블의 헤더라인(한 줄)
```abap
DATA: <itab> TYPE TABLE OF <structure> WITH HEADER LINE.
```
```abap
DATA: gt_flight TYPE TABLE OF flight WITH HEADER LINE.

" 헤더라인 사용 예시
gt_flight-carrid = 'AA'.
APPEND gt_flight.
```
</br>
</br>

**4) REFRESH**
- 내부 테이블 내용 초기화
- 테이블이 존재하면 바디(데이터: `itab[]`)만 삭제, 구조와 타입은 유지
- 테이블이 없으면 생성 후 초기화
```abap
REFRESH <itab>.
```
```abap
DATA: gt_flight TYPE TABLE OF flight.

" 내부 테이블 내용 삭제
REFRESH gt_flight.
```
</br>
</br>

**5) CLEAR**
- 변수/워크에어리어를 초기화
- 숫자는 0, 문자형은 공백, 구조는 내부 필드별 초기화
- 단일 필드 또는 전체 구조 초기화 가능
```abap
CLEAR <variable>.
```
```abap
DATA: ls_flight TYPE flight.

CLEAR ls_flight.
" 모든 필드 0/공백으로 초기화
```
</br>
</br>

**6) FREE**
- 내부 테이블의 메모리까지 완전히 해제
- REFRESH와 달리 테이블 자체 메모리 공간도 반환
```abap
FREE <itab>.
```
```abap
DATA: gt_flight TYPE TABLE OF flight.

FREE gt_flight.
" 내부 테이블 삭제 + 메모리 해제
```
</br>
</br>
</br>

---
</br>

## < ABAP 추가 문법 >
</br>

**1) SELECT**
- ABAP 프로그램에서 데이터베이스 테이블의 데이터를 읽어오는 SQL 명령어
- `<field>`와 `<target>`의 구조가 동일해야 함
```abap
SELECT <field1> <field2> ...
  FROM <table>
  [INTO <target>]
  [WHERE <condition>]
  [ORDER BY <field>].
```
```abap
DATA: lt_flight TYPE TABLE OF sflight,
      ls_flight TYPE sflight.

" 모든 데이터 조회
SELECT * FROM sflight INTO TABLE lt_flight.

" 조건 조회
SELECT carrid connid
  FROM sflight
  INTO TABLE lt_flight
  WHERE carrid = 'AA'
  ORDER BY connid.
```
</br>
</br>

**2) Single (1건 조회)**
- 조건에 맞는 단일 레코드를 조회할 때 사용
- 부분 필드 조회 시 나머지 필드는 초기화됨
```abap
SELECT SINGLE <field1> <field2> ...
  FROM <table>
  INTO <target>
  WHERE <condition>.
```
```abap
DATA: ls_flight TYPE sflight.

" 단일 레코드 조회
SELECT SINGLE carrid connid
  FROM sflight
  INTO ls_flight
  WHERE carrid = 'AA' AND connid = '0017'.

WRITE: / ls_flight-carrid, ls_flight-connid.
```
</br>
</br>

**3) CORRESPONDING FIELDS OF**
- 이름이 같은 필드만 매핑
- 나머지 필드는 기존값 유지
```abap
<target_structure> = CORRESPONDING FIELDS OF <source_structure>.
```
- CORRESPONDING FIELDS OF 사용했을 때
```abap
DATA: ls_flight TYPE sflight.
ls_flight-cityfrom = 'Seoul'.  " 기존 값

SELECT SINGLE seatmax seatsocc
  FROM sflight
  INTO CORRESPONDING FIELDS OF ls_flight
  WHERE carrid = 'AA' AND connid = '0017'.

" 결과:
" ls_flight-seatmax = DB 값
" ls_flight-seatsocc = DB 값
" ls_flight-cityfrom = 'Seoul' (기존 값 그대로)
```
- CORRESPONDING FIELDS OF 사용하지 않았을 때
```abap
DATA: ls_flight TYPE sflight.
CLEAR ls_flight.

SELECT SINGLE seatmax seatsocc
  FROM sflight
  INTO ls_flight
  WHERE carrid = 'AA' AND connid = '0017'.

" 결과:
" ls_flight-seatmax = DB 값
" ls_flight-seatsocc = DB 값
" ls_flight-cityfrom = 초기화 (빈 값)
```
</br>
</br>

**4) SELECT … ENDSELECT (Row-by-Row)**
- 한 줄씩 DB에서 읽어오고, 읽을 때마다 바로 처리하는 방식 (다 건 SELECT 반복 조회)
- DB를 한 줄 가져올 때마다 계속 DB를 다시 호출하는 방식 → 느림
- 반면에, `LOOP AT`은 DB에서 한 번에 전체 데이터를 가져온 뒤 메모리에서 반복 → 빠름
- `sy-dbcnt` 사용 가능
```abap
SELECT <필드목록>                  " <필드목록> : 가져올 컬럼 이름 (예: carrid, connid)
  FROM <테이블명>                  " <테이블명> : DB 테이블 이름 (예: sflight)
  INTO <워크에어리어 변수>          " <워크에어리어 변수> : 데이터를 담을 ABAP 변수/구조
  [WHERE <조건문>]                 " WHERE : 선택 조건 (선택 사항)
  [ORDER BY <정렬필드>].            " ORDER BY : 정렬 조건 (선택 사항)
  
  " 처리 로직 작성 (레코드 하나씩 처리)
  
ENDSELECT.
```
```abap
DATA: ls_connect TYPE spfli.

SELECT *
  FROM spfli
  INTO ls_connect
  WHERE carrid = 'AA'.

  WRITE: / ls_connect-connid.
ENDSELECT.
```
</br>
</br>

**5) SELECT … INTO TABLE (Array Fetch)**
- 조건에 맞는 데이터 전체를 한 번에 인터널 테이블로 가져옴
- 한 번에 전체 레코드 Fetch → 빠름
```abap
SELECT <필드목록>
  FROM <테이블명>
  INTO [CORRESPONDING FIELDS OF] TABLE <인터널테이블>
  [WHERE <조건>].
```
```abap
DATA: lt_connect TYPE TABLE OF spfli.

SELECT *
  FROM spfli
  INTO TABLE lt_connect
  WHERE carrid = 'AA'.

LOOP AT lt_connect INTO DATA(ls_connect).
  WRITE: / ls_connect-connid.
ENDLOOP.
```
</br>
</br>

**6) SELECT-OPTIONS**
- 사용자가 입력한 범위나 조건을 DB 조회용으로 저장하는 ABAP 키워드
- 내부적으로 테이블 구조로 만들어지며, 단일 값, 범위, 제외 조건까지 처리 가능
- FOR 뒤에는 `데이터 오브젝트(필드)`가 들어가야 함.
```abap
SELECT-OPTIONS: <옵션이름> FOR <필드> [DEFAULT <값>].
```
```abap
DATA: gt_connect TYPE TABLE OF spfli,
      gs_connect TYPE spfli.

PARAMETERS: pa_car TYPE s_carr_id DEFAULT 'AA'.

" 사용자 입력 범위 생성 (connid 17이 기본값)
SELECT-OPTIONS: so_con FOR gs_connect-connid DEFAULT '17'.

" 조회 시 SELECT-OPTIONS 범위 적용
SELECT *
  FROM spfli
  INTO CORRESPONDING FIELDS OF TABLE gt_connect
  WHERE carrid = pa_car
    AND connid IN so_con.

LOOP AT gt_connect INTO gs_connect.
  WRITE:/ gs_connect-carrid,
        gs_connect-connid,
        gs_connect-cityfrom.
ENDLOOP.
```
</br>
</br>
</br>

---
</br>

## < ABAP 데이터 모델과 데이터베이스 관계 이해 >
**1) ABAP Dictionary (SE11)**
- 데이터 구조를 논리적으로 정의하는 곳
- 테이블, 뷰, 구조, 데이터 요소 등을 설계하지만, 실제 데이터는 저장하지 않음
- 프로그램에서 사용할 데이터의 설계도 역할을 합니다.
- Transparent Table로 정의하면 DB에 1:1 매핑됩니다.
</br>
</br>

**2) Relational Database (DB)**
- 실제 데이터를 물리적으로 저장하는 공간
- Dictionary에서 정의한 테이블 구조를 기반으로 DB에 생성
- 데이터가 존재하며, 프로그램에서 읽고 쓸 수 있음
</br>
</br>

**3) Transparent Table**
- Dictionary에서 정의하면 DB에 1:1 매핑되는 테이블
- 구조를 알 수 있기 때문에 프로그램에서는 DATA <structure>로 선언하여 바로 사용 가능합니다.
- MANDT(Client) 필드는 항상 포함되어야 하는 필수 필드
  - 다중 클라이언트 환경에서 데이터 구분용
  - SAP 시스템에서 클라이언트를 식별하는 역할
  - 예: `MANDT = client`

 </br>
 
  <img width="559" height="378" alt="image" src="https://github.com/user-attachments/assets/a577c609-6dbb-4d44-8da5-3c0d9f6978bd" />

</br>
</br>
</br>

## < ABAP 3티어 구조와 Open SQL 처리 흐름 >
</br>

### ABAP 3티어 구조
1) Application Layer (애플리케이션 서버)
   - ABAP 프로그램이 실행되는 곳
   - 비즈니스 로직 처리
2) Database Layer (DB 서버)
   - 실제 데이터를 저장하는 곳
   - RDBMS (Oracle, HANA 등)
3) Presentation Layer (UI)
   - 사용자와 시스템이 상호작용하는 인터페이스
</br>


### SQL 사용 방식
**1) Native SQL**
- 특정 DB에 맞는 SQL 문을 직접 작성
- DB 고유 기능 활용 가능
- 다른 DB로 변경하면 SQL 문도 수정해야 함

**2) Open SQL**
- ABAP에서 표준 SQL 문법 사용
- Database Interface를 거쳐 DB에 맞게 변환
- DB 종류가 바뀌어도 프로그램 수정 없이 그대로 사용 가능
</br>


### Database Interface 역할
1. Open SQL 문법 체크
2. Open SQL → Native SQL 변환
3. 결과를 버퍼에 저장
   
<img width="498" height="341" alt="image" src="https://github.com/user-attachments/assets/c440c952-b86d-4e29-a5c5-9b86499b082a" />
</br>

<img width="478" height="310" alt="image" src="https://github.com/user-attachments/assets/1e2b9d76-178b-4210-9fca-a5d5d0f38ca8" />

</br>
</br>

---

</br>

## < 실습 코드 >

### 실습 1
- LOOP AT 반복문과 MODIFY, Header Line, Sort를 이용하여 결과 출력
```abap
DATA: gs_data TYPE bc400_s_flight,
      gt_data TYPE TABLE OF bc400_s_flight.

" Header Line이 포함된 인터널 테이블 변수 선언
" => 아래에서 사용한 gs_data/gt_data를 gt_hline으로 바꿔보는걸로..
DATA: gt_data2 TYPE TABLE OF bc400_s_flight WITH HEADER LINE.

SELECT carrid connid fldate seatsmax seatsocc
  FROM sflight
  INTO TABLE gt_data
  WHERE carrid = 'AA'.

" 1) 만약 sy-subrc가 0 이라면
" gt_data를 LOOP 돌면서 Percentage 계산하여 MODIFY를 이용해 반영한다.
" 계산식 : percentage = seatsocc * 100 / seatmax

IF ( sy-subrc = 0 ).
  LOOP AT gt_data INTO gs_data.
    gs_data-percentage = gs_data-seatsocc * 100 / gs_data-seatsmax.
    MODIFY gt_data FROM gs_data.
  ENDLOOP.
ENDIF.

SORT gt_data BY connid ASCENDING
                percentage DESCENDING.

" 2) percentage 반영된 itab을 LOOP 돌면서,
"    percentage 가 80을 초과하는 레코드만 출력한다. (출력필드는 전체필드 기준)

CLEAR gs_data.
LOOP AT gt_data INTO gs_data WHERE percentage > 80.
  WRITE:/ gs_data-carrid,
          gs_data-connid,
          gs_data-fldate,
          gs_data-seatsmax,
          gs_data-seatsocc,
          gs_data-percentage.
ENDLOOP.
```
</br>
</br>
</br>

### 실습 2
- function module로 carrid, connid를 받으면 spfli에서 1건 조회하여 반환하는 로직 구현
  
**1) Import 표 채우기**

<img width="599" height="127" alt="image" src="https://github.com/user-attachments/assets/356d3c61-3fff-442c-a3d2-f36c32fd3eb8" />

</br>

**2) Export 표 채우기**

<img width="599" height="108" alt="image" src="https://github.com/user-attachments/assets/e7aaadb5-08f8-42f9-b6a3-24d1c4c268ba" />

</br>

**3) Exceptions 표 채우기**

<img width="599" height="130" alt="image" src="https://github.com/user-attachments/assets/1e247174-54a7-465d-b975-cc45e696f5c0" />

</br>
</br>

**4) Function Module 코드**
```abap
FUNCTION z_bc400_03_connection_get.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(IV_CARRID) TYPE  S_CARR_ID
*"     REFERENCE(IV_CONNID) TYPE  S_CONN_ID
*"  EXPORTING
*"     REFERENCE(ES_CONNECTION) TYPE  BC400_S_CONNECTION
*"  EXCEPTIONS
*"      NO_DATA
*"----------------------------------------------------------------------

  SELECT SINGLE carrid connid cityfrom airpfrom cityto airpto fltime deptime
    FROM spfli
    INTO es_connection
    WHERE carrid = iv_carrid AND connid = iv_connid.

  IF sy-subrc <> 0.
    RAISE no_data.
  ENDIF.

ENDFUNCTION.
```
</br>

**5) Program 코드**
```abap
PARAMETERS: p_carrid TYPE c LENGTH 3,
            p_connid TYPE n LENGTH 4.
DATA: gs_data TYPE bc400_s_connection.

CALL FUNCTION 'Z_BC400_03_CONNECTION_GET'
  EXPORTING
    iv_carrid     = p_carrid
    iv_connid     = p_connid
  IMPORTING
    es_connection = gs_data
  EXCEPTIONS
    no_data       = 1
    OTHERS        = 2.

IF sy-subrc <> 0.
  MESSAGE '데이터가 없습니다.' TYPE 'E'.
ELSE.
  WRITE:/ gs_data-carrid, gs_data-connid,
          gs_data-cityfrom, gs_data-airpfrom,
          gs_data-cityto, gs_data-airpto,
          gs_data-fltime, gs_data-deptime,
          gs_data-arrtime.
ENDIF.
```
</br>
</br>
</br>

### 실습 3
- select 세 가지 종류
  
**1) Single Select (단 건 조회)**
```abap
* SELECT LOOP
DATA: ls_connect  TYPE BC400_s_connection,
      lt_connects LIKE TABLE OF ls_connect.

PARAMETERS: pa_car TYPE s_carr_id.

SELECT *
  FROM spfli
  INTO CORRESPONDING FIELDS OF ls_connect
  WHERE carrid = pa_car.
  " 참고) 여기선 sy-dbcnt로 index를 얻을 수 있음
    APPEND ls_connect TO lt_connects.
  WRITE: ls_connect-arrtime.
ENDSELECT.

IF sy-subrc <> 0.
  MESSAGE 'Data is not exist' TYPE 'E'.
ELSE.
  cl_demo_output=>display( lt_connects ).
ENDIF.
```
</br>

**2) SELECT ~ ENDSELECT (다 건 반복 조회)**
```abap
FUNCTION z_bc400_03_flightlist_get.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(IV_CARRID) TYPE  S_CARR_ID
*"     REFERENCE(IV_CONNID) TYPE  S_CONN_ID
*"  EXPORTING
*"     REFERENCE(ET_FLIGHTS) TYPE  BC400_T_FLIGHTS
*"  EXCEPTIONS
*"      NO_DATA
*"----------------------------------------------------------------------
  DATA: ls_flight TYPE bc400_s_flight.

  SELECT carrid connid fldate seatsmax seatsocc
    FROM sflight
    INTO ls_flight
    WHERE carrid = iv_carrid AND connid = iv_connid.
      ls_flight-percentage = ( ls_flight-seatsmax / ls_flight-seatsocc ) * 100.
      APPEND ls_flight TO et_flights.
  ENDSELECT.

  IF sy-subrc <> 0.
    RAISE no_data.
  ELSE.
    SORT et_flights BY percentage DESCENDING.
  ENDIF.

ENDFUNCTION.
```
</br>

**3) SELECT ~ INTO TABLE (다 건 한번에 조회)**
```abap
FUNCTION Z_BC400_03_FLIGHTLIST_GET_OPT.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(IV_CARRID) TYPE  S_CARR_ID
*"     REFERENCE(IV_CONNID) TYPE  S_CONN_ID
*"  EXPORTING
*"     REFERENCE(ET_FLIGHTS) TYPE  BC400_T_FLIGHTS
*"  EXCEPTIONS
*"      NO_DATA
*"----------------------------------------------------------------------

DATA: ls_flight TYPE bc400_s_flight.

SELECT carrid connid fldate seatsmax seatsocc
  FROM sflight
  INTO TABLE et_flights
  WHERE carrid = iv_carrid AND connid = iv_connid.

IF sy-subrc <> 0.
    RAISE no_data.
  ELSE.
    LOOP AT et_flights INTO ls_flight.
      ls_flight-percentage = ( ls_flight-seatsmax / ls_flight-seatsocc ) * 100.
      MODIFY et_flights FROM ls_flight INDEX sy-tabix TRANSPORTING percentage.
    ENDLOOP.

    SORT et_flights BY percentage DESCENDING.
  ENDIF.

ENDFUNCTION.
```
</br>

**4) SELECT-OPTIONS**
```abap
DATA: gs_connect TYPE BC400_S_CONNECTION,
      gt_connect TYPE BC400_T_CONNECTIONS.
DATA: gv_dt TYPE S_DATE.

PARAMETERS: pa_car TYPE s_carr_id DEFAULT 'AA'.

SELECT-OPTIONS: so_con FOR gs_connect-connid DEFAULT '17',
                so_fdt FOR gv_dt.
*SELECT-OPTIONS: so_con2 FOR S_CONN_ID. " 오류!
* => FOR 뒤에는 TYPE이 들어오는게 아니라 DATA Object

SELECT *
  INTO CORRESPONDING FIELDS OF TABLE gt_connect
  FROM spfli
  WHERE carrid = pa_car
    AND connid IN so_con.

LOOP AT gt_connect INTO gs_connect.
  WRITE:/ gs_connect-carrid,
        gs_connect-connid,
        gs_connect-cityfrom.
ENDLOOP.
```
