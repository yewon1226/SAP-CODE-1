# 반복문

## 📌 ABAP 반복문 관련 시스템 변수

| 시스템 변수 | 기능 / 의미 | 반복문과의 관계 |
|-------------|------------|----------------|
| **sy-subrc** | ABAP 문법 실행 결과 코드 <br> - 0: 성공 / 데이터 존재 <br> - 4: 조건에 맞는 데이터 없음 <br> - 8: 키 조합 오류 | SELECT, 함수, 조건문 실행 후 결과 확인 |
| **sy-dbcnt** | SELECT … ENDSELECT 루프 인덱스 (몇 번째 DB 레코드를 읽었는지) | SELECT 루프에서 자동 증가 |
| **sy-tabix** | 내부 테이블 LOOP 행 번호 | LOOP AT 내부 테이블 반복 시 현재 행 번호 |
| **sy-index** | DO / WHILE 반복문 인덱스 | 일반 반복문(DO, DO n TIMES, WHILE)에서 반복 횟수 |
</br>
</br>

### 1) DO … ENDDO
- 반복 횟수를 지정하지 않으면 무한 반복
- `EXIT`나 `CHECK` 등으로 빠져나와야 함
- `sy-index` 사용 가능
```abap
DO.
  " 반복 코드
ENDDO.
```
```abap
PARAMETERS: pa_cnt TYPE i.

DO.
  IF SY-INDEX > pa_cnt.
    EXIT.
  ENDIF.
  WRITE:/ sy-index.
ENDDO.
```
```abap
DATA lv_cnt TYPE i VALUE 0.

DO.
  lv_cnt = lv_cnt + 1.
  IF lv_cnt > 3.
    EXIT.
  ENDIF.
ENDDO.
```
</br>

### 2) DO n TIMES … ENDDO
- 지정한 n번 반복
- 반복 횟수는 sy-index에 자동 저장됨(1부터 시작)
- `sy-index` 사용 가능
```abap
DO n TIMES.
  " 반복 코드
ENDDO.
```
```abap
PARAMETERS: pa_cnt TYPE i.

DO pa_cnt TIMES.
  WRITE:/ sy-index.
ENDDO.
```
```abap
DO 5 TIMES.
  WRITE: / '횟수:', sy-index.
ENDDO.
```
</br>

### 3) WHILE … ENDWHILE
- 조건이 TRUE일 동안 반복
- 조건이 FALSE가 되면 종료
- `sy-index` 사용 가능
```abap
WHILE 조건.
  " 반복 코드
ENDWHILE.
```
```abap
PARAMETERS: pa_cnt TYPE i.

WHILE sy-index < pa_cnt.
  WRITE:/ sy-index.
ENDWHILE.
```
```abap
DATA lv_i TYPE i VALUE 1.

WHILE lv_i <= 5.
  WRITE: / lv_i.
  lv_i = lv_i + 1.
ENDWHILE.
```
</br>

### 4) SELECT … ENDSELECT
- DB를 row-by-row 방식으로 조회
- SELECT된 각 레코드를 반복 처리
- `sy-dbcnt` 사용 가능
```abap
SELECT <필드목록>                  " <필드목록> : 가져올 컬럼 이름 (예: carrid, connid)
  FROM <테이블명>                  " <테이블명> : DB 테이블 이름 (예: sflight)
  INTO <워크에어리어 변수>          " <워크에어리어 변수> : 데이터를 담을 ABAP 변수/구조
  [WHERE <조건문>]                 " WHERE : 선택 조건 (선택 사항)
  [ORDER BY <정렬필드>].            " ORDER BY : 정렬 조건 (선택 사항)
  
  " 처리 로직 작성 (레코드 하나씩 처리)
  
ENDSELECT.
```
```abap
DATA: gv_carrid TYPE scarr-carrid. " S_CARR_ID랑 동일
" Transparent Table 이라 세부적으로 들어갈 수 있음

" 만약 조건이 없으면 테이블의 전체 건수 만큼 루프문 실행
" 조건이 있으면 조건에 맞는 데이터를 가져옴
SELECT carrid
  INTO gv_carrid
  FROM scarr
  WHERE carrid='AA'.
    " 여기서 데이터 처리 로직 구현
    WRITE:/ sy-dbcnt, gv_carrid.
ENDSELECT.
```
```abap
DATA: wa_sflight TYPE sflight.  " 작업 영역 선언

" sflight 테이블 전체 레코드를 하나씩 읽어서 처리
SELECT * 
  FROM sflight
  INTO wa_sflight.

  WRITE: / wa_sflight-carrid, wa_sflight-connid, wa_sflight-fldate.

ENDSELECT.
```
</br>

### 5) LOOP AT … ENDLOOP
- 내부 테이블을 한 행씩 반복 처리
- 현재 행 번호는 sy-tabix
- `sy-tabix` 사용 가능
- `TABLE OF` : 특정 구조나 타입을 가지는 내부 테이블을 선언할 때 사용
- `LINE OF` : 내부 테이블에서 한 행(row)의 타입을 가져올 때 사용
```abap
LOOP AT <internal_table> INTO <work_area> [FROM <시작행>] [TO <끝행>] [WHERE <조건>].

  " 반복 처리 로직 작성 (각 행마다 실행)

ENDLOOP.
```
```abap
DATA: gs_sflight TYPE BC400_S_FLIGHT,      " Structure
      gt_sflight LIKE TABLE OF gs_sflight. " gt : 글로벌 테이블
" DATA: gs_sflight2 LIKE LINE OF gt_sflight. " Structure

SELECT * FROM SFLIGHT
  INTO CORRESPONDING FIELDS OF TABLE @gt_sflight  " DB 테이블에서 데이터 가져와서 internal 테이블에 넣음
  WHERE CARRID = 'AA'
    AND CONNID = '0017'.

IF sy-subrc = 0. " 만약 데이터 조회 성공한다면 (데이터 존재시)
  " Internal Table에 조회한 데이터들이 들어와 있는 상황
  " gt_flight를 한 건씩 돌면서 처리. 이 때 gs_flight 에 담아서 처리
  LOOP AT gt_sflight INTO gs_sflight. " Work-area라고 부름
    " gt_sflight 와 gs_sflights 는 필드 구조가 동일해야함.
    WRITE:/ sy-tabix,
            gs_sflight-carrid,
            gs_sflight-connid,
            gs_sflight-fldate.
  ENDLOOP.
ENDIF.
```
```abap
DATA: lt_data TYPE TABLE OF sflight,
      wa_data TYPE sflight.

SELECT * FROM sflight INTO TABLE lt_data.

LOOP AT lt_data INTO wa_data.
  WRITE: / wa_data-carrid, wa_data-connid.
ENDLOOP.
```
</br>
</br>

---

</br>

## < 실습 코드 >
- 실습 1
```abap
PARAMETERS: pa_num1 TYPE I,
            pa_num2 TYPE I.
DATA gv_num TYPE I.

IF ( pa_num1 > pa_num2 ).
  gv_num = pa_num2 + 1.

  DO.
    IF ( sy-index > pa_num1 - pa_num2 - 1 ).
      EXIT.
    ENDIF.
    IF ( gv_num MOD 2 = 1 ).
      WRITE / gv_num.
    ENDIF.
    gv_num = gv_num + 1.
  ENDDO.
ELSE.
  gv_num = pa_num1 + 1.

  DO.
    IF ( sy-index > pa_num2 - pa_num1 - 1 ).
      EXIT.
    ENDIF.
    IF ( gv_num MOD 2 = 1 ).
      WRITE / gv_num.
    ENDIF.
    gv_num = gv_num + 1.
  ENDDO.
ENDIF.
```
