# 반복문

## 📌 ABAP 반복문 관련 시스템 변수

| 시스템 변수 | 기능 / 의미 | 반복문과의 관계 |
|-------------|------------|----------------|
| **sy-subrc** | ABAP 문법 실행 결과 코드 <br> - 0: 성공 / 데이터 존재 <br> - 4: 조건에 맞는 데이터 없음 <br> - 8: 키 조합 오류 | SELECT, 함수, 조건문 실행 후 결과 확인 |
| **sy-dbcnt** | SELECT … ENDSELECT 루프 인덱스 (몇 번째 DB 레코드를 읽었는지) | SELECT 루프에서 자동 증가 |
| **sy-tabix** | 내부 테이블 LOOP 행 번호 | LOOP AT 내부 테이블 반복 시 현재 행 번호 |
| **sy-index** | DO / WHILE 반복문 인덱스 | 일반 반복문(DO, DO n TIMES, WHILE)에서 반복 횟수 |
</br>
</br>

### 1) DO … ENDDO
- 반복 횟수를 지정하지 않으면 무한 반복
- `EXIT`나 `CHECK` 등으로 빠져나와야 함
- `sy-index` 사용 가능
```abap
DO.
  " 반복 코드
ENDDO.
```
```abap
PARAMETERS: pa_cnt TYPE i.

DO.
  IF SY-INDEX > pa_cnt.
    EXIT.
  ENDIF.
  WRITE:/ sy-index.
ENDDO.
```
```abap
DATA lv_cnt TYPE i VALUE 0.

DO.
  lv_cnt = lv_cnt + 1.
  IF lv_cnt > 3.
    EXIT.
  ENDIF.
ENDDO.
```
</br>

### 2) DO n TIMES … ENDDO
- 지정한 n번 반복
- 반복 횟수는 sy-index에 자동 저장됨(1부터 시작)
- `sy-index` 사용 가능
```abap
DO n TIMES.
  " 반복 코드
ENDDO.
```
```abap
PARAMETERS: pa_cnt TYPE i.

DO pa_cnt TIMES.
  WRITE:/ sy-index.
ENDDO.
```
```abap
DO 5 TIMES.
  WRITE: / '횟수:', sy-index.
ENDDO.
```
</br>

### 3) WHILE … ENDWHILE
- 조건이 TRUE일 동안 반복
- 조건이 FALSE가 되면 종료
- `sy-index` 사용 가능
```abap
WHILE 조건.
  " 반복 코드
ENDWHILE.
```
```abap
PARAMETERS: pa_cnt TYPE i.

WHILE sy-index < pa_cnt.
  WRITE:/ sy-index.
ENDWHILE.
```
```abap
DATA lv_i TYPE i VALUE 1.

WHILE lv_i <= 5.
  WRITE: / lv_i.
  lv_i = lv_i + 1.
ENDWHILE.
```
</br>

### 4) SELECT … ENDSELECT
- DB를 row-by-row 방식으로 조회
- SELECT된 각 레코드를 반복 처리
- `sy-dbcnt` 사용 가능
```abap
SELECT <필드목록>                  " <필드목록> : 가져올 컬럼 이름 (예: carrid, connid)
  FROM <테이블명>                  " <테이블명> : DB 테이블 이름 (예: sflight)
  INTO <워크에어리어 변수>          " <워크에어리어 변수> : 데이터를 담을 ABAP 변수/구조
  [WHERE <조건문>]                 " WHERE : 선택 조건 (선택 사항)
  [ORDER BY <정렬필드>].            " ORDER BY : 정렬 조건 (선택 사항)
  
  " 처리 로직 작성 (레코드 하나씩 처리)
  
ENDSELECT.
```
```abap
DATA: gv_carrid TYPE scarr-carrid. " S_CARR_ID랑 동일
" Transparent Table 이라 세부적으로 들어갈 수 있음

" 만약 조건이 없으면 테이블의 전체 건수 만큼 루프문 실행
" 조건이 있으면 조건에 맞는 데이터를 가져옴
SELECT carrid
  INTO gv_carrid
  FROM scarr
  WHERE carrid='AA'.
    " 여기서 데이터 처리 로직 구현
    WRITE:/ sy-dbcnt, gv_carrid.
ENDSELECT.
```
```abap
DATA: wa_sflight TYPE sflight.  " 작업 영역 선언

" sflight 테이블 전체 레코드를 하나씩 읽어서 처리
SELECT * 
  FROM sflight
  INTO wa_sflight.

  WRITE: / wa_sflight-carrid, wa_sflight-connid, wa_sflight-fldate.

ENDSELECT.
```
</br>

### 5) LOOP AT … ENDLOOP
- 내부 테이블을 한 행씩 반복 처리
- 현재 행 번호는 sy-tabix
- `sy-tabix` 사용 가능
- `TABLE OF` : 특정 구조나 타입을 가지는 내부 테이블을 선언할 때 사용
- `LINE OF` : 내부 테이블에서 한 행(row)의 타입을 가져올 때 사용
```abap
LOOP AT <internal_table> INTO <work_area> [FROM <시작행>] [TO <끝행>] [WHERE <조건>].

  " 반복 처리 로직 작성 (각 행마다 실행)

ENDLOOP.
```
```abap
DATA: gs_sflight TYPE BC400_S_FLIGHT,      " Structure
      gt_sflight LIKE TABLE OF gs_sflight. " gt : 글로벌 테이블
" DATA: gs_sflight2 LIKE LINE OF gt_sflight. " Structure

SELECT * FROM SFLIGHT
  INTO CORRESPONDING FIELDS OF TABLE @gt_sflight  " DB 테이블에서 데이터 가져와서 internal 테이블에 넣음
  WHERE CARRID = 'AA'
    AND CONNID = '0017'.

IF sy-subrc = 0. " 만약 데이터 조회 성공한다면 (데이터 존재시)
  " Internal Table에 조회한 데이터들이 들어와 있는 상황
  " gt_flight를 한 건씩 돌면서 처리. 이 때 gs_flight 에 담아서 처리
  LOOP AT gt_sflight INTO gs_sflight. " Work-area라고 부름
    " gt_sflight 와 gs_sflights 는 필드 구조가 동일해야함.
    WRITE:/ sy-tabix,
            gs_sflight-carrid,
            gs_sflight-connid,
            gs_sflight-fldate.
  ENDLOOP.
ENDIF.
```
```abap
DATA: lt_data TYPE TABLE OF sflight,
      wa_data TYPE sflight.

SELECT * FROM sflight INTO TABLE lt_data.

LOOP AT lt_data INTO wa_data.
  WRITE: / wa_data-carrid, wa_data-connid.
ENDLOOP.
```
</br>
</br>

---

</br>

# ABAP Message Class (SE91) & 메시지 타입 정리
### 1) Message Class (SE91)
- 메시지를 번호로 관리하는 저장소
- 메시지는 `&` 로 변수 값을 받을 수 있음
- 다국어(번역) 지원 → SAP 로그인 언어에 따라 자동으로 해당 언어 메시지 표시됨
</br>

### 2) 메시지 타입 정리

| 타입 | 이름 | 동작 | 상세 설명 |
|------|------|------|------------|
| **I** | Information | 팝업 메시지 표시 | 단순 정보 안내. OK 누르면 계속 진행 |
| **S** | Success | 상태바(하단)에 녹색 메시지 | 성공 메시지. 실행 계속됨 |
| **W** | Warning | **하단 상태바에 노란색 경고 메시지 표시** | 엔터 누르면 계속 진행. 단, *입력 화면(Selection-Screen)* 안에서만 유효 |
| **E** | Error | **하단 상태바에 빨간색 에러 메시지 표시 후 처리 중단** | AT SELECTION-SCREEN에서는 입력 화면으로 돌아감. 프로그램 실행 중에는 현재 이벤트 종료 |
| **A** | Abort | 비정상 종료 | 메시지 출력 후 프로그램 즉시 종료 |
| **X** | Exception | Short Dump 발생 | 시스템 덤프 생성(SAP 오류 강제 발생) |
</br>

### 3) MESSAGE-ID 미사용
- <메시지클래스> 반드시 명시해야 함
- WITH 뒤에 메시지의 & 자리에 들어갈 값 지정
- 최대 4개까지 가능 → &1, &2, &3, &4 또는 단순 & 순서대로
```abap
MESSAGE <type><번호>(<메시지클래스>) WITH 값1 값2 ...
```
```abap
REPORT ZPROGB03_0006.

PARAMETERS: pa_name TYPE string.
CONSTANTS: gc_const TYPE string VALUE 'CODE'.
MESSAGE i002(ZMCB03) WITH pa_name gc_const.
```
</br>

### 4) MESSAGE-ID 사용
- 프로그램 가장 위( REPORT 문 뒤 ) 선언
- 메시지 호출 시 클래스 이름 생략 가능
```abap
REPORT <프로그램명> MESSAGE-ID <메시지클래스>.
```
```abap
REPORT ZPROGB03_0006 MESSAGE-ID ZMCB03.          " MESSAGE-ID 사용

PARAMETERS: pa_name TYPE string.
CONSTANTS: gc_const TYPE string VALUE 'CODE'.
MESSAGE i002 WITH pa_name gc_const.              " 생략
```
</br>
</br>

---
</br>

## 디버깅
1. 소스코드에 BREAK-POINT. 키워드
2. 커멘드필드창에 /h 입력
3. 소스코드의 특정 라인 선택
</br>

### 디버깅 창에서 application toolbar의 버튼 4개

1. F5 한줄씩 실행 (메서드 안쪽까지 들어감)
2. F6 함수 블럭을 넘기고 다음 라인 실행. 함수 내부에서 실행 시 F5와 같이 동작함.
3. F7 함수 블럭 안에서, 메인 소스의 현재 위치 바로 다음줄로 이동
4. F8 다음 Break Point로 이동

</br>
</br>

---

</br>

## < 실습 코드 >
- 실습 1
- 숫자 2개 사이 값의 홀수 출력
```abap
PARAMETERS: pa_num1 TYPE I,   " 입력받은 두 숫자
            pa_num2 TYPE I.
DATA: gv_num TYPE I,
      gv_num1 LIKE gv_num,
      gv_num2 LIKE gv_num.           " 출력할 숫자 검사를 시작할 변수 선언

IF ( pa_num1 > pa_num2 ).     " 앞에 숫자 값이 더 클 때
  gv_num = pa_num2 + 1.
  gv_num1 = pa_num1.
  gv_num2 = pa_num2.
ELSE.
  gv_num = pa_num1 + 1.
  gv_num1 = pa_num2.
  gv_num2 = pa_num1.
ENDIF.

DO.
  IF ( sy-index > gv_num1 - gv_num2 - 1 ).
    EXIT.
  ENDIF.
  IF ( gv_num MOD 2 = 1 ).
    WRITE / gv_num.
  ENDIF.
  gv_num = gv_num + 1.
ENDDO.
```
</br>

- 실습 2
- 두 숫자 사이 3의 배수 구하기
```abap
PARAMETERS: pa_small TYPE I, pa_big TYPE I.
CONSTANTS: gc_const TYPE I VALUE 3.

IF ( ( pa_small IS INITIAL ) OR ( pa_big IS INITIAL ) ).
  MESSAGE TEXT-001 TYPE 'E'.
ENDIF.

IF ( pa_big <= pa_small ).
  MESSAGE TEXT-002 TYPE 'E'.
ENDIF.

DO.
  IF ( pa_small > pa_big ).
    EXIT.
  ELSEIF ( pa_small MOD gc_const = 0 ).
    WRITE / pa_small.
  ENDIF.
  pa_small = pa_small + 1.
ENDDO.
```
