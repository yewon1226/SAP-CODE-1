# ABAP 모듈화(Modularization)
- 코드를 따로 만들어 놓고 필요할 때 호출해서 쓰는 것
- 가독성 ↑, 재사용성 ↑, 유지보수 ↑
</br>

**1) Local Modularization (로컬 모듈화)**
- 현재 프로그램 안에서만 사용 가능, 재사용성 낮음
- Subroutine (FORM), Local Class

**2) Global Modularization (전역 모듈화)**
- SAP 전체 프로그램이 공용으로 사용 가능, 어디서든 호출 가능, 재사용성 매우 좋음.
- Function Group / Function Module, Global Class (SE24) / Method
</br>

### 데이터 캡슐화
- 객체 내부 데이터를 숨기고(PRIVATE) 외부에서는 메서드(PUBLIC)로만 접근하도록 제한하는 것
- 데이터 보호 + 잘못된 접근 방지를 위한 객체지향의 기본 원칙
</br>

--- 

</br>

## 모듈화 기술 함수

# 1) Subroutine (FORM … ENDFORM)
- 로컬 모듈화 방식: 같은 프로그램 안에서만 호출 가능
- 글로벌 변수 사용 가능하지만 최소화하여 독립적·재사용 가능하게 작성

- 파라미터
  - `Formal Parameter` : 서브루틴/함수 선언 시 정의되는 변수
  - `Actual Parameter` : 호출 시 전달되는 값
- 호출 방식
  - `CALL BY VALUE` : 호출 시 값만 복사해서 전달, 호출부 값은 바뀌지 않음.
  - `CALL BY VALUE AND RESULT` : 값 전달 후, 서브루틴에서 수정된 값을 호출부로 반환.
  - `CALL BY REFERENCE` : 변수의 메모리 주소를 공유, 서브루틴에서 바꾸면 호출부 값도 바로 바뀜.
```abap
* -------------------------------
* Subroutine 호출부
* -------------------------------
PERFORM <subroutine_name> 
        USING <param1> VALUE <param2> 
        CHANGING <param3> <param4>.

* -------------------------------
* Subroutine 선언부
* -------------------------------
FORM <subroutine_name> 
     USING VALUE(<param1>) VALUE(<param2>) 
     CHANGING <param3> <param4>.
  " 처리 로직 작성
ENDFORM.
```
</br>

### < ABAP 서브루틴 파라미터 전달 방식 정리 >
- USING / CHANGING 키워드와 VALUE() 사용 여부에 따른 호출 방식 표

| 키워드    | VALUE() 사용 여부 | 호출 방식                  | 특징                       | 호출부 반영 여부                |
|-----------|----------------|---------------------------|----------------------------|-------------------------------|
| USING     | VALUE()         | Call by Value             | 값만 전달                  | 호출부 변수 변경 안됨          |
| USING     | 없음            | Call by Reference         | 값 전달 + 수정 가능        | 호출부 변수 변경됨             |
| CHANGING  | VALUE()         | Call by Value and Result  | 값 전달 + 결과 반환        | 호출부 변수 변경됨             |
| CHANGING  | 없음            | Call by Reference         | 값 전달 + 수정 가능        | 호출부 변수 변경됨             |
- `USING VALUE(fa)` → 값만 전달, 호출부 변수 변경 안됨  
- `USING fa` → 값 전달 + 호출부 변수 공유  
- `CHANGING VALUE(fd)` → 값 전달 후 수정 결과 반환  
- `CHANGING fd` → 호출부 변수 공유, 바로 수정
```abap
DATA: gv_a TYPE C VALUE 'A',
      gv_b TYPE C VALUE 'B',
      gv_c TYPE C VALUE 'C',
      gv_d TYPE C VALUE 'D'.

PERFORM test USING gv_a gv_b
             CHANGING gv_c gv_d.

NEW-LINE.
WRITE: 'PERFORM IN : ', gv_a, gv_b, gv_c, gv_d.

FORM test  USING    VALUE(fa)
                    fb
           CHANGING VALUE(fc)
                    fd.
  fa = 'W'.
  fb = 'X'.
  fc = 'Y'.
  fd = 'Z'.
  WRITE: 'PERFORM END : ', fa, fb, fc, fd.

ENDFORM.
```
</br>
</br>

## 2) Function Module (FM)
- SE37 (Function Builder): SAP에서 Function Module을 생성, 수정, 테스트할 수 있는 트랜잭션 코드.
- Function Module(FM) 은 Function Group(FG) 안에 소속됨.
- Function Group = 하나의 프로그램처럼 동작.
  
- FG 내부 변수들은 FG 안의 Function Module끼리만 접근 가능, 일반 ABAP 프로그램에서는 직접 접근 불가
  - FM의 파라미터(interface)를 통해서만 값 전달·수정 가능.
- 하나의 FG 안에는 여러 개의 Function Module이 들어갈 수 있음.
```abap
* Function Module 호출

CALL FUNCTION '<FUNCTION_MODULE_NAME>'.
```
</br>

### < Function Module 파라미터 >
**1) Function Module 파라미터 옵션**
1) OPTIONAL
   - 체크하면 해당 파라미터를 전달하지 않아도 FM 호출 가능 (선택값)
   - 체크하지 않으면 필수값, 반드시 전달해야 함
     
2) Pass by Value / Reference
   - Pass by Value (체크 O) : FM에 값만 전달, FM 내부에서 변경해도 호출부 변수는 영향 없음
   - Pass by Reference (체크 X) : FM과 호출부 변수가 같은 메모리 주소를 공유, FM 내부 변경 시 호출부에도 반영

3) EXCEPTIONS (예외 처리)
   - FM 실행 중 발생할 수 있는 오류 상황을 처리
   - 호출부에서 특정 예외를 감지하고 대응 가능
</br>
</br>

**2) Function Module 파라미터 종류 (Interface)**
- FM에서 파라미터 영역을 **Interface**라고 부름
  - 프로그램과 FM이 값을 주고받는 통로
  
| 파라미터 종류 | 의미 |
|---------------|------------------------------------------------|
| **IMPORT**    | 프로그램 → FM 값 전달 |
| **EXPORT**    | FM → 프로그램 값 반환 |
| **CHANGING**  | 양방향 데이터 전달 (주고받기) |
| **EXCEPTIONS**| 예외 처리 |
</br>
</br>

**3) 프로그램 ↔ Function Module 파라미터 대응표**
- 프로그램이 **EXPORTING** 으로 보내면 FM에서는 반드시 **IMPORTING** 으로 받아야 함.

| 프로그램에서 전달 | Function Module에서 받음 |
|------------------|---------------------------|
| **EXPORTING**    | **IMPORTING** |
| **IMPORTING**    | **EXPORTING** |
| **CHANGING**     | **CHANGING** |
| **Tables**     | **Tables** |
| **Exceptions**     | **Exceptions** |

</br>
</br>

### < Function Module 선언 (SE37에서 생성) >

</br>
</br>

---

</br>

## < ABAP 추가적인 문법 >
</br>

**1) ULINE**
- 화면에 ————— (라인) 을 출력하는 명령
- WRITE 없이 단독으로 사용 가능
```abap
ULINE.
```
</br>

**2) WRITE: 숫자(숫자) → 출력 위치 + 필드 길이 지정**
```abap
WRITE: position(length) <값>.
```
```abap
WRITE: 5(10) pa_num, '단 :'.    " 5(10) → 화면 5번째 칼럼부터 10칸 공간 확보
```
</br>

---
</br>

## < 실습 코드 >
- 실습 1
```abap
PARAMETERS pa_num TYPE I.
DATA gv_result TYPE I.

IF ( pa_num <= 1 ).
  MESSAGE '2 이상을 입력하세요' TYPE 'E'.
ELSEIF ( pa_num >= 10 ).
  MESSAGE '9 이하를 입력하세요' TYPE 'E'.
ELSE.
  DO 9 TIMES.
    gv_result = pa_num * sy-index.
    WRITE:/ pa_num, ' * ', sy-index, ' = ', gv_result.
  ENDDO.
ENDIF.
```
```abap
PARAMETERS: pa_num TYPE I.
DATA: gv_result TYPE I.

IF pa_num < 2 OR pa_num > 9.
  MESSAGE '2 이상 9 이하의 숫자를 입력하세요.' TYPE 'I'.
  ELSE.
    WRITE: 5(10) pa_num, '단 :'.
    ULINE.

    DO 9 TIMES.
      gv_result = pa_num * sy-index.
      WRITE:
        10(2) pa_num,
        12(2) '*',
        14(2) sy-index,
        16(2) '=',
        18(2) gv_result.
      NEW-LINE.
    ENDDO.
ENDIF.
```
</br>

- 실습 2
```abap
PARAMETERS: gv_num1 TYPE i,
            gv_op   TYPE c LENGTH 1,
            gv_num2 TYPE i.

DATA: gv_result TYPE i.

PERFORM get_compute USING gv_num1 gv_num2 gv_op
                    CHANGING gv_result.

WRITE: gv_result.

* 서브루틴 정의
FORM get_compute USING VALUE(p_pa_num1)
                       VALUE(p_pa_num2)
                       VALUE(p_pa_op)
                 CHANGING VALUE(p_pa_result).
  CASE p_pa_op.
    WHEN '+'.
      p_pa_result = p_pa_num1 + p_pa_num2.
    WHEN '-'.
      p_pa_result = p_pa_num1 - p_pa_num2.
    WHEN '*'.
      p_pa_result = p_pa_num1 * p_pa_num2.
    WHEN '/'.
      p_pa_result = p_pa_num1 / p_pa_num2.
    WHEN OTHERS.
  ENDCASE.

ENDFORM.
```
</br>

- 실습 3
```abap
PARAMETERS: pa_int1 TYPE i,
            pa_int2 TYPE i,
            pa_op   TYPE c.

DATA gv_result TYPE p LENGTH 16 DECIMALS 2.


CASE pa_op.
  WHEN '+'.
    gv_result = pa_int1 + pa_int2.
  WHEN '-'.
    gv_result = pa_int1 - pa_int2.
  WHEN '*'.
    gv_result = pa_int1 * pa_int2.
  WHEN '/'.
    IF ( pa_int1 = 0 OR pa_int2 = 0 ).
      MESSAGE '0을 나눌 순 없습니다.' TYPE 'E'.
    ENDIF.
    gv_result = pa_int1 / pa_int2.
  WHEN '%'.
    PERFORM CALC_PERCENTAGE USING pa_int1 pa_int2 CHANGING gv_result.
  WHEN OTHERS.
    MESSAGE '타당하지 않는 연산자입니다.' TYPE 'E'.
ENDCASE.

WRITE: gv_result.

FORM CALC_PERCENTAGE USING VALUE(PV_ACT) TYPE I 
                           VALUE(PV_MAX) TYPE I
                     CHANGING VALUE(CV_RESULT).
  IF ( PV_MAX = 0 ).
    MESSAGE '0이 들어올 수 없습니다.' TYPE 'E'.
  ELSE.
    CV_RESULT = ( PV_ACT / PV_MAX ) * 100.
  ENDIF.
ENDFORM.
```
