### 데이터 요소(Data Element) 타입으로 올 수 있는 3가지 종류
- `DATA`는 메모리와 값을 갖는 변수 생성, `TYPE`은 값 없이 타입만 정의
  
#### 1) Standard Data Type
   - SAP가 제공하는 기본 데이터 타입
      #### 1-1) Complete Type
      | Type       | 설명                                                                 |
      |------------|----------------------------------------------------------------------|
      | D          | 날짜(Date)                                                             |
      | T          | 시간(Time)                                                             |
      | I          | 4바이트 정수(Integer 4)                                               |
      | INT8       | 8바이트 정수(Integer 8)                                               |
      | F          | 부동 소수점(Float)                                                     |
      | STRING     | 가변 길이 문자열(Variable-length string), 사용자가 입력하는 만큼 동적 할당됨 |
      | XSTRING    | 가변 길이 이진(Binary) 문자열, 사용자가 입력하는 만큼 동적 할당됨      |
      | DECFLOAT16 | 16자리 부동 소수점(decimal floating)                                  |
      | DECFLOAT34 | 34자리 부동 소수점(decimal floating)                                  |
      
      #### 1-2) Incomplete Type
      | Type | 설명                                                      |
      |------|-----------------------------------------------------------|
      | C    | 문자(Character), 길이 지정 필요                            |
      | N    | 숫자형 문자(Numeric character), 길이 지정 필요              |
      | X    | 16진수(Hexadecimal), 길이 지정 필요                       |
      | P    | 고정소수점. Packed Decimal(BCD), 소수점 위치 지정 필요                 |
     
        - P TYPE
        - `총 자릿수 = LENGTH * 2 - 1`
          - LENGTH : P 타입 선언 시 지정하는 바이트 수
          - *2 → 1바이트 = 2자리 숫자를 저장
          - -1 → 마지막 절반 바이트는 부호(+, -)용
          - 총 자릿수가 DECIMALS 자릿수보다 작으면 에러
          
            ```abap
            DATA lv_amount TYPE P LENGTH 5 DECIMALS 2.
            ```
            </br>
      
#### 2) Local Type
   - 특정 프로그램 내에서 정의하여 사용하는 타입
   - 다른 프로그램에서는 사용할 수 없음
       #### 2-1) TYPES
       - 로컬 타입을 정의할 때 사용하는 키워드, 실제 변수를 만드는 것이 아님
        </br>
         
       ```abap
       TYPES <타입명> TYPE <데이터타입/구조>.
       ```
       ```abap
       TYPES tv_c_type TYPE C LENGTH 8.
       TYPES tv_n_type TYPE N LENGTH 5.
       TYPES tv_p_type TYPE P LENGTH 3 DECIMALS 2.
    
       TYPES ty_employee TYPE string.         " 문자열 타입 정의
       DATA lv_emp_name TYPE ty_employee.     " 타입 사용 변수 선언
       ```

       #### 2-2) LIKE
       - 기존 변수나 데이터 요소의 타입과 속성을 그대로 가져와 새로운 변수 선언
        </br>
         
       ```abap
       DATA <새변수> LIKE <기존변수|데이터요소>.
       ```
       ```abap
       DATA gv_amount TYPE P LENGTH 7 DECIMALS 2.   " 기존 변수 선언
       DATA lv_amount LIKE gv_amount.               " gv_amount와 같은 타입으로 선언
       ```
     </br>
  
#### 3) Global Data Type
   - SE11에서 정의되어 모든 프로그램에서 사용 가능한 타입
   - 데이터 요소, 구조, 테이블 타입 등으로 활용 가능

     #### 3-1) Data Element Type
      - 하나의 값(필드 하나)을 표현하는 타입
      - 길이/형식 같은 기본 속성을 정의함
   
      #### 3-2) Structure Type
      - 여러 필드가 모여 하나의 덩어리를 이루는 타입
      - 하나의 레코드(행) 같은 구조
        
      #### 3-3) Table Type (Internal Table)
      - 동일한 구조를 여러 개 담는 “내부 테이블”을 위한 타입
      - 여러 행을 저장하는 컬렉션 형태

</br>
</br>

### ABAP 변수와 타입 선언: 초기값 vs 기본값 정리
#### 1) 초기값 (Initial Value)
- 모든 변수에는 타입에 따라 자동으로 존재하는 값
- 변수 값을 초기화하면 이 값으로 초기값이 변경됨
```abap
DATA gv_count TYPE I.   " 초기값 0 자동 존재
DATA gv_char  TYPE C.   " 초기값 공백
```

#### 2) 기본값 (Default Value)
- 변수 선언 시 임의로 지정한 값
- 초기값과 달리 개발자가 지정한 값으로 변수 시작
```abap
DATA gv_count TYPE I VALUE 10.  " 기본값 10
DATA gv_name  TYPE C LENGTH 5 VALUE 'ABAP'.  " 기본값 'ABAP'
```
</br>
</br>

---

</br>

## < ABAP 기본 문법 >
#### 1) VALUE
- 변수를 선언하면서 초기값을 지정할 때 사용
</br>
 
```abap
DATA <변수명> TYPE <데이터타입> VALUE <초기값>.
```
```abap
DATA gv_count TYPE I VALUE 10.               " 정수형 변수 초기값 10
DATA lv_name  TYPE string VALUE 'ABAP'.      " 문자형 변수 초기값 'ABAP'
```
</br>

#### 2) CONSTANTS
- 변하지 않는 값(상수)을 선언할 때 사용
- 선언 후 값 변경 불가
```abap
CONSTANTS <상수명> TYPE <데이터타입> VALUE <값>.
```
```abap
CONSTANTS: gc_str TYPE string VALUE 'OKOK',
           gc_num TYPE I VALUE 100.
```
</br>

#### 3) WRITE
- (필드) : 필드 길이에 맞춰 출력
- text-001 : SE51에서 정의한 텍스트 요소, 자리 표시자(&1, &2) 사용 가능
- text-001 다국어 처리 방법 : `Goto → Translation 선택 -> 원하는 언어(EN/KO) 문자열 입력 → 저장 -> 실행 시 환경 언어에 맞춰 자동 출력`
```abap
WRITE: 'My selected variable : '(GRE),
       gc_num,
       text-001.
```
- WRITE 구문에서 필드 길이 지정
- (n) : 출력 시 지정한 길이만큼 공간 확보
```abap
WRITE: (10) gv_data,   " gv_data 값을 10자리 폭으로 출력
       (8)  gv_data2.  " gv_data2 값을 8자리 폭으로 출력
```
</br>

#### 4) MOVE
- 값을 다른 변수에 대입할 때 사용하는 구문(현재는 `=` 와 동일하게 동작)
```abap
MOVE <source> TO <target>.
```
```abap
DATA gv_num1 TYPE I VALUE 10.
DATA gv_num2 TYPE I.

MOVE gv_num1 TO gv_num2.     " gv_num2 = 10
```
</br>

#### 5) CLEAR
- 변수 또는 내부 테이블의 값을 초기값으로 리셋할 때 사용 (타입별 초기값으로 설정됨)
```abap
CLEAR <변수명>.
```
```abap
DATA gv_num TYPE I VALUE 10.
DATA gv_text TYPE c LENGTH 5 VALUE 'ABAP'.

CLEAR gv_num.    " 결과: 0
CLEAR gv_text.   " 결과: '     ' (공백)
```
</br>

#### 6) STRLEN
- 문자열의 길이(문자 수)를 구할 때 사용
```abap
<변수> = STRLEN( <문자열> ).
```
```abap
DATA gv_text TYPE string VALUE 'ABAP'.
DATA gv_len  TYPE i.

gv_len = STRLEN( gv_text ).     " 결과: 4
```
</br>

#### 7) IF문
- 조건에 따라 코드 블록을 실행할 때 사용
- 괄호 양 옆에 띄어쓰기 필수
  
  - 비교 연산자 : EQ (=), NE (≠), GT (>), LT (<), GE (≥), LE (≤), = (같다), <> (같지 않다), > (크다), < (작다), >= (크거나 같다), <= (작거나 같다)
  - 논리 연산자 : AND (그리고), OR (또는), NOT (부정)
  - 초기값 확인 : IS INITIAL (초기값인지 확인), IS NOT INITIAL (초기값이 아닌지 확인)
```abap
IF <조건1> AND <조건2>.
    " 두 조건 모두 참일 때 실행
ELSEIF <조건1> OR <조건3>.
    " 조건1 또는 조건3 중 하나라도 참이면 실행
ELSEIF NOT gv_flag.
    " gv_flag가 FALSE일 때 실행
ELSEIF gv_var IS NOT INITIAL.
    " gv_var가 초기값이 아닐 때 실행
ELSE.
    " 위 조건이 모두 아니면 실행
ENDIF.
```
```abap
DATA gv_num1 TYPE i VALUE 10.
DATA gv_num2 TYPE i VALUE 0.
DATA gv_flag TYPE abap_bool VALUE abap_false.
DATA gv_text TYPE string.

IF gv_num1 > 5 AND gv_num2 = 0.
    WRITE '조건 1과 2 모두 만족'.
ELSEIF gv_num1 = 5 OR gv_num2 = 1.
    WRITE '조건 1 또는 2 만족'.
ELSEIF NOT gv_flag.
    WRITE 'gv_flag가 FALSE'.
ELSEIF gv_text IS NOT INITIAL.
    WRITE 'gv_text 값 있음'.
ELSE.
    WRITE '모든 조건 불만족'.
ENDIF.
```
</br>

#### 8) CASE문
- 하나의 변수 값에 따라 여러 경우를 처리할 때 사용
```abap
CASE <변수>.
    WHEN <값1>.
        <실행문>.
    WHEN <값2>.
        <실행문>.
    WHEN OTHERS.
        <실행문>.
ENDCASE.
```
```abap
DATA gv_code TYPE c LENGTH 1 VALUE 'B'.

CASE gv_code.
    WHEN 'A'.
        WRITE 'Apple'.
    WHEN 'B'.
        WRITE 'Banana'.
    WHEN OTHERS.
        WRITE 'Unknown'.
ENDCASE.
```
</br>

#### 9) MESSAGE
- 프로그램 실행 중 사용자에게 알림, 경고, 오류 등을 출력
```abap
MESSAGE '<메시지 내용>' TYPE '<메시지 타입>'.
```
```abap
MESSAGE '나이를 입력해주세요' TYPE 'E'.  " 오류 메시지
```

</br>
</br>

---
</br>

## < 연산자(Operators) >
- ABAP에서 사용되는 기본 산술 연산자
```abap
+   : 더하기
-   : 빼기
*   : 곱하기
/   : 나누기
**  : 지수(제곱) → 2 ** 3 = 8
DIV : 정수 나눗셈의 몫
MOD : 나머지
```
```abap
DATA a TYPE i VALUE 10.
DATA b TYPE i VALUE 3.
DATA r TYPE i.

r = a + b.      " 13
r = a ** b.     " 1000 (10의 3승)
r = a DIV b.    " 3   (몫)
r = a MOD b.    " 1   (나머지)
```
</br>

### 내장함수
- `abs()` : 숫자의 절대값을 반환
- `strlen()` : 문자열 길이를 반환
- `sqrt()` : 숫자의 제곱근을 반환
- `ipow()` : 정수 거듭제곱 계산 (base^exp)
```abap
DATA: gv_num TYPE I,
      gv_len TYPE string,
      gv_sqrt TYPE I,
      gv_ipow TYPE I.

gv_num = abs( -20 ).
gv_len = strlen( 'Hello World' ).
gv_sqrt = sqrt( abs( 9 ) ).
gv_ipow = ipow( base = 5 exp = 3 ).

write:/ '절대값 abs : ', gv_num,     " 20
      / '문자열길이 len : ', gv_len,  " 11
      / '제곱근 sqrt : ', gv_sqrt,   " 3
      / '지수 ipow : ', gv_ipow.    " 125
```
</br>

### 문자열 처리 함수
- `&&` : 두 문자열을 간단히 이어 붙일 때 사용.
- `CA` : 왼쪽 문자열에 오른쪽 문자열의 문자 중 하나라도 포함되어 있으면 TRUE. 대소문자 구분함.
- `CONCATENATE` : 여러 문자열을 순서대로 연결. `SEPARATED BY`로 각 문자열 사이에 넣을 구분자 지정 가능.
```abap
DATA lv_result TYPE string.
lv_result = 'Hello' && ' World'.    " 결과: 'Hello World'

DATA lv_str TYPE string.
lv_str = 'ABC123'.
IF lv_str CA '123'.
  WRITE: / '숫자를 포함함'.
ENDIF.

DATA: lv_text1 TYPE string VALUE '여기는 서울',
      lv_text2 TYPE string VALUE '날씨가 맑습니다',
      result   TYPE string.
CONCATENATE lv_text1 '이고' lv_text2 '입니다'
INTO result SEPARATED BY space.
WRITE: / result.
" 결과: '여기는 서울 이고 날씨가 맑습니다 입니다'
```
</br>
</br>

---

</br>

## < 실습 코드 >
- 실습 1
```abap
" 변수 선언 시
" => gv_ 글로벌 Data obj
" => lv_ 로컬 Data obj
" 타입 선언 시
" => tv_ : Type value
" 파라미터 선언 시
" => pv_ : 첫 글자에 Parameter 약자 P
" 상수 선언 시
" => gc_ : 첫 글자에 Constants 약자

" 연습
TYPES: tv_char(10) TYPE C,
       tv_dec TYPE P LENGTH 3 DECIMALS 2.

PARAMETERS: pv_data TYPE C LENGTH 3 DEFAULT 'HI'.

DATA: gv_dec TYPE tv_dec,
      gv_date TYPE D,
      gv_char2 TYPE tv_char,
      gv_num TYPE I VALUE 20,
      gv_carrname TYPE S_CARRNAME,
      gv_conn TYPE S_CONN_ID.
DATA: gv_carrname2 LIKE gv_carrname VALUE 'TEST'.

CONSTANTS: gc_str TYPE string VALUE 'OKOK',
           gc_num TYPE I VALUE 100.

WRITE: 'My selected variable : '(GRE),
       gc_num,
       text-001.

" Message Class / Text symbols 를 사용하여 메세지 관리를 하는데,
" Text symbols 에서는 변수 사용할 수 없음
" 변수 사용하려면 Message Class를 사용하자
```
</br>
</br>

- 실습 2
```abap
PARAMETERS name(10) TYPE C.
WRITE: name, 'trainee can learn ABAP programming.'(GRE).

" GRE 더블클릭해서 Text symbols의 값 trainee can learn ABAP programming. 로 설정 -> Translation 선택 -> 원하는 언어(EN/KO) 문자열 입력 → 저장
```
</br>
</br>

- 실습 3
```abap
PARAMETERS: pa_num1 TYPE i,
            pa_num2 TYPE i.

DATA: gv_result TYPE i.

gv_result = pa_num1 + pa_num2.    " 5 + 2 = 7
gv_result = pa_num1 - pa_num2.    " 5 - 2 = 3
gv_result = pa_num1 * pa_num2.    " 5 + 2 = 7
gv_result = pa_num1 / pa_num2.    " 5 / 2 = 3 -> 정수끼리 나눗셈 후 반올림
gv_result = pa_num1 ** pa_num2.   " 5 ** 2 = 25
gv_result = pa_num1 DIV pa_num2.  " 5 DIV 2 = 2 -> 반올림 없음
gv_result = pa_num1 MOD pa_num2.  " 5 MOD 2 = 1

WRITE:/ gv_result.
*Pretty printer(코드정리) 사용시 Shift + F1
```
</br>
</br>

- 실습 4
```abap
PARAMETERS pa_age TYPE I.

IF pa_age IS INITIAL.
    MESSAGE '나이를 입력해주세요' TYPE 'E'.

ELSEIF pa_age GE 8 AND pa_age LE 13.
    WRITE '초등학생입니다.'.

ELSEIF pa_age GT 13 AND pa_age LE 16.
    WRITE '중학생입니다.'.

ELSEIF pa_age GT 16 AND pa_age LT 20.
    WRITE '고등학생입니다.'.

ELSE.
    WRITE '성인입니다.'.
ENDIF.
```
</br>
</br>

- 실습 5
```abap
PARAMETERS pa_curr TYPE C LENGTH 3.

CASE pa_curr.
  WHEN 'USD'.
    WRITE: '달러를 선택하였습니다.'.
  WHEN 'EUR'.
    WRITE: '유로를 선택하였습니다.'.
  WHEN 'KRW'.
    WRITE: '한화를 선택하였습니다.'.
  WHEN OTHERS.
    MESSAGE 'USD, EUR, KRW 중 하나를 입력하세요' TYPE 'E'.
ENDCASE.
```
</br>
</br>

- 실습 6
```abap
PARAMETERS: pa_check AS CHECKBOX.

CASE 'X'.
  WHEN pa_check.  " 체크박스에 체크 됐을 때
    WRITE: '체크되었습니다'.
  WHEN OTHERS.    " 체크박스에 체크가 안됐을 때
    WRITE: '체크되지 않았습니다.'.
ENDCASE.
```
</br>
</br>

- 실습 7
```abap
PARAMETERS score TYPE I.
PARAMETERS pa_check AS CHECKBOX.

IF ( score LE 100 AND score GE 80 ).
  IF ( pa_check EQ 'X' ).
    WRITE '성적 : A 우수상'.
  else.
    WRITE '성적 : A'.
  ENDIF.
ELSEIF ( score LT 80 AND score GE 60 ).
  WRITE '성적 : B'.
ELSEIF ( score LT 60 AND score GE 40 ).
  WRITE '성적 : C'.
ELSE.
  WRITE '성적 : F'.
ENDIF.
```
```abap
PARAMETERS score TYPE I.
PARAMETERS pa_check AS CHECKBOX.

IF ( score <= 100 AND score >= 80 ).
  IF pa_check EQ 'X'.
    WRITE '성적 : A 우수상'.
  else.
    WRITE '성적 : A'.
  ENDIF.
ELSEIF ( score < 80 AND score >= 60 ).
  WRITE '성적 : B'.
ELSEIF ( score < 60 AND score >= 40 ).
  WRITE '성적 : C'.
ELSE.
  WRITE '성적 : F'.
ENDIF.
```
</br>
</br>

- 실습 8
```abap
PARAMETERS: pa_int1 TYPE i,
            pa_int2 TYPE i,
            pa_op   TYPE c.

TYPES: ty_result TYPE p LENGTH 16 DECIMALS 2.

DATA gv_result TYPE ty_result.


CASE pa_op.
  WHEN '+'.
    gv_result = pa_int1 + pa_int2.
  WHEN '-'.
    gv_result = pa_int1 - pa_int2.
  WHEN '*'.
    gv_result = pa_int1 * pa_int2.
  WHEN '/'.
    IF ( pa_int1 = 0 OR pa_int2 = 0 ).
      MESSAGE '0을 나눌 순 없습니다.' TYPE 'E'.
    ENDIF.
    gv_result = pa_int1 / pa_int2.
  WHEN '%'.
    PERFORM CALC_PERCENTAGE USING pa_int1 pa_int2 CHANGING gv_result.
  WHEN OTHERS.
    MESSAGE '타당하지 않는 연산자입니다.' TYPE 'E'.
ENDCASE.

WRITE: gv_result.

FORM CALC_PERCENTAGE USING VALUE(PV_ACT) TYPE I
                           VALUE(PV_MAX) TYPE I
                     CHANGING VALUE(CV_RESULT) TYPE ty_result.
  IF ( PV_MAX = 0 ).
    MESSAGE '0이 들어올 수 없습니다.' TYPE 'E'.
  ELSE.
    CV_RESULT = ( PV_ACT / PV_MAX ) * 100.
  ENDIF.
ENDFORM.
```
