## < Table Join 방법 >
### 1) Database View 이용
- DB 레벨에서 여러 테이블을 미리 조인하여 가상 테이블(View) 생성
- 재사용 가능, SQL 최적화, 코드 간결
- 조건 변경에는 유연하지 않음
```abap
SELECT <필드1> <필드2> ...
  FROM <DatabaseView>
  WHERE <조건>.
```
```
SELECT carrid connid carrname      
  FROM zabc        " zabc는 이미 여러 테이블을 조인해 만든 Database View
  WHERE carrid = 'LH'.
```
</br>

### 2) 프로그램에서 직접 조인
- ABAP 프로그램 안에서 SELECT문에서 직접 JOIN 수행
- 조건을 동적으로 처리 가능, 유연성 높음
- 코드 길어지고, DB 최적화는 View보다 어려움
</br>

- `INNER JOIN` : 두 테이블 모두에 있는 데이터만 반환 (교집합)
- `LEFT OUTER JOIN` : 왼쪽 테이블 기준, 오른쪽 테이블 없으면 NULL 포함
- `RIGHT OUTER JOIN` : 오른쪽 테이블 기준, 왼쪽 테이블 없으면 NULL 포함
</br>

- `-` : 내부 테이블(워크 에어리어) 또는 구조 필드 접근용
- `~` : DB 테이블이나 뷰 필드 접근용 (SELECT, JOIN, WHERE 등)
```abap
SELECT <테이블1~필드>, <테이블2~필드>
  INTO TABLE <내테이블>
  FROM <테이블1>
  INNER JOIN <테이블2>
  ON <테이블1~키> = <테이블2~키>
  WHERE <조건>.
```
```abap
SELECT SCARR~CARRID
       SPFLI~CONNID
       SCARR~CARRNAME
       SPFLI~CITYFROM
  INTO TABLE lt_flight
  FROM SCARR as A INNER JOIN SPFLI as B
    ON SCARR~CARRID = SPFLI~CARRID      " spfli와 scarr 모두 존재하는 carrid만 결과에 포함
  WHERE SCARR~CARRID = 'AA'.

  IF sy-subrc = 0.
    cl_demo_output=>display( lt_flight ).
  ENDIF.
```
```abap
TYPES: BEGIN OF ts_data,
        CARRID TYPE SCARR-CARRID,
        CONNID TYPE SFLIGHT-CONNID,
        FLDATE TYPE SFLIGHT-FLDATE,
       END OF ts_data.

DATA: gs_data TYPE ts_data,
      gt_data TYPE TABLE OF ts_data.

SELECT C~CARRID F~CONNID F~FLDATE
  INTO TABLE gt_data
  FROM SCARR AS C INNER JOIN SFLIGHT AS F
    ON C~CARRID = F~CARRID
  WHERE C~CARRID = 'AA'.

  IF sy-subrc = 0.
    cl_demo_output=>display( gt_data ).
  ENDIF.
```
</br>
</br>

---

</br>

## < ABAP EVENT >
- 프로그램 실행 시점에 자동 호출되는 코드 블록
- 주요 이벤트
  - **INITIALIZATION**
    - 프로그램 시작 시 실행
    - 화면이나 변수의 초기값 설정
  - **AT SELECTION-SCREEN**
    - 사용자가 셀렉션 스크린에 입력한 값 처리
    - 입력값 검증이나 추가 처리 수행
  - **START-OF-SELECTION**
    - SAP에서 사전 정의된 이벤트
    - 프로그램 실행 시 자동 호출
    - 메인 처리 로직 수행 (데이터 조회, 주요 작업)
- 주의 및 특징
  - 동일 이벤트 중복 선언 불가
  - 모든 이벤트 작성 필요 없음 (필요한 것만 사용)
  - 이벤트 순서와 상관없이 호출 시점에 따라 실행됨
```abap
REPORT z_event_example.

" 초기값 설정
INITIALIZATION.
  gv_title = '항공편 조회 프로그램'.

" 셀렉션 스크린 입력값 검증
PARAMETERS: p_carrid TYPE spfli-carrid.

AT SELECTION-SCREEN.
  IF p_carrid IS INITIAL.
    MESSAGE '항공사를 입력하세요.' TYPE 'E'.
  ENDIF.

" 메인 처리 로직
START-OF-SELECTION.
  SELECT * FROM spfli
    WHERE carrid = p_carrid
    INTO TABLE @DATA(lt_spfli).

  LOOP AT lt_spfli INTO DATA(ls_spfli).
    WRITE: / ls_spfli-carrid, ls_spfli-connid, ls_spfli-cityfrom, ls_spfli-cityto.
  ENDLOOP.
```
</br>
</br>

---

</br>

## < Class 클래스 (SE24) >
- 객체를 만들기 위한 틀. 속성과 기능을 정의.
- 객체(인스턴스): 클래스에서 만들어진 실제 존재하는 개별 데이터 단위
- 클래스 구성
  - 속성(Attributes): 객체 상태 정보
  - 메서드(Methods): 객체가 수행하는 기능
- 접근 제한자
  - `public` : 외부에서 접근 가능
  - `private` : 외부에서 접근 불가
- 객체 특징
  - 각 객체는 독립적인 메모리 보유 → 속성/메서드 상태가 객체마다 다름 (`instance component`)
  - 모든 객체가 공통으로 접근하는 속성/메서드 → `static component`
```abap
CLASS <클래스명> DEFINITION.
  PUBLIC SECTION.
    "객체별 속성(Attributes)
    DATA: <속성1> TYPE <타입>,
          <속성2> TYPE <타입>.

    "객체별 기능(Methods)
    METHODS: <메서드명>.

    "모든 객체가 공통으로 쓰는 속성/메서드 (Static)
    CLASS-DATA: <static속성> TYPE <타입> VALUE <초기값>.

  PRIVATE SECTION.
    "외부 접근 불가 속성/메서드
    DATA: <속성명> TYPE <타입>.
    METHODS: <메서드명>.
ENDCLASS.

CLASS <클래스명> IMPLEMENTATION.
  METHOD <메서드명>.
    "메서드 내용
  ENDMETHOD.
ENDCLASS.
```
```abap
CLASS zcl_car DEFINITION.
  PUBLIC SECTION.
    DATA: color TYPE string,    "각 자동차 색상
          speed TYPE i.         "각 자동차 속도
    METHODS: show_info.         "정보 출력
    CLASS-DATA: total_cars TYPE i VALUE 0.  "모든 자동차 공통
ENDCLASS.

CLASS zcl_car IMPLEMENTATION.
  METHOD show_info.
    WRITE: / '자동차 색상:', color, '속도:', speed.
  ENDMETHOD.
ENDCLASS.

"객체 생성
DATA(car1) = NEW zcl_car( ).
DATA(car2) = NEW zcl_car( ).

car1->color = 'Red'. car1->speed = 100.
car2->color = 'Blue'. car2->speed = 120.

"메서드 호출
car1->show_info( ).
car2->show_info( ).

"static 속성 사용
zcl_car=>total_cars = 2.
WRITE: / '총 자동차 수:', zcl_car=>total_cars.
```
</br>
</br>

---

</br>

## < ABAP 추가 문법 >
</br>

**1) APPENDING**
- SELECT 결과를 기존 내부 테이블 뒤에 이어서 추가
- 기존 데이터는 그대로 유지
- 필드명이 같은 컬럼끼리 자동 매칭
- 구문 비교:
  - `INTO TABLE itab` → 내부테이블 기존 내용 삭제 후 새 데이터
  - `APPENDING CORRESPONDING FIELDS OF TABLE itab` → 기존 데이터 유지 후 추가
```abap
SELECT <필드1> <필드2> ...
  FROM <테이블>
  APPENDING CORRESPONDING FIELDS OF TABLE <itab>  " `INTO` 대신 `APPENDING` 넣기
  WHERE <조건>.
```
</br>
</br>

**2) CLIENT SPECIFIED**
- SAP ABAP에서 일반적으로 SELECT는 현재 클라이언트(sy-mandt) 기준으로만 데이터 조회.
- CLIENT SPECIFIED를 사용하면 MANDT 값을 직접 지정하여 다른 클라이언트 데이터도 조회 가능.
- 주의: 잘못 사용하면 보안/데이터 일관성 문제 발생 가능.
```abap
SELECT fields
  INTO <TABLE|STRUCTURE>
  FROM dbtable
  CLIENT SPECIFIED
  WHERE mandt = '값'.
```
```abap
DATA: lt_scarr TYPE TABLE OF SCARR.

SELECT *
  INTO CORRESPONDING FIELDS OF TABLE lt_scarr
  FROM SCARR
  CLIENT SPECIFIED
  WHERE mandt BETWEEN '000' AND '800'.

IF sy-subrc = 0.
  cl_demo_output=>display( lt_scarr ).
ENDIF.
```
</br>
</br>

**3) AUTHORITY-CHECK (SU21)**
- 사용자가 특정 권한을 가지고 있는지 확인하는 ABAP 구문
- Role 부여: 특정 사용자에게 역할(Role)을 부여하면 해당 권한 획득
- 권한 객체(Object) + 필드(ID) + 액티비티(ACTVT) 기반으로 체크
- ACTVT(Activity): 수행 가능한 작업 지정
  - `01` = Create
  - `02` = Change
  - `03` = Display
- AUTHORITY-CHECK: ABAP에서 사용자 권한을 확인하는 구문
  - 성공 여부는 sy-subrc로 판단 (0 = 권한 있음, <>0 = 권한 없음)
```abap
AUTHORITY-CHECK OBJECT '<권한객체>'
  ID '<필드1>' FIELD <값1>
  ID '<필드2>' FIELD <값2>
  ...
IF sy-subrc = 0.
  " 권한 있음 처리
ELSE.
  " 권한 없음 처리
ENDIF.
```
```abap
AUTHORITY-CHECK OBJECT 'S_CARRID'
  ID 'CARRID' FIELD iv_carrid
  ID 'ACTVT' FIELD '03'.  " Display 권한 체크

IF sy-subrc = 0.
  " 권한 있음 → 데이터 조회
  SELECT * FROM spfli WHERE carrid = iv_carrid.
ELSE.
  " 권한 없음 → 메시지 처리
  MESSAGE '권한이 없습니다.' TYPE 'E'.
ENDIF.
```
</br>
</br>

**4) SELECT-OPTIONS + APPEND/CLEAR**
- SELECT-OPTIONS: 화면에서 범위 조건 입력용, 내부적으로 `SIGN / OPTION / LOW / HIGH` 구조
- Select-options는 Header Line 있는 itab 이므로 APPEND 시 TO 절 생략 가능
- `APPEND` : 조건을 내부 테이블에 추가
- `CLEAR` : 헤더라인 초기화 → 다음 조건 입력 준비
```abap
" 1. SELECT-OPTIONS 선언
SELECT-OPTIONS: <so_name> FOR <field>.

" 2. 헤더라인 변수에 값 설정 후 APPEND
<so_name>-SIGN   = '<Include / Exclude>';   " 예: 'I' 또는 'E'
<so_name>-OPTION = '<연산자>';            " 예: 'EQ', 'BT', 'GE' 등
<so_name>-LOW    = '<시작값>';            " 범위 시작값
<so_name>-HIGH   = '<끝값>';              " 범위 끝값 (BT일 경우)
APPEND <so_name>.                           " 내부 테이블에 적용
CLEAR <so_name>.                            " 헤더라인 초기화 후 다음 조건 설정
```
```abap
REPORT z_example_so_append.

DATA: gt_flight TYPE TABLE OF sflight.

" SELECT-OPTIONS 선언
SELECT-OPTIONS: so_conn FOR sflight-connid.

INITIALIZATION.
  " 포함 조건: 0400
  so_conn-SIGN   = 'I'.
  so_conn-OPTION = 'EQ'.
  so_conn-LOW    = '0400'.
  APPEND so_conn.
  CLEAR so_conn.

  " 제외 조건: 0401
  so_conn-SIGN   = 'E'.
  so_conn-OPTION = 'EQ'.
  so_conn-LOW    = '0401'.
  APPEND so_conn.
  CLEAR so_conn.

START-OF-SELECTION.
  " 조건 적용 SELECT
  SELECT *
    FROM sflight
    INTO TABLE gt_flight
    WHERE connid IN so_conn.

  cl_demo_output=>display( gt_flight ).      " 결과 : CONNID = 0400 만
```
</br>
</br>

**4) SELECT-OPTIONS + APPEND/CLEAR**
```abap
```
</br>
</br>

---

</br>

## < ABAP 추가적인 개념 >
</br>

### Secondary Index
- 기본 키(primary key) 외에 추가로 만드는 검색용 인덱스
- 특정 필드 조합으로 데이터를 더 빠르게 찾기 위해 사용
- WHERE 조건에 인덱스 필드가 포함되면 → DB 검색 속도 향상
</br>

### Table Buffer (테이블 버퍼링)
- 자주 사용하는 테이블 데이터를 DB에서 읽지 않고 메모리(Buffer) 에 저장해두고 읽는 방식
- 버퍼에 있으면 DB 접근 없이 바로 조회 → 조회 속도 매우 빠름
- 읽기 중심 테이블에 적합, 변경이 잦은 테이블에는 비권장
- 테이블마다 `버퍼링 허용 여부`를 SAP Dictionary(SE11)에서 설정
</br>

### DB & 내부 테이블 연산 정리
- **INSERT** : 값 없을 때 새로 추가
- **UPDATE** : 값 있을 때 갱신
- **DELETE** : 값 삭제
- **MODIFY (DB)** : 값 있으면 UPDATE, 없으면 INSERT
- **MODIFY (ITAB)** : 조건에 맞는 행만 갱신, 값 없으면 추가되지 않음

</br>
</br>

---

</br>

## < 실습 코드 >
</br>

### 실습 1
- Event 함수 실습
```abap
DATA: gt_flight TYPE TABLE OF SFLIGHT,
      gs_flight LIKE LINE OF gt_flight.

SELECT-OPTIONS: so_con FOR gs_flight-connid.
PARAMETERS: pa_car TYPE sflight-carrid,
            pa_chk TYPE CHAR01 AS CHECKBOX DEFAULT 'X'.

INITIALIZATION.
  pa_car = 'LH'.
  so_con-SIGN = 'I'.
  so_con-OPTION = 'EQ'.
  so_con-LOW = '0400'.
  so_con-HIGH = '0402'.
  APPEND so_con. " 원래 APPEND SO_CON TO SO_SON 처럼
                 " TO~부분이 있어야 하지만, Select-options는
                 " Header Line 있는 itab 이므로 생략
  CLEAR so_con.  " Header(Structure)만 클리어

  so_con-SIGN = 'E'.
  so_con-OPTION = 'EQ'.
  so_con-LOW = '0400'.      " 0401, 0402만 조회
  APPEND so_con.
  CLEAR so_con.

AT SELECTION-SCREEN.
  IF pa_chk = 'X' AND pa_car IS INITIAL.
    MESSAGE 'carrid를 입력하세요~~~~' TYPE 'E'.
  ENDIF.

START-OF-SELECTION.
  SELECT *
    FROM SFLIGHT
    INTO CORRESPONDING FIELDS OF TABLE gt_flight
    WHERE CARRID = PA_CAR
      AND CONNID IN SO_CON.

  IF sy-subrc = 0.
    cl_demo_output=>display( gt_flight ).
  ENDIF.
```
</br>
</br>

### 실습 2
- Event 함수, Function Module 실습
```abap
PARAMETERS: pa_car TYPE S_CARR_ID.
DATA: gt_data TYPE BC400_T_CONNECTIONS.
" TABLE OF로 가져오고 싶으면 KEY 설정 맞추기
" DATA: gt_data TYPE STANDARD TABLE OF BC400_S_CONNECTION WITH NON-UNIQUE KEY CARRID CONNID. 

AT SELECTION-SCREEN.
  IF pa_car IS INITIAL.
    MESSAGE 'pa_car가 입력되지 않았습니다.' TYPE 'E'.
  ENDIF.

START-OF-SELECTION.
  CALL FUNCTION 'ZGET_CONNECT03'
    EXPORTING
      iv_carrid = pa_car
    IMPORTING
      ET_CONNECT = gt_data
    EXCEPTIONS
      NO_DATA   = 1
      OTHERS    = 2.

  IF sy-subrc <> 0.
    MESSAGE 'No Data error!' TYPE 'E'.
  ELSE.
    cl_demo_output=>display( gt_data ).
  ENDIF.
```
</br>
</br>

### 실습 3
- class/method 코드
```abap
METHOD get_power.
  DATA lv_power TYPE bc400_compute_power.

*Simple error handling
  IF iv_power >= 5 OR iv_power <= 0.
    ev_result = 0.
    RAISE EXCEPTION TYPE cx_bc400_power_too_high.
*Calculate result
  ELSEIF iv_power = 1.
    ev_result = iv_base.
  ELSE.
    TRY.
        ev_result = iv_base * iv_base.
        lv_power = iv_power - 1.

        WHILE sy-index < lv_power .
          ev_result =  ev_result * iv_base.
        ENDWHILE.
      CATCH cx_sy_arithmetic_overflow.
        ev_result = 0.
        RAISE EXCEPTION TYPE cx_bc400_result_too_high.
    ENDTRY.
  ENDIF.
ENDMETHOD.
```
- program 코드
```abap
TYPES tv_result TYPE P LENGTH 16 DECIMALS 2.

PARAMETERS: pa_int1 TYPE I,
            pa_int2 TYPE I.

DATA: gv_result TYPE tv_result.

TRY.
CALL METHOD cl_bc400_compute=>get_power
  EXPORTING
    iv_base  = pa_int1
    iv_power = pa_int2
  IMPORTING
   ev_result = gv_result
  .
  CATCH cx_bc400_power_too_high.
    MESSAGE 'Power too high!!' TYPE 'E'.
  CATCH cx_bc400_result_too_high.
    MESSAGE 'Result too high!!' TYPE 'E.'.
ENDTRY.

WRITE:/ gv_result.
```
</br>
</br>

### 실습 4
- class(method 가져오기) 실습
```abap
PARAMETERS: CARRID TYPE S_CARR_ID,
            CONNID TYPE S_CONN_ID.
DATA: gt_data TYPE BC400_T_FLIGHTS.

INITIALIZATION.
  CARRID = 'AA'.
  CONNID = '0017'.

AT SELECTION-SCREEN.
  IF ( CARRID IS INITIAL OR CONNID IS INITIAL ).
    MESSAGE 'CARRID 나 CONNID 가 빈 값입니다.' TYPE 'E'.
  ENDIF.

START-OF-SELECTION.
  TRY.
  CALL METHOD cl_bc400_flightmodel=>get_flights
    EXPORTING
      iv_carrid = CARRID
      iv_connid = CONNID
    IMPORTING
     et_flights = gt_data.

    CATCH cx_bc400_no_data.
      MESSAGE 'ERROR ! : No Data for Selection' TYPE 'E'.
    CATCH cx_bc400_no_auth.
      MESSAGE 'EEROR ! : No Authorization for Airline' TYPE 'E'.
  ENDTRY.

  cl_demo_output=>display( gt_data ).
```
