## < Internal Table (화면 출력/데이터 처리용 메모리 테이블) >
- Internal 테이블은 프로그램 안에서 임시로 데이터를 저장·처리하는 메모리상의 테이블
- 일반 테이블은 DB에 실제로 저장되어 여러 사용자와 프로그램이 공유하는 영구 테이블
</br>

**1) Line Type**
- 내부 테이블 한 줄(Row)의 구조
- Structure 또는 Dictionary 테이블 구조를 기반으로 함
</br>

**2) Primary Key**
- key = 내부 테이블에서 검색/행 식별에 사용되는 기준 필드
  - `components` → 어떤 필드들이 키인지
  - `uniqueness` → 중복 허용 여부 (UNIQUE / NON-UNIQUE)
  - `sequence` → 정렬 여부 (Sorted 테이블에서만 의미 있음)
</br>

**3) Table Kind**
- 내부 테이블의 정렬 방식, 중복 가능 여부, 검색 성능을 결정
- 종류:
  - Standard Table (Index Table)
  - Sorted Table
  - Hashed Table
</br>
</br>

**< ABAP Internal Table 비교 >**

| 구분 | STANDARD TABLE | SORTED TABLE | HASHED TABLE |
|------|----------------|--------------|--------------|
| **Table Kind** | Standard Table | Sorted Table | Hashed Table |
| **Index Access** | ✔ 가능 | ✔ 가능 | ❌ 불가능 |
| **Key Access** | ✔ 가능 | ✔ 가능 | ✔ 가능 |
| **Key Uniqueness** | NON-UNIQUE (중복 허용) | UNIQUE / NON-UNIQUE (중복 허용/불가 둘 다 가능) | UNIQUE (중복 불가) |
| **Use In** | Mainly Index Access (주로 인덱스 접근) | Mainly Key Access (주로 키 기반 검색) | Only Key Access (키 기반 초고속 검색 전용) |

</br>
</br>

---
</br>

## < Internal Table 선언 3가지 방식 >
</br>

**1) Table Type 기반**
- 이미 정의된 Table Type을 사용하여 Internal Table 선언
- Table Type에 Line Type, Table Kind, Key 등이 미리 정의되어 있어 코드가 간결
```abap
DATA <internal_table_name> TYPE <table_type>.
```
```abap
DATA gt_flights TYPE BC400_T_FLIGHTS.
DATA gt_flights TYPE tt_flights.
```
</br>
</br>
</br>

**2) Table Kind + Key 직접 정의**
- Table Type 없이 Internal Table 종류(Standard/Sorted/Hashed)와 Key를 직접 지정
- Table Type 없이 바로 선언 가능, Key 조건도 자유롭게 지정
```abap
DATA <internal_table_name> TYPE <table_kind> TABLE OF <structure_type>
     WITH [UNIQUE | NON-UNIQUE] KEY <field1> <field2> ... .
```
```abap
DATA gt_iteb1 TYPE STANDARD TABLE OF BC400_S_FLIGHT WITH DEFAULT KEY.
DATA gt_item2 TYPE STANDARD TABLE OF BC400_S_FLIGHT WITH NON-UNIQUE KEY CARRID CONNID.
DATA gt_item4 TYPE SORTED TABLE OF BC400_S_FLIGHT WITH NON-UNIQUE KEY CARRID CONNID.
DATA get_item6 TYPE HASHED TABLE OF BC400_S_FLIGHT WITH UNIQUE KEY CARRID CONNID.
```
</br>
</br>
</br>

**3) 단순 Table of Structure**
- Key를 지정하지 않고 단순히 Table of Structure 선언
- 간단하게 선언 가능, Standard Table 기본
```abap
DATA <internal_table_name> TYPE TABLE OF <structure_type>.
```
```abap
DATA gt_flight2 TYPE TABLE OF BC400_S_FLIGHT.
DATA gt_flight3 TYPE TABLE OF SCARR.
DATA gt_item3 TYPE TABLE OF BC400_S_FLIGHT.
```
</br>
</br>
</br>

## < ABAP Internal Table 및 Structure 선언과 사용 예제 >
</br>

**1) Internal Table 선언 (Table Type / Structure 기반)**
- `gt_flight` : 이미 정의된 Table Type을 기반으로 Internal Table 생성.
- `gt_flight2` : Global Structure를 기반으로 Internal Table 생성.
- `gt_flight3` : DB Transparent Table 구조를 그대로 Internal Table로 선언.
- `gt_flight4` : 기존 Table gt_flight3의 구조와 동일하게 선언(LIKE 사용).
```abap
DATA: gt_flight TYPE BC400_T_FLIGHTS,   " Table type 사용
      gt_flight2 TYPE TABLE OF BC400_S_FLIGHT,   " Global structure 사용
      gt_flight3 TYPE TABLE OF SCARR, " DB Table (Transparent table) 사용
      gt_flight4 LIKE gt_flight3. " LIKE 사용해서 Internal Table 사용
```
</br>
</br>
</br>

**2) Standard Internal Table 선언**
- `gt_iteb1` : 기본 키를 가지는 표준 Internal Table.
- `gt_item2` : 지정한 필드(CARRID, CONNID)를 기준으로 비유니크 키를 가지는 표준 Internal Table.
- `gt_item3` : 키를 명시하지 않은 표준 Internal Table.
```abap
" Standard internal table
DATA: gt_iteb1 TYPE STANDARD TABLE OF BC400_S_FLIGHT
               WITH DEFAULT KEY,
      gt_item2 TYPE STANDARD TABLE OF BC400_S_FLIGHT
               WITH NON-UNIQUE KEY CARRID CONNID,
      gt_item3 TYPE TABLE OF BC400_S_FLIGHT.
```
</br>
</br>
</br>

**3) Sorted Internal Table 선언**
- `gt_item4` : 지정된 키 기준으로 항상 정렬되는 Internal Table, 중복 키 허용.
- `gt_itab5` : 지정된 키 기준으로 정렬, 중복 키 불가.
```abap
" Sorted internal table
DATA: gt_item4 TYPE SORTED TABLE OF BC400_S_FLIGHT
               WITH NON-UNIQUE KEY CARRID CONNID, " key는 띄어쓰기로 구분
      gt_itab5 TYPE SORTED TABLE OF BC400_S_FLIGHT
               WITH UNIQUE KEY CARRID CONNID.
```
</br>
</br>
</br>

**4) Hashed Internal Table 선언**
- `get_item6` : Key 기반 Hash 구조를 사용, 빠른 검색 가능, 반드시 UNIQUE KEY 필요.
```abap
* Hashed internal table
DATA: get_item6 TYPE HASHED TABLE OF BC400_S_FLIGHT
                WITH UNIQUE KEY CARRID CONNID.
```
</br>
</br>
</br>

**5) Structure 변수 선언**
```abap
" Glocal structure type
DATA gs_flight TYPE BC400_S_FLIGHT.

" transparent table 가지고도 스트럭처 변수 생성 가능
DATA gs_flight2 TYPE SCARR.

" Table type의 Line type 정보로 스트럭처 변수 생성 가능
DATA gs_flight3 TYPE LINE OF BC400_T_FLIGHTS.

" 위에서 선언한 Internal table에서 Line type만 복사하여 생성
DATA gs_flight4 LIKE LINE OF gt_iteb1.
```
</br>
</br>
</br>

**6) 기타 Table/Structure 선언**
- `aa` : Table Type 기반 Internal Table.
- `bb` : Table Type의 Table 선언.
- `cc` : Table Type의 한 행(Line Type) 구조 변수.
- `dd` : bb Table 라인과 동일한 구조 변수(LIKE LINE OF).
- `ee` : 단일 Structure 변수.
- `ff` : dd와 같은 구조의 Internal Table(LIKE TABLE OF).
```abap
DATA: aa TYPE BC400_T_CONNECTIONS,
      " Table Type 위에 또 TABLE OF를 붙일 수 없음
      bb TYPE TABLE OF BC400_T_CONNECTIONS,    " bb TYPE aa 로 바꾸기
      cc TYPE LINE OF BC400_T_CONNECTIONS,
      dd LIKE LINE OF bb,
      ee TYPE S_CARR_ID,
      ff LIKE TABLE OF dd.
```
</br>
</br>
</br>

---
</br>

## < ABAP 인터널 테이블 CRUD 명령어 >
- INDEX 사용 시 대부분 Table 이름 뒤에 TABLE 키워드 생략 가능
- INSERT만 예외적으로 `INTO TABLE` 또는 `INTO itab` 둘 다 가능
</br>
</br>

**1-1) APPEND – 인터널 테이블 끝에 값 추가**
- 인터널 테이블의 맨 끝에 데이터를 추가
- Standard Table 기준 → 삽입 순서 그대로 유지
```abap
APPEND <추가할_행> TO <인터널_테이블>.
```
```abap
DATA: flight TYPE BC400_S_FLIGHT,
      flights_table TYPE STANDARD TABLE OF BC400_S_FLIGHT.

flight-carrid = 'AA'.
flight-connid = '001'.

APPEND flight TO flights_table.
```
</br>

**1-2) APPEND LINES OF – 다른 테이블의 여러 행 끝에 추가**
- `<소스_테이블>`의 여러 행을 `<대상_테이블>` 끝에 추가
```abap
APPEND LINES OF <소스_테이블> [WHERE <조건>] TO <대상_테이블>.
```
```abap
APPEND LINES OF flights_table1 WHERE carrid = 'AA' TO flights_table2.
```
</br>
</br>
</br>

**2-1) INSERT – 특정 위치 또는 조건에 값 삽입**
- 조건 생략 → 맨 끝에 추가 (APPEND와 동일)
- 조건/인덱스 지정 가능 → 원하는 위치에 삽입
- INSERT 구문에는 WHERE 절은 지원되지 않음
```abap
INSERT <work_area> INTO [TABLE] <internal_table> 
       [INDEX <n>] 
       [TRANSPORTING <field1> <field2> ...] 
       [LINES OF <source_table> INTO <target_table>].
```
```abap
INSERT flight INTO TABLE flights_table INDEX 2.
INSERT flight INTO TABLE flights_table.  " 맨 끝
```
</br>

**2-2) INSERT LINES OF – 다른 테이블의 여러 행 삽입**
- `<소스_테이블>`의 여러 행을 `<대상_테이블>`에 삽입
```abap
INSERT LINES OF <소스_테이블> [WHERE <조건1>] INTO TABLE <대상_테이블> [INDEX <위치>] [FROM <조건2>].
```
```abap
INSERT LINES OF flights_table1 WHERE carrid = 'AA' INTO TABLE flights_table2.
```
</br>
</br>
</br>

**3) READ – 특정 조건/위치의 값 조회**
- 조건에 맞는 첫 번째 행을 가져옴
- 성공 → `sy-subrc` = 0, 실패 → `sy-subrc` <> 0
```abap
READ TABLE <인터널_테이블> INTO <행> 
     [WITH KEY <필드1> = <값1> <필드2> = <값2> …] 
     [INDEX <위치>] [BINARY SEARCH].
```
```abap
READ TABLE flights_table INTO flight WITH KEY carrid = 'AA' connid = '001'.
IF sy-subrc = 0.
  WRITE: / 'Flight found:', flight-carrid.
ENDIF.
```
</br>
</br>
</br>

**4) MODIFY – 기존 값 수정**
- 조건에 맞는 행을 덮어씀
- Standard Table 기준 → 조건에 맞는 여러 행이 있어도, 그 중에서 가장 먼저 나오는 한 행만 수정
- INDEX 지정 시 → 해당 위치 행만 변경
- TRANSPORTING <필드> → 지정한 필드만 수정
```abap
MODIFY <인터널_테이블> 
       FROM <행_데이터> 
       [INDEX <위치>] 
       [TRANSPORTING <필드1> <필드2> ...] 
       [WHERE <조건>].
```
```abap
flight-cityfrom = 'Seoul'.
MODIFY TABLE flights_table FROM flight.

flight-price = 20000.
MODIFY flights_table FROM flight TRANSPORTING price WHERE carrid = 'AA'.

flight-price = 15000.
MODIFY flights_table FROM flight INDEX 2.
```
</br>
</br>
</br>

**5) DELETE – 행 삭제**
- `INDEX` → 특정 위치 삭제
- `WHERE` → 조건에 맞는 행 삭제
- `FROM` → 구조체와 동일한 행 삭제
```abap
DELETE <internal_table> 
       [INDEX <n>] 
       [WHERE <field1> = <value1> <field2> = <value2> ...] 
       [FROM <work_area>] 
       [TABLE <internal_table> WHERE <condition>].
```
```abap
DELETE flights_table WHERE carrid = 'AA'.
DELETE flights_table INDEX 1.
```
</br>
</br>
</br>

**6) LOOP AT – 테이블 반복 처리**
- 인터널 테이블의 모든 행 또는 조건에 맞는 행을 반복 처리
- `WHERE` 조건 생략 시 → 테이블 전체를 반복
```abap
LOOP AT <인터널_테이블> INTO <행> [WHERE <조건>].
  " 반복하면서 처리할 코드
ENDLOOP.
```
```abap
DATA: flight TYPE BC400_S_FLIGHT,
      flights_table TYPE STANDARD TABLE OF BC400_S_FLIGHT.

* 데이터 예시
* flight_table = [
*   {carrid='AA', connid='001'},
*   {carrid='BB', connid='002'},
*   {carrid='AA', connid='003'}
* ]

LOOP AT flights_table INTO flight WHERE carrid = 'AA'.
  WRITE: / flight-carrid, flight-connid.
ENDLOOP.
```

</br>
</br>
</br>

---

</br>

## < 실습 코드 >
### 실습 1
- global structure 생성하기
<img width="1520" height="660" alt="image" src="https://github.com/user-attachments/assets/d533af41-58cf-459f-a95e-12c8662a9c39" />
</br>

<img width="1556" height="668" alt="image" src="https://github.com/user-attachments/assets/44bebdb1-9117-4787-b7bd-0146e8df7f5d" />
</br>

```abap
DATA: gs_flight TYPE ZSCLB03_DEMO.

BREAK-POINT.
gs_flight-carrid = 'AA'.

WRITE:/ gs_flight-carrid.
```
</br>
</br>

### 실습 2
**1) Standard Table에 APPEND, READ, LOOP 사용**
```abap
TYPES: BEGIN OF ty_line,
        carrid TYPE sflight-carrid,
        connid TYPE sflight-connid,
        carrname TYPE scarr-carrname,
       END OF ty_line.

**********************************************************************

* Standard table 선언
DATA: lt_tab1 TYPE STANDARD TABLE OF ty_line
              WITH DEFAULT KEY,
      lt_tab2 TYPE STANDARD TABLE OF ty_line
              WITH NON-UNIQUE KEY CARRID CONNID.

DATA: ls_line TYPE ty_line. " work-area (wa)
ls_line-carrid = 'AA'.
ls_line-connid = '0017'.
ls_line-carrname = 'Add Data'.
APPEND ls_line TO lt_tab2.

ls_line-carrid = 'BB'.
ls_line-connid = '0064'.
ls_line-carrname = 'Add Data 2'.
APPEND ls_line TO lt_tab2.

ls_line-carrid = 'AA'.
ls_line-connid = '0017'.
ls_line-carrname = 'Add Data 3'.
APPEND ls_line TO lt_tab2.  " 키 중복

LOOP AT lt_tab2 INTO ls_line.
  WRITE:/ ls_line-carrid,
          ls_line-connid,
          ls_line-carrname.
ENDLOOP.

CLEAR ls_line.  "위에서 한번 사용했으니 초기화
READ TABLE lt_tab2 INTO ls_line
     WITH KEY CARRID = 'AA' CONNID = '0017'.
WRITE:/ 'Standard table: ',
      / ls_line-carrid, ls_line-carrname.
```
</br>
</br>
</br>

**2) Sorted Table에 INSERT, READ, LOOP 사용**
```abap
TYPES: BEGIN OF ty_line,
        carrid TYPE sflight-carrid,
        connid TYPE sflight-connid,
        carrname TYPE scarr-carrname,
       END OF ty_line.

**********************************************************************

* Sorted table 선언
DATA: lt_sort TYPE SORTED TABLE OF ty_line
              WITH NON-UNIQUE KEY CARRID CONNID.

" 데이터 추가
DATA: ls_line TYPE ty_line.
ls_line-carrid ='ZZ'.
ls_line-connid = '0017'.
ls_line-carrname = 'First Data'.
INSERT ls_line INTO TABLE lt_sort.

ls_line-carrid ='AA'.
ls_line-connid = '0017'.
ls_line-carrname = 'Second Data'.
* APPEND ls_line to lt_sort. "덤프 발생
INSERT ls_line INTO TABLE lt_sort.

READ TABLE lt_sort INTO ls_line INDEX 1.

IF sy-subrc = 0.
  WRITE:/ 'Sorted 결과: ',
          ls_line-carrid, ls_line-connid.
ENDIF.

LOOP AT lt_sort INTO ls_line.
  WRITE:/ ls_line-carrid,
          ls_line-connid,
          ls_line-carrname.
ENDLOOP.
```
</br>
</br>
</br>

**3) Hashed Table에 INSERT와 READ TABLE(키 기준) 사용**
```abap
TYPES: BEGIN OF ty_line,
        carrid TYPE sflight-carrid,
        connid TYPE sflight-connid,
        carrname TYPE scarr-carrname,
       END OF ty_line.

**********************************************************************

" Hashed Internal Table
DATA: lt_hash TYPE HASHED TABLE OF ty_line
              WITH UNIQUE KEY CARRID CONNID.
DATA: ls_line TYPE ty_line.
ls_line-carrid = 'AA'.
ls_line-connid = '0017'.
ls_line-carrname = 'Add Data'.
INSERT ls_line INTO TABLE lt_hash.

CLEAR ls_line.
*READ TABLE lt_hash INTO ls_line INDEX 1. " 에러 (해쉬테이블에는 인덱스 x)
READ TABLE lt_hash INTO ls_line
     WITH KEY CARRID = 'AA' CONNID = '0017'.
IF sy-subrc = 0.
  WRITE:/ 'Hashed 결과: ',
          ls_line-carrid, ls_line-connid.
ENDIF.
```
</br>
</br>
</br>

**4) DB 테이블 데이터를 Internal Table에 SELECT, LOOP 사용**
```abap
DATA: gt_flight TYPE TABLE OF SFLIGHT,
      gs_flight TYPE SFLIGHT.

SELECT *
  INTO TABLE gt_flight
  FROM sflight
  WHERE carrid = 'AA'
    AND CONNID = '0017'.

LOOP AT gt_flight INTO gs_flight.
  WRITE:/ gs_flight-carrid,
          gs_flight-connid,
          gs_flight-fldate.
ENDLOOP.
```
</br>
</br>
</br>

**5) Internal Table에 APPEND, INSERT, LOOP 사용**
```abap
DATA: gs_flight TYPE SFLIGHT,
      gt_flight LIKE TABLE OF gs_flight.

gs_flight-carrid = 'AA'.
gs_flight-connid = '0017'.
gs_flight-fldate = '20250501'.
gs_flight-price = '10000'.
gs_flight-currency = 'USD'.
gs_flight-seatsmax = 400.
gs_flight-seatsocc = 200.
APPEND gs_flight TO gt_flight.

gs_flight-carrid = 'BB'.
gs_flight-connid = '0027'.
gs_flight-fldate = '20260501'.
gs_flight-price = '1000'.
gs_flight-currency = 'EUR'.
gs_flight-seatsmax = 550.
gs_flight-seatsocc = 20.
APPEND gs_flight TO gt_flight.

gs_flight-carrid = 'AB'.
gs_flight-connid = '0064'.
gs_flight-fldate = '20270501'.
gs_flight-price = '2500'.
gs_flight-currency = 'EUR'.
gs_flight-seatsmax = 300.
gs_flight-seatsocc = 250.
INSERT gs_flight INTO TABLE gt_flight.

gs_flight-carrid = 'AC'.
gs_flight-connid = '0224'.
gs_flight-fldate = '20280501'.
gs_flight-price = '3000'.
gs_flight-currency = 'EUR'.
gs_flight-seatsmax = 60.
gs_flight-seatsocc = 5.
INSERT gs_flight INTO gt_flight INDEX 1.

LOOP AT gt_flight INTO gs_flight.
  WRITE:/ gs_flight-carrid,
          gs_flight-connid,
          gs_flight-fldate,
          gs_flight-price,
          gs_flight-currency,
          gs_flight-seatsmax,
          gs_flight-seatsocc.
ENDLOOP.
```
</br>
</br>
</br>

**6) Standard Table에 APPEND, INSERT, LOOP 사용**
```abap
DATA: gs_tab TYPE TABLE OF ZSCLB03_DEMO,    " 그냥 TABLE OF 하면 standard
      gs_line TYPE ZSCLB03_DEMO.

gs_line-CARRID = 'AA'.
gs_line-CARRNAME = '김예원'.
gs_line-CONNID = '0017'.
gs_line-CITYFROM = '인천'.
gs_line-CITYTO = '서울'.
APPEND gs_line TO gs_tab.

gs_line-CARRID = 'BB'.
gs_line-CARRNAME = '김예원'.
gs_line-CONNID = '0016'.
gs_line-CITYFROM = '광주'.
gs_line-CITYTO = '철원'.
INSERT gs_line INTO TABLE gs_tab.

gs_line-CARRID = 'CC'.
gs_line-CARRNAME = '김예원'.
gs_line-CONNID = '0015'.
gs_line-CITYFROM = '부산'.
gs_line-CITYTO = '인천'.
INSERT gs_line INTO gs_tab INDEX 1.

CLEAR gs_line.
LOOP AT gs_tab INTO gs_line.
  WRITE:/ gs_line-CARRID,
          gs_line-CARRNAME,
          gs_line-CONNID,
          gs_line-CITYFROM,
          gs_line-CITYTO.
ENDLOOP.
```
</br>

**7) Standard Table에서 READ, MODIFY, DELETE, LOOP 사용**
```abap
DATA: gs_flight TYPE SFLIGHT,
      gt_flight LIKE STANDARD TABLE OF gs_flight
      WITH NON-UNIQUE KEY CARRID CONNID FLDATE.

gs_flight-carrid = 'AA'.
gs_flight-connid = '0017'.
gs_flight-fldate = '20250501'.
gs_flight-price = '10000'.
gs_flight-currency = 'USD'.
gs_flight-seatsmax = 400.
gs_flight-seatsocc = 200.
APPEND gs_flight TO gt_flight.

gs_flight-carrid = 'BB'.
gs_flight-connid = '0027'.
gs_flight-fldate = '20260501'.
gs_flight-price = '1000'.
gs_flight-currency = 'EUR'.
gs_flight-seatsmax = 550.
gs_flight-seatsocc = 20.
APPEND gs_flight TO gt_flight.

gs_flight-carrid = 'AB'.
gs_flight-connid = '0027'.
gs_flight-fldate = '20260501'.
gs_flight-price = '1000'.
gs_flight-currency = 'EUR'.
gs_flight-seatsmax = 550.
gs_flight-seatsocc = 20.
APPEND gs_flight TO gt_flight.

gs_flight-carrid = 'BZ'.
gs_flight-connid = '0027'.
gs_flight-fldate = '20260501'.
gs_flight-price = '1000'.
gs_flight-currency = 'EUR'.
gs_flight-seatsmax = 550.
gs_flight-seatsocc = 20.
APPEND gs_flight TO gt_flight.

READ TABLE gt_flight INTO gs_flight
     WITH TABLE KEY CARRID = 'AA' CONNID = '0017' FLDATE = '20250501'.

*READ TABLE gt_flight INTO gs_flight
*     INDEX 1.

" 스트럭처의 값 변경
gs_flight-price = '9500'.
gs_flight-seatsmax = 555.

" 변경된 스트럭처를 Internal table의 첫번째 레코드에 적용(변경)
*MODIFY gt_flight FROM gs_flight INDEX 1.
MODIFY TABLE gt_flight FROM gs_flight.
*MODIFY gt_flight FROM gs_flight TRANSPORTING PRICE
*  WHERE CARRID = 'AA'.
MODIFY gt_flight FROM gs_flight INDEX 1 TRANSPORTING PRICE.

CLEAR gs_flight.
" READ TABLE 구분으로 Itab의 1번째 레코드 읽어서 gs_flight에 담는다
READ TABLE gt_flight INTO gs_flight INDEX 1.

  " 읽어온 1번째 레코드 gs_flight를 출력
*  WRITE:/ gs_flight-carrid,
*          gs_flight-connid,
*          gs_flight-fldate,
*          gs_flight-price,
*          gs_flight-seatsmax.

* Internal table에서 데이터 삭제
* => DALETE <itab> <condition>
*DELETE gt_flight INDEX 1.
*DELETE gt_flight FROM 3. " 3 이후부터 전부 삭제
*DELETE gt_flight TO 2.
*DELETE gt_flight FROM 2 TO 4. " 범위 지정하여 삭제
DELETE gt_flight WHERE carrid = 'AA'
                       AND connid = '0017'
                       AND fldate = '20250501'.

LOOP AT gt_flight INTO gs_flight.
  WRITE:/ gs_flight-carrid,
          gs_flight-connid,
          gs_flight-fldate,
          gs_flight-price,
          gs_flight-currency,
          gs_flight-seatsmax,
          gs_flight-seatsocc.
ENDLOOP.
```
</br>

**8) Standard Table에서 APPEND/INSERT LINES, MODIFY, DELETE, LOOP 사용**
```abap
TYPES: BEGIN OF ty_person,
         fname TYPE s_fname,
         lname TYPE s_lname,
       END OF ty_person.

DATA: gs_data  TYPE ty_person,
      gt_itab1  TYPE TABLE OF ty_person,
      gt_itab2 LIKE gt_itab1.

gs_data-fname = 'Hong'.
gs_data-lname = 'Gildong'.
APPEND gs_data TO gt_itab1.

gs_data-fname = 'Kim'.
gs_data-lname = 'donggu'.
APPEND gs_data TO gt_itab1.

" itab1의 전체 레코드를 itab2에 추가
APPEND LINES OF gt_itab1 TO gt_itab2.
INSERT LINES OF gt_itab1 INTO TABLE gt_itab2.

" 범위값 지정하여 여러 건의 레코드를 테이블에 추가
APPEND LINES OF gt_itab1 FROM 1 TO 2 TO gt_itab2.
INSERT LINES OF gt_itab1 FROM 2 INTO TABLE gt_itab2.
INSERT LINES OF gt_itab1 TO 2 INTO TABLE gt_itab2.

" Loop문으로 돌면서 modify
LOOP AT gt_itab2 INTO gs_data.
  gs_data-fname = '변경'.
  MODIFY gt_itab2 FROM gs_data.
ENDLOOP.

" Modify 적용 후, 적용된 Internal table을 Loop 사용하여 출력해보기
LOOP AT gt_itab2 INTO gs_data.
  WRITE:/ sy-tabix,
          gs_data-fname,
          gs_data-lname.
ENDLOOP.

ULINE.

" 범위값 지정하여 삭제
DELETE gt_itab2 WHERE lname = 'Gildong'.

" LOOP AT gt_itab2 INTO gs_data WHERE lname = 'Yewon'.
LOOP AT gt_itab2 INTO gs_data.
  WRITE:/ sy-tabix,
          gs_data-fname,
          gs_data-lname.
ENDLOOP.
```
