## <  핵심 개념 >
- **1) `CALL METHOD go_alv->check_changed_data.` : ALV에 바인딩된 it_outtab 내부테이블의 변경사항을 반영함**
</br>

- **정적(Class) 메서드는 `클래스=>` , 인스턴스(Object) 메서드는 `객체->` 로 접근함**
- **Static Method(CLASS-METHODS) 안에서는 Static 컴포넌트(CLASS-DATA)만 직접 접근 가능**
</br>
</br>

---

</br>

## < ABAP 클래스 정의 기본 구조 >
</br>

### 1) ABAP 클래스 구조와 호출 방식 정리
- 정적 메서드는 클래스 기준, 인스턴스 메서드는 객체 기준으로 호출
```abap
클래스명=>CLASS-METHOD( ).     " 가능 (정적 메서드)
클래스명=>METHOD( ).           " ❌ 오류 (인스턴스 메서드)

참조변수->METHOD( ).           " 가능 (인스턴스 메서드)
참조변수->CLASS-METHOD( ).     " 가능 (정적 메서드, 문법상 허용)
```
- `DATA` 는 객체마다 따로 생기는 변수, `CLASS-DATA` 는 클래스 전체가 하나를 공유하는 변수
- `METHODS` 는 객체(인스턴스) 생성 후 호출, `CLASS-METHODS` 는 객체 없이 클래스명으로 바로 호출
- Static Method(`CLASS-METHODS`) 안에서는 Static 컴포넌트(`CLASS-DATA`)만 직접 접근 가능
- Public 속성은 외부 접근 가능, Private 속성은 내부 전용이며 READ-ONLY는 외부 수정만 제한
```abap
*************** 클래스 정의 (CLASS DEFINITION) ****************
CLASS class_name DEFINITION.
  PUBLIC SECTION.
    " 정적 속성 (Static Attribute)
    " 클래스당 1개만 존재
    CLASS-DATA: gv_n_o_vehicles TYPE i.       " 전체 객체가 공유
  PRIVATE SECTION.
    " 인스턴스 속성 (Instance Attribute)
    " 객체 생성 시마다 개별로 생성
    DATA: variable5 TYPE string READ-ONLY.    " 읽기 전용 - 외부: 조회 가능, 수정 불가
                                                          " 클래스 내부: 둘 다 가능
ENDCLASS.
```
```abap
*************** 메서드 정의 (METHODS Syntax) ****************
CLASS class_name DEFINITION.
  PUBLIC SECTION.
    METHODS method_name
      IMPORTING         iv_par TYPE type_name    " 입력 파라미터
      EXPORTING         ev_par TYPE type_name    " 출력 파라미터
      CHANGING          cv_par TYPE type_name    " 입·출력 파라미터
      RETURNING VALUE(rv_par)  TYPE type_name    " 반환값 (메서드 실행 결과를 단일 값으로 반환)
      EXCEPTIONS  exception.                  " Classic Exception
      RAISING   cx_exception_class.           " Class-based Exception
    CLASS-METHODS static_method.               " 정적 메서드
ENDCLASS.

*************** 메서드 구현 (METHOD IMPLEMENTATION) ****************
CLASS class_name IMPLEMENTATION.
  METHOD method_name.
    " 인스턴스 메서드 로직
  ENDMETHOD.
  METHOD static_method.
    " 정적 메서드 로직
  ENDMETHOD.
ENDCLASS.
```
- 정적 메서드는 객체 생성 없이 호출 가능
```abap
*************** 클래스 정의 ****************
CLASS <class> DEFINITION.
  PUBLIC SECTION.
    METHODS <inst_meth>.
    CLASS-METHODS <static_meth>.
  PRIVATE SECTION.
    DATA mv_attr TYPE <type>.
    CLASS-DATA gv_attr TYPE i.
ENDCLASS.

*************** 클래스 구현 ****************
CLASS <class> IMPLEMENTATION.
  METHOD <inst_meth>. ENDMETHOD.
  METHOD <static_meth>. ENDMETHOD.
ENDCLASS.

*************** 객체 생성 및 호출 ****************
DATA go_obj TYPE REF TO <class>.
CREATE OBJECT go_obj.
CALL METHOD go_obj-><inst_meth>.
CALL METHOD <class>=><static_meth>.
```
```abap
REPORT ZPROGB03_0036.

*************** 클래스 정의 ****************
CLASS lcl_vehicle DEFINITION.
  PUBLIC SECTION.  " 외부에서 접근이 가능
   METHODS: set_attribute IMPORTING iv_make TYPE s_make
                                    iv_mode TYPE s_model,
            display_attributes.
   CLASS-METHODS: display_global_vehicles.
  PRIVATE SECTION. " 외부에서 접근이 불가능
   DATA: mv_make TYPE s_make,
         mv_model TYPE s_model.
   CLASS-DATA: gv_vehicles TYPE I.
ENDCLASS.

*************** 클래스 구현 ****************
CLASS lcl_vehicle IMPLEMENTATION.
  METHOD set_attribute.  " instance Method
    mv_make = iv_make.
    mv_model = iv_mode.
    gv_vehicles = gv_vehicles + 1.
  ENDMETHOD.

  METHOD display_attributes. " instance Method
    WRITE:/ 'Make: ', mv_make,
          / 'Model: ', mv_model.
  ENDMETHOD.

  METHOD display_global_vehicles.  " Static Method
    WRITE:/ 'Number of vehicle: ', gv_vehicles.
  ENDMETHOD.
ENDCLASS.
```
</br>
</br>

### 2) ABAP 객체 참조 정리
- 참조 대입(=)은 객체를 복사하지 않고 같은 객체를 함께 가리킴
- `go_vehicle1` , `go_vehicle2` → 동일 객체, `go_vehicle3` → 별도 객체
- 같은 객체를 참조하므로 `go_vehicle1` 으로 변경한 내용은 `go_vehicle2` 에서도 그대로 보임
```abap
*************** 객체 참조 (Reference) ****************
DATA: go_vehicle1 TYPE REF TO lcl_vehicle,
      go_vehicle2 LIKE go_vehicle1,
      go_vehicle3 LIKE go_vehicle1.

CREATE OBJECT go_vehicle1.
go_vehicle2 = go_vehicle1.    " 같은 객체를 참조 (참조 복사)
CREATE OBJECT go_vehicle3.    " 새로운 객체 생성

" go_vehicle1, go_vehicle2 → 동일 객체
" go_vehicle3             → 별도 객체
```
</br>
</br>

### 3) ABAP 객체 참조 테이블 (TABLE OF REF) 사용 패턴
- `TABLE OF REF TO` 는 객체 자체를 테이블에 저장하는 것이 아니라, 객체를 가리키는 참조(주소) 를 저장함
- 실제 데이터는 객체 안에 있고, 테이블에는 그 객체로 가는 포인터만 존재
```abap
*************** 객체 참조 테이블 (Multiple Instantiation) ****************
DATA:
  go_obj   TYPE REF TO <class>,                 " 단일 객체 참조
  gt_objs  TYPE TABLE OF REF TO <class>.        " 객체 참조를 담는 내부테이블

CREATE OBJECT go_obj.
APPEND go_obj TO gt_objs.    " 첫 번째 객체 참조 저장

CREATE OBJECT go_obj.
APPEND go_obj TO gt_objs.    " 두 번째 객체 참조 저장

*************** 객체 참조 테이블 접근 ****************
gt_objs[ 1 ]-><inst_meth>( ).    " 1번째 객체의 인스턴스 메서드 호출
gt_objs[ 2 ]-><static_meth>( ).  " 정적 메서드 호출 (클래스 공용)
```
```abap
REPORT ZPROGB03_0036.
START-OF-SELECTION.

*************** 객체 참조 변수 선언 ****************
 DATA: go_vehicle TYPE REF TO lcl_vehicle.
* DATA: go_vehicle2 TYPE REF TO lcl_vehicle.
 DATA: gt_vehicle TYPE TABLE OF REF TO lcl_vehicle.

*************** 객체 생성 및 설정 ****************
 CREATE OBJECT go_vehicle.
 CALL METHOD go_vehicle->set_attribute
  EXPORTING iv_make = 'MK1'
            iv_mode = 'MODEL1'.
 APPEND go_vehicle TO gt_vehicle.

 CREATE OBJECT go_vehicle.
 CALL METHOD go_vehicle->set_attribute
  EXPORTING iv_make = 'MK2'
            iv_mode = 'MODEL2'.
 APPEND go_vehicle TO gt_vehicle.

*************** 객체 참조 테이블을 통한 메서드 호출 ****************
* CALL METHOD go_vehicle1->display_attributes.
* CALL METHOD go_vehicle2->display_attributes.
* CALL METHOD go_vehicle1->display_global_vehicles.
 gt_vehicle[ 1 ]->display_attributes( ).
 gt_vehicle[ 2 ]->display_attributes( ).
 gt_vehicle[ 2 ]->display_global_vehicles( ).
```
</br>
</br>

### 4) ABAP 최신 메서드 호출 및 Static/Instance 메서드 호출 정리
- 최신 메서드 호출은 `객체->메서드( )` 형식을 사용
```abap
*************** 메서드 호출 (Method Call) ****************
DATA go_obj TYPE REF TO <class>.

CREATE OBJECT go_obj.
<ref_obj>-><method_name>(
  EXPORTING
    <iv_par1> = <value1>
    <iv_par2> = <value2>
).

*************** 정적 메서드 호출 (Static Method Call) ****************
<class_name>=><static_method>( ).
```
- 정적(Class) 메서드는 `클래스=>` , 인스턴스(Object) 메서드는 `객체->` 로 접근함
```abap
REPORT ZPROGB03_0036.

*************** 클래스 정의 ****************
CLASS lcl_vehicle DEFINITION.
  PUBLIC SECTION.                 " 외부 접근 가능
    DATA: gv_data(2) TYPE c VALUE 'OK'.        " 인스턴스 속성
    CLASS-DATA: gv_cdata(2) TYPE c VALUE 'HI'. " 정적 속성
ENDCLASS.

START-OF-SELECTION.

*************** 객체 참조 변수 선언 ****************
DATA: go_vehicle TYPE REF TO lcl_vehicle.
DATA: gt_vehicle TYPE TABLE OF REF TO lcl_vehicle.

*************** 객체 생성 및 설정 ****************
CREATE OBJECT go_vehicle.
go_vehicle->set_attribute(
  EXPORTING
    iv_make = 'MK1'
    iv_mode = 'MODEL1'
).
APPEND go_vehicle TO gt_vehicle.

CREATE OBJECT go_vehicle.
go_vehicle->set_attribute(
  EXPORTING
    iv_make = 'MK2'
    iv_mode = 'MODEL2'
).
APPEND go_vehicle TO gt_vehicle.

*************** 정적 메서드 호출 ****************
lcl_vehicle=>display_global_vehicles( ).   " 정석 호출
* gt_vehicle[ 1 ]->display_global_vehicles( ). " 문법상 가능 (비권장)

*************** 데이터 접근 방식 비교 ****************
WRITE: / gt_vehicle[ 1 ]->gv_cdata,     " 객체 통해 정적 데이터 접근
       / lcl_vehicle=>gv_cdata,         " 클래스 통해 정적 데이터 접근 (정석)
       / go_vehicle->gv_data,           " 인스턴스 데이터
       / go_vehicle->gv_cdata.          " 정적 데이터 (객체 통해 접근 가능)
```
</br>
</br>

### 5) Functional Method (함수형 메서드)
- RETURNING 파라미터를 정확히 1개만 가지는 메서드 (함수처럼 동작)
- 대입문, 조건문, 계산식 안에서 바로 호출 가능
```abap
*************** Functional Method 정의 ****************
CLASS <class_name> DEFINITION.
  PUBLIC SECTION.
    METHODS <func_method>
      IMPORTING
        iv_par TYPE <type>
      RETURNING
        VALUE(rv_result) TYPE <return_type>.
ENDCLASS.

*************** 인스턴스 함수형 메서드 ****************
result = <ref_obj>-><func_method>(
  iv_par_1 = val_1
  iv_par_n = val_n
).

*************** 정적 함수형 메서드 ****************
result = <class_name>=><func_method>(
  iv_par_1 = val_1
  iv_par_n = val_n
).
```
</br>
</br>

---

</br>

## < 실습 코드 >
</br>

### 실습 1
- local class 만들기 실습
```abap
REPORT ZBC401_03_MAIN.
TYPE-POOLS icon.

CLASS lcl_airplane DEFINITION.
  PUBLIC SECTION.
    METHODS: set_attributes IMPORTING iv_name TYPE string
                                      iv_planetype TYPE saplane-planetype,
             display_attributes.
    CLASS-METHODS: display_gv_n_o_airplanes.
  PRIVATE SECTION.
    CONSTANTS: c_pos_l TYPE I VALUE 30.
    DATA: mv_name TYPE string,
          mv_planetype TYPE saplane-planetype.
    CLASS-DATA: gv_n_o_airplanes TYPE I.
ENDCLASS.

CLASS lcl_airplane IMPLEMENTATION.
  METHOD set_attributes.
    mv_name = iv_name.
    mv_planetype = iv_planetype.
    gv_n_o_airplanes = gv_n_o_airplanes + 1.
  ENDMETHOD.

  METHOD display_attributes.
    WRITE:/ icon_ws_plane AS ICON,
          / 'Name: ', AT c_pos_l mv_name,
          / 'Planetype: ', AT c_pos_l mv_planetype.
  ENDMETHOD.

  METHOD display_gv_n_o_airplanes.
    WRITE:/ 'Number of airplane: ', gv_n_o_airplanes.
  ENDMETHOD.
ENDCLASS.

START-OF-SELECTION.
  DATA: go_airplane TYPE REF TO lcl_airplane,
        gt_airplane TYPE TABLE OF REF TO lcl_airplane.

  CREATE OBJECT go_airplane.
  APPEND go_airplane TO gt_airplane.
```
</br>
</br>

### 실습 2
</br>

- 문제
<img width="379" height="196" alt="image" src="https://github.com/user-attachments/assets/82d06abd-b1ed-47cf-8641-827addf4b214" />

</br>
</br>

```abap
REPORT ZBC400_B03_PRACTICE11.

CLASS lcl_person DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: display_info RETURNING VALUE(rv_result) TYPE CHAR40.
  PRIVATE SECTION.
    CLASS-DATA: name TYPE CHAR20 VALUE '홍길동',
                age TYPE CHAR10 VALUE '20'.
ENDCLASS.

CLASS lcl_person IMPLEMENTATION.
  METHOD display_info.
    rv_result = name && `의 나이는 ` && age && '살 입니다.'.
    WRITE: rv_result.
  ENDMETHOD.
ENDCLASS.

START-OF-SELECTION.
  lcl_person=>display_info( ).
```
</br>

- 결과 확인
<img width="275" height="135" alt="image" src="https://github.com/user-attachments/assets/168acaa0-7b64-4bfc-a1b8-5502e45386fd" />
