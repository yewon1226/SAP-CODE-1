## <  핵심 개념 >
- **1) Upcast (Widening Cast)**
</br>

- **Upcast에서 실제 객체 기준 실행은 메서드(재정의)에만 해당**
- **변수는 무조건 참조 타입 기준으로만 접근 판단**
</br>
</br>

---

</br>

## < ABAP 클래스 정의 기본 구조 >
</br>

### 1) Upcast (Widening Cast)
- 자식 객체를 부모 타입 참조 변수에 담는 것
- 객체는 그대로고, 접근 가능한 메서드만 부모 기준으로 제한됨
```abap
*************** 클래스 ****************
CLASS <parent_class> DEFINITION.
  PUBLIC SECTION.
    METHODS <parent_method>.
ENDCLASS.

CLASS <child_class> DEFINITION
  INHERITING FROM <parent_class>.
  PUBLIC SECTION.
    METHODS <child_method>.
ENDCLASS.

*************** 구현 ****************
CLASS <parent_class> IMPLEMENTATION.
  METHOD <parent_method>.
  ENDMETHOD.
ENDCLASS.

CLASS <child_class> IMPLEMENTATION.
  METHOD <child_method>.
  ENDMETHOD.
ENDCLASS.

*************** 객체 생성 및 업캐스트 ****************
DATA: <parent_obj> TYPE REF TO <parent_class>,
      <child_obj>  TYPE REF TO <child_class>.

CREATE OBJECT <child_obj>.
<parent_obj> = <child_obj>.   " Upcast

*************** 사용 ****************
<parent_obj>-><parent_method>( ).
" ✔ parent 타입에 정의된 메서드라서 컴파일 통과
" ✔ 실제 객체는 child → child에서 재정의된 메서드 실행

<parent_obj>-><child_method>( ).
" ✘ parent 타입에는 child_method가 없음
" ✘ 컴파일 단계에서 호출 불가
" ✘ 실행 단계까지 가지도 못함
```
```abap
REPORT ZPROGB03_0037.

CLASS lcl_grandparent DEFINITION.
  PUBLIC SECTION.
  DATA: pa_char(10) TYPE C VALUE 'Hello~~'.
  METHODS: constructor IMPORTING iv_kimchi TYPE string,
           cook. "요리하기 메서드 추가
  PROTECTED SECTION. "할머니 김치는 가족(본인+자녀)만 공유하도록 함
  DATA: mv_kimchi TYPE string.
ENDCLASS.

CLASS lcl_grandparent IMPLEMENTATION.
  METHOD constructor.
      mv_kimchi = iv_kimchi.
  ENDMETHOD.

  METHOD cook.
    WRITE:/ '할머니 김치 투하: ', mv_kimchi.
  ENDMETHOD.
ENDCLASS.

**********************************************************************
CLASS lcl_parent DEFINITION INHERITING FROM lcl_grandparent. "상속
  PUBLIC SECTION.
    METHODS: constructor IMPORTING iv_kimchi TYPE string
                                   iv_meat TYPE string.
    METHODS: cook REDEFINITION. "상위 클래스로부터 상속받은 메서드 재정의
  PRIVATE SECTION.
    DATA: mv_meat TYPE string.
ENDCLASS.

CLASS lcl_parent IMPLEMENTATION.
  METHOD constructor.
    super->constructor( EXPORTING iv_kimchi = iv_kimchi ).
    mv_meat = iv_meat.
  ENDMETHOD.
  METHOD cook.
    super->cook( ).
    WRITE:/ '엄마 단골가게 고기 추가: ', mv_meat.
  ENDMETHOD.
ENDCLASS.

**********************************************************************
CLASS lcl_child DEFINITION INHERITING FROM lcl_parent. "상속
  PUBLIC SECTION.
    METHODS: constructor IMPORTING iv_kimchi TYPE string
                                   iv_meat TYPE string
                                   iv_topping TYPE string.
    METHODS: cook REDEFINITION. "상위 클래스로부터 상속받은 메서드 재정의
  PRIVATE SECTION.
    DATA: mv_topping TYPE string.
ENDCLASS.

CLASS lcl_child IMPLEMENTATION.
  METHOD constructor.
    super->constructor(
      iv_kimchi = iv_kimchi
      iv_meat   = iv_meat
    ).
    mv_topping = iv_topping.
  ENDMETHOD.
  METHOD cook.
    super->cook( ).
    WRITE:/ '나만의 토핑으로 마무리: ', mv_topping.
*    SKIP.
*    WRITE:/ mv_kimchi. 할머니 클래스의 protected 변수에 접근 가능
  ENDMETHOD.
ENDCLASS.

**********************************************************************
START-OF-SELECTION.
  DATA: go_child1 TYPE REF TO lcl_child,
        go_child2 TYPE REF TO lcl_child.
  DATA: gt_super TYPE TABLE OF REF TO lcl_grandparent,
        gs_super TYPE REF TO lcl_grandparent.

  CREATE OBJECT go_child1
         EXPORTING iv_kimchi = '3년된 묵은지'
                   iv_meat = '흑돼지 앞다리살'
                   iv_topping = '스팸/대파 듬뿍'.
  APPEND go_child1 TO gt_super.

  gs_super = go_child1. "upcast
  gs_super->cook( ). "자식 클래스의 재정의된 메서드가 실행됨
  SKIP 1.
  "여전히 부모 클래스의 변수에 접근 가능
  WRITE:/ '부모변수 PA_CHAR : ' && gs_super->pa_char.
```
</br>
</br>

### 2) Up-Cast 기반 다형성 (부모 참조를 이용한 공통 처리)
- 자식 객체를 부모 타입 참조 변수에 담아 호출하는 구조 → Up-Cast
- 호출은 부모 기준이지만, 실제 실행은 자식에서 재정의된 메서드가 수행됨(다형성)
```abap
*************** 부모 ****************
CLASS <parent> DEFINITION.
  PUBLIC SECTION.
    METHODS display.
ENDCLASS.

*************** 자식 ****************
CLASS <child> DEFINITION INHERITING FROM <parent>.
  PUBLIC SECTION.
    METHODS display REDEFINITION.
ENDCLASS.

*************** START-OF-SELECTION ****************
DATA: <go_parent> TYPE REF TO <parent>,
      <go_child>  TYPE REF TO <child>.

START-OF-SELECTION.
CREATE OBJECT <go_child>.
<go_parent> = <go_child>.   " Upcast
<go_parent>->display( ).    " 자식 메서드 실행
```
```abap
REPORT  sapbc401_inh_s3.

*************** 자식 객체 생성 ****************
CREATE OBJECT go_passenger
  EXPORTING
    iv_name      = 'LH BERLIN'
    iv_planetype = '747-400'
    iv_seats     = 345.

CREATE OBJECT go_cargo
  EXPORTING
    iv_name      = 'US Hercules'
    iv_planetype = '747-200F'
    iv_cargo     = 533.

*************** Up-Cast (자식 → 부모 타입으로 저장) ****************
METHOD add_airplane.
  APPEND io_plane TO mt_airplanes.
* io_plane TYPE REF TO lcl_airplane
ENDMETHOD.

*************** 부모 참조로 메서드 호출 (다형성) ****************
METHOD display_airplanes.
  DATA lo_plane TYPE REF TO lcl_airplane.

  LOOP AT mt_airplanes INTO lo_plane.
    lo_plane->display_attributes( ).
  ENDLOOP.
ENDMETHOD.
```
</br>
</br>

### 3) Down-Cast 기반 특정 객체 접근 (Narrowing Cast + 예외 처리)
- 부모 참조 테이블에 여러 자식 객체가 섞여 있음
- 반복문에서 하나씩 꺼내 Downcast 시도
- 실제 객체가 해당 자식일 때만 캐스팅 성공
- 성공 시 자식 전용 메서드/속성 접근
- 실패 가능 → TRY–CATCH 필수
```abap
*************** 부모 ****************
CLASS <parent> DEFINITION.
  PUBLIC SECTION.
    METHODS <common_method>.
ENDCLASS.

*************** 자식 ****************
CLASS <child> DEFINITION INHERITING FROM <parent>.
  PUBLIC SECTION.
    METHODS <child_method>.
ENDCLASS.

*************** 컨테이너 ****************
CLASS <container> DEFINITION.
  PUBLIC SECTION.
    METHODS <get_specific>.
  PRIVATE SECTION.
    DATA <mt_objs> TYPE TABLE OF REF TO <parent>.
ENDCLASS.

*************** 구현 ****************
CLASS <container> IMPLEMENTATION.
  METHOD <get_specific>.
    DATA: <lo_parent> TYPE REF TO <parent>,
          <lo_child>  TYPE REF TO <child>.

    LOOP AT <mt_objs> INTO <lo_parent>.
      TRY.
          <lo_child> ?= <lo_parent>.        " Downcast
          <lo_child>-><child_method>( ).    " 자식 전용 접근
        CATCH cx_sy_move_cast_error.
          " 자식 객체가 아니면 무시
      ENDTRY.
    ENDLOOP.
  ENDMETHOD.
ENDCLASS.
```
```abap
REPORT  sapbc401_inh_s3_opt.

*************** 부모 클래스 ****************
CLASS lcl_airplane DEFINITION.
  PUBLIC SECTION.
    METHODS display_attributes.
ENDCLASS.

*************** 자식 클래스 (Downcast 대상) ****************
CLASS lcl_cargo_plane DEFINITION INHERITING FROM lcl_airplane.
  PUBLIC SECTION.
    METHODS get_cargo
      RETURNING VALUE(rv_cargo) TYPE s_plan_car.
  PRIVATE SECTION.
    DATA mv_cargo TYPE s_plan_car.
ENDCLASS.

CLASS lcl_cargo_plane IMPLEMENTATION.
  METHOD get_cargo.
    rv_cargo = mv_cargo.
  ENDMETHOD.
ENDCLASS.

*************** Downcasting 발생 메서드 ****************
METHOD get_max_cargo.
  DATA:
    lo_plane TYPE REF TO lcl_airplane,       " 부모 참조
    lo_cargo TYPE REF TO lcl_cargo_plane.    " 자식 참조

  LOOP AT mt_airplanes INTO lo_plane.
    TRY.
        lo_cargo ?= lo_plane.                " 🔴 Downcast 핵심

        IF rv_max_cargo < lo_cargo->get_cargo( ).
          rv_max_cargo = lo_cargo->get_cargo( ).
        ENDIF.

      CATCH cx_sy_move_cast_error.
*       cargo plane 이 아니면 무시
    ENDTRY.
  ENDLOOP.
ENDMETHOD.
```
</br>
</br>

### 4) 인터페이스 + ALIAS + 인터페이스 업캐스트 다형성
- 인터페이스 메서드/속성은 원래 `인터페이스~컴포넌트` 형식으로 접근
- ALIAS를 쓰면 클래스 안에서 짧은 이름으로 재정의 가능
- 외부 호출 시 가독성↑, 인터페이스 구조는 그대로 유지
- 인터페이스 참조 변수로 객체를 받는 것 = 인터페이스 업캐스트
- 업캐스트 시 인터페이스에 정의된 메서드/속성만 접근 가능
```abap
*************** 인터페이스 정의 ****************
INTERFACE <if_partner>.
  METHODS <display_partner>.
  DATA <gv_partner_id> TYPE n LENGTH 10.
ENDINTERFACE.

*************** 클래스 정의 (인터페이스 + ALIAS) ****************
CLASS <lcl_rental> DEFINITION.
  PUBLIC SECTION.
    INTERFACES <if_partner>.
    ALIASES <display_partner1>
      FOR <if_partner>~<display_partner>.

  PRIVATE SECTION.
    ALIASES <gv_partner>
      FOR <if_partner>~<gv_partner_id>.
ENDCLASS.

*************** 클래스 구현 ****************
CLASS <lcl_rental> IMPLEMENTATION.
  METHOD <if_partner>~<display_partner>.
    " 실제 로직
  ENDMETHOD.
ENDCLASS.

*************** START-OF-SELECTION ****************
DATA:
  <go_rental>  TYPE REF TO <lcl_rental>,
  <go_partner> TYPE REF TO <if_partner>.

CREATE OBJECT <go_rental>.

*************** 인터페이스 업캐스트 ****************
<go_partner> = <go_rental>.        " Up-Cast (클래스 → 인터페이스)

*************** 호출 ****************
<go_partner>-><display_partner>( ).   " 인터페이스 기준 호출
" 또는
<go_rental>-><display_partner1>( ).   " ALIAS로 간단 호출
```
