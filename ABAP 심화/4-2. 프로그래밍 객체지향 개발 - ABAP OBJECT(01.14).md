## <  핵심 개념 >
- **1) `PUBLIC SECTION`**
- **2) `PRIVATE SECTION`**
</br>

- **`constructor` 는 `METHODS` 만 가능, `CLASS-METHODS` 에는 `class_constructor` 만 가능**
- **같은 클래스 안에서는 인스턴스/정적 메서드 모두 이름만으로 호출 가능**
</br>
</br>

---

</br>

## < ABAP 클래스 정의 기본 구조 >
</br>

### 1) Instance Constructor
- 객체가 생성될 때마다 자동으로 실행되는 초기화 메서드
- `constructor` 는 `METHODS` 만 가능, `CLASS-METHODS` 에는 `class_constructor` 만 가능
```abap
*************** 클래스 ****************
CLASS <class> DEFINITION.
  PUBLIC SECTION.
    METHODS constructor
      IMPORTING <p1> TYPE <type>.
  PRIVATE SECTION.
    DATA <a1> TYPE <type>.
ENDCLASS.

*************** 구현 ****************
CLASS <class> IMPLEMENTATION.
  METHOD constructor.
    <a1> = <p1>.
  ENDMETHOD.
ENDCLASS.

*************** 객체 생성 및 호출 ****************
DATA <obj> TYPE REF TO <class>.
CREATE OBJECT <obj> EXPORTING <p1> = <val>.
```
```abap
REPORT ZPROGB03_0036.

CLASS lcl_vehicle DEFINITION.
  PUBLIC SECTION.  " 외부에서 접근이 가능
   METHODS: constructor IMPORTING iv_make TYPE s_make
                                  iv_model TYPE s_model
                        EXCEPTIONS wrong_planetype.
ENDCLASS.

CLASS lcl_vehicle IMPLEMENTATION.
  METHOD constructor.
    mv_make = iv_make.
    mv_model = iv_model.

    gv_vehicles = gv_vehicles + 1.
  ENDMETHOD.
ENDCLASS.

START-OF-SELECTION.
 CREATE OBJECT go_vehicle EXPORTING iv_make = 'AUDI'
                                    iv_model = 'A3'
                          EXCEPTIONS wrong_planetype = 1.

 CREATE OBJECT go_vehicle EXPORTING iv_make = 'BMW'
                                    iv_model = '318I'
                          EXCEPTIONS wrong_planetype = 1.
```
</br>
</br>

### 2) Static Constructor
- `class_constructor` 는 클래스가 처음 접근될 때 1번 자동 실행됨
- 클래스 최초 접근 시 `class_constructor` 가 먼저 실행되고, 이후 객체 생성 시 `constructor` 가 실행됨
```abap
*************** 클래스 정의 ****************
CLASS <class> DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS class_constructor.
    METHODS constructor.
  PRIVATE SECTION.
    CLASS-DATA <static_attr> TYPE <type>.
ENDCLASS.

*************** 클래스 구현 ****************
CLASS <class> IMPLEMENTATION.
  METHOD class_constructor.
    " 클래스 최초 접근 시 1회 실행
  ENDMETHOD.

  METHOD constructor.
    " 객체 생성 시 실행
  ENDMETHOD.
ENDCLASS.

*************** 최초 접근 ****************
DATA <var> TYPE <type>.

<var> = <class>=><static_method>( ).
" → 처음이면 class_constructor 먼저 실행
```
</br>
</br>

### 3) Self-Reference
- `me->` 는 현재 생성된 인스턴스 객체 자신을 참조
- 인스턴스 메서드에서만 사용 가능
- 이름 충돌이 없으면 생략 가능하고, 충돌 시 반드시 사용
```abap
*************** 클래스 ****************
CLASS <class> DEFINITION.
  PRIVATE SECTION.
    DATA <attr> TYPE <type>.
ENDCLASS.

*************** 구현 ****************
CLASS <class> IMPLEMENTATION.
  METHOD <method>.
    <attr> = <value>.        " me-> 생략
    me-><attr> = <value>.    " 명시적 자기참조
  ENDMETHOD.
ENDCLASS.
```
</br>
</br>

### 4) 같은 클래스 내부에서 메서드 간 호출 방식
- 같은 클래스 안에서는 인스턴스/정적 메서드 모두 이름만으로 호출 가능
```abap
*************** 클래스 정의 ****************
CLASS <class> DEFINITION.
  PUBLIC SECTION.
    METHODS <inst_meth>.
    CLASS-METHODS <static_meth>.
ENDCLASS.

*************** 클래스 구현 ****************
CLASS <class> IMPLEMENTATION.

  METHOD <inst_meth>.
    <inst_meth2>( ).          " 같은 클래스 인스턴스 메서드 호출 (me-> 생략)
    <static_meth>( ).         " 같은 클래스 정적 메서드 호출 (클래스명 생략)
  ENDMETHOD.

  METHOD <inst_meth2>.
  ENDMETHOD.

  METHOD <static_meth>.
  ENDMETHOD.

ENDCLASS.
```
</br>
</br>

---

</br>

## < Inheritance (상속) >
</br>

### 1) 클래스 상속(Inheritance) 기본 구조
- `INHERITING FROM` 을 사용해 부모 클래스의 속성과 메서드를 물려받음
- 자식 클래스는 부모의 PUBLIC / PROTECTED 멤버 사용 가능
- PRIVATE 멤버는 상속되지 않음
```abap
*************** 부모 클래스 ****************
CLASS <parent_class> DEFINITION.
  PUBLIC SECTION.
    METHODS <parent_method>
      IMPORTING <p1> TYPE <type>.
  PRIVATE SECTION.
    DATA <parent_attr> TYPE <type>.
ENDCLASS.

*************** 자식 클래스 ****************
CLASS <child_class> DEFINITION
  INHERITING FROM <parent_class>.
  PUBLIC SECTION.
    METHODS <child_method>
      RETURNING VALUE(<rv>) TYPE <type>.
  PRIVATE SECTION.
    DATA <child_attr> TYPE <type>.
ENDCLASS.
```
```abap
REPORT ZPROGB03_0037.

CLASS lcl_grandparent DEFINITION.
  PUBLIC SECTION.
  DATA: mv_kimchi TYPE string.
  METHODS: constructor IMPORTING iv_kimchi TYPE string.
ENDCLASS.

CLASS lcl_grandparent IMPLEMENTATION.
  METHOD constructor.
    mv_kimchi = iv_kimchi.
    WRITE:/ '김치 투하: ', mv_kimchi.
   ENDMETHOD.
ENDCLASS.

**********************************************************************
CLASS lcl_parent DEFINITION INHERITING FROM lcl_grandparent.
  PUBLIC SECTION.
    DATA: mv_meat TYPE string.
    METHODS: constructor IMPORTING iv_kimchi TYPE string
                                   iv_meat TYPE string.
ENDCLASS.

CLASS lcl_parent IMPLEMENTATION.
  METHOD constructor.
    super->constructor( EXPORTING iv_kimchi = iv_kimchi ).
    mv_meat = iv_meat.
    WRITE:/ '엄마의 엄선된 고기 추가: ', mv_meat.
  ENDMETHOD.
ENDCLASS.

**********************************************************************
CLASS lcl_child DEFINITION INHERITING FROM lcl_parent.
  PUBLIC SECTION.
    DATA: mv_topping TYPE string.
    METHODS: constructor IMPORTING iv_kimchi TYPE string
                                   iv_meat TYPE string
                                   iv_topping TYPE string.
ENDCLASS.

CLASS lcl_child IMPLEMENTATION.
  METHOD constructor.
    super->constructor(
      iv_kimchi = iv_kimchi
      iv_meat = iv_meat
    ).
    mv_topping = iv_topping.
    WRITE:/ '나만의 토핑으로 마무리: ', mv_topping.
  ENDMETHOD.
ENDCLASS.

**********************************************************************
START-OF-SELECTION.
  DATA: go_child TYPE REF TO lcl_child.

  CREATE OBJECT go_child
    EXPORTING iv_kimchi = '묵은지'
              iv_meat = '흑돼지'
              iv_topping = '치즈 듬뿍'.
```
</br>
</br>

### 2) 메서드 재정의(Redefinition)
- 자식 클래스에서 부모 클래스의 메서드를 다시 구현하는 것을 재정의라 함
- `REDEFINITION` 키워드를 사용하며 메서드 시그니처는 동일해야 함
- `super->` 로 부모 메서드를 호출할 수 있음
```abap
*************** 자식 클래스 ****************
CLASS <child_class> DEFINITION
  INHERITING FROM <parent_class>.
  PUBLIC SECTION.
    METHODS <method> REDEFINITION.
ENDCLASS.

*************** 자식 클래스 구현 ****************
CLASS <child_class> IMPLEMENTATION.
  METHOD <method>.
    super-><method>( ).   " 부모 메서드 호출
    " 자식 클래스용 로직
  ENDMETHOD.
ENDCLASS.
```
</br>
</br>

### 3) 서브클래스 생성자 정의(Constructor in Subclass)
- 자식 클래스도 자신만의 constructor 정의 가능
- 자식 생성자에서 `super->constructor` 로 부모 생성자 호출
- 생성자는 시그니처 변경 가능 (일반 메서드와 다름)
```abap
*************** 부모 클래스 ****************
CLASS <parent_class> DEFINITION.
  PUBLIC SECTION.
    METHODS constructor
      IMPORTING <p_parent> TYPE <type>.
ENDCLASS.

CLASS <parent_class> IMPLEMENTATION.
  METHOD constructor.
    <parent_attr> = <p_parent>.
  ENDMETHOD.
ENDCLASS.

*************** 자식 클래스 ****************
CLASS <child_class> DEFINITION
  INHERITING FROM <parent_class>.
  PUBLIC SECTION.
    METHODS constructor
      IMPORTING
        <p_child1> TYPE <type>
        <p_child2> TYPE <type>.
  PRIVATE SECTION.
    DATA <child_attr> TYPE <type>.
ENDCLASS.

*************** 자식 클래스 구현 ****************
CLASS <child_class> IMPLEMENTATION.
  METHOD constructor.
    super->constructor( <p_parent> = <p_child1> ).
    <child_attr> = <p_child2>.
  ENDMETHOD.
ENDCLASS.
```
</br>
</br>

### 4) 상속과 접근제어(Visibility)
- `PUBLIC` : 어디서든 접근 가능
- `PROTECTED` : 해당 클래스 + 모든 자식 클래스에서 접근 가능
- `PRIVATE` : 해당 클래스 내부에서만 접근 가능
```abap
*************** 클래스 정의 ****************
CLASS <class> DEFINITION.
  PUBLIC SECTION.
    METHODS <public_method>.

  PROTECTED SECTION.
    CONSTANTS <protected_const> TYPE <type> VALUE <val>.

  PRIVATE SECTION.
    DATA <private_attr> TYPE <type>.
ENDCLASS.
```
</br>
</br>

---

</br>

## < 실습 코드 >
</br>

### 실습 1
- Constructor 실습
```abap
REPORT ZBC401_03_MAIN.

*************** 클래스 정의 ****************
CLASS lcl_airplane DEFINITION.
  PUBLIC SECTION.
    METHODS: display_attributes,
             constructor IMPORTING iv_name TYPE string
                                   iv_planetype TYPE saplane-planetype
                         EXCEPTIONS wrong_planetype.
    CLASS-METHODS: display_gv_n_o_airplanes,
                   get_n_o_airpalnes RETURNING VALUE(rv_result) TYPE I.
  PRIVATE SECTION.
    CONSTANTS: c_pos_l TYPE I VALUE 30.
    DATA: mv_name TYPE string,
          mv_planetype TYPE saplane-planetype.
    DATA: mv_weight TYPE saplane-weight,
          mv_tankcap TYPE saplane-tankcap.
    CLASS-DATA: gv_n_o_airplanes TYPE I.
ENDCLASS.

*************** 클래스 구현 ****************
CLASS lcl_airplane IMPLEMENTATION.

*************** 생성자 ****************
  METHOD constructor.
    DATA: gs_data TYPE saplane.

    mv_name = iv_name.
    mv_planetype = iv_planetype.

    SELECT SINGLE * FROM saplane
      INTO gs_data
      WHERE planetype = mv_planetype.
    IF sy-subrc <> 0.
      RAISE wrong_planetype.
    ELSE.
      mv_weight = gs_data-weight.
      mv_tankcap = gs_data-tankcap.
      gv_n_o_airplanes = gv_n_o_airplanes + 1.
    ENDIF.
  ENDMETHOD.

  METHOD display_attributes.
    WRITE:/ icon_ws_plane AS ICON,
          / 'Name: ', AT c_pos_l mv_name,
          / 'Planetype: ', AT c_pos_l mv_planetype,
          / 'Weight: ', AT c_pos_l mv_weight,
          / 'Tankcap', AT c_pos_l mv_tankcap.
  ENDMETHOD.

  METHOD display_gv_n_o_airplanes.
    WRITE:/ 'Number of airplane: ', gv_n_o_airplanes.
  ENDMETHOD.

  METHOD get_n_o_airpalnes.
    rv_result = gv_n_o_airplanes.
  ENDMETHOD.
ENDCLASS.

*************** 실행부 ****************
START-OF-SELECTION.
  DATA: go_airplane TYPE REF TO lcl_airplane,
        gt_airplane TYPE TABLE OF REF TO lcl_airplane,
        gv_cnt TYPE I.

  lcl_airplane=>display_gv_n_o_airplanes( ).
  CREATE OBJECT go_airplane EXPORTING iv_name = '이름1'
                                      iv_planetype = '747-00'
                            EXCEPTIONS wrong_planetype = 1.
  IF sy-subrc = 0.
    APPEND go_airplane TO gt_airplane.
  ENDIF.

  CREATE OBJECT go_airplane EXPORTING iv_name = '이름2'
                                      iv_planetype = '146-200'
                            EXCEPTIONS wrong_planetype = 1.
  IF sy-subrc = 0.
    APPEND go_airplane TO gt_airplane.
  ENDIF.

  CREATE OBJECT go_airplane EXPORTING iv_name = '이름3'
                                      iv_planetype = '777-300'
                            EXCEPTIONS wrong_planetype = 1.
  IF sy-subrc = 0.
    APPEND go_airplane TO gt_airplane.
  ENDIF.

  gt_airplane[ 1 ]->display_gv_n_o_airplanes( ).

  LOOP AT gt_airplane INTO go_airplane.
    go_airplane->display_attributes( ).
  ENDLOOP.
  lcl_airplane=>get_n_o_airpalnes( RECEIVING rv_result = gv_cnt ).
  WRITE:/ 'Number of airplane: ', gv_cnt.
```
</br>

- 결과 확인
<img width="339" height="262" alt="image" src="https://github.com/user-attachments/assets/8bceb2db-a542-446b-9e81-823f5b7ecf35" />
</br>
</br>
</br>

### 실습 2
- 실습 1에 이어서 진행
- Class constructor 실습
```abap
REPORT ZBC401_03_MAIN.

*************** 클래스 정의 ****************
CLASS lcl_airplane DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: class_constructor.
  PRIVATE SECTION.
    TYPES: TY_PLANETYPES TYPE STANDARD TABLE OF saplane
      WITH NON-UNIQUE KEY planetype.
    CLASS-DATA: GT_PLANETYPES TYPE TY_PLANETYPES.
    CLASS-METHODS: get_technical_attributes
                      IMPORTING iv_planetype TYPE saplane-planetype
                      EXPORTING iv_weight TYPE saplane-weight
                                iv_tankcap TYPE saplane-tankcap
                      EXCEPTIONS wrong_planetype.
ENDCLASS.

*************** 클래스 구현 ****************
CLASS lcl_airplane IMPLEMENTATION.

*************** 정적 생성자 ****************
  METHOD class_constructor.
    SELECT * FROM saplane
      INTO TABLE GT_PLANETYPES.
  ENDMETHOD.

  METHOD constructor.
    DATA: gs_data TYPE saplane.

    mv_name = iv_name.
    mv_planetype = iv_planetype.

    get_technical_attributes(
      EXPORTING iv_planetype = mv_planetype
      IMPORTING iv_weight = mv_weight
                iv_tankcap = mv_tankcap
      EXCEPTIONS wrong_planetype = 1
    ).
    IF sy-subrc <> 0.
      RAISE wrong_planetype.
    ELSE.
      gv_n_o_airplanes = gv_n_o_airplanes + 1.
    ENDIF.
  ENDMETHOD.

*************** 정적 메서드 (기술 속성 조회) ****************
  METHOD get_technical_attributes.
    DATA: gs_data TYPE saplane.
    READ TABLE gt_planetypes INTO gs_data
      WITH TABLE KEY planetype = iv_planetype
      TRANSPORTING weight tankcap.
    IF sy-subrc = 0.
      iv_weight = gs_data-weight.
      iv_tankcap = gs_data-tankcap.
    ELSE.
      RAISE wrong_planetype.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

*************** 실행부 ****************
START-OF-SELECTION.
  DATA: go_airplane TYPE REF TO lcl_airplane,
        gt_airplane TYPE TABLE OF REF TO lcl_airplane,
        gv_cnt TYPE I.

  lcl_airplane=>display_gv_n_o_airplanes( ).
  CREATE OBJECT go_airplane EXPORTING iv_name = '이름1'
                                      iv_planetype = '747-00'
                            EXCEPTIONS wrong_planetype = 1.
  IF sy-subrc = 0.
    APPEND go_airplane TO gt_airplane.
  ENDIF.

  CREATE OBJECT go_airplane EXPORTING iv_name = '이름2'
                                      iv_planetype = '146-200'
                            EXCEPTIONS wrong_planetype = 1.
  IF sy-subrc = 0.
    APPEND go_airplane TO gt_airplane.
  ENDIF.

  CREATE OBJECT go_airplane EXPORTING iv_name = '이름3'
                                      iv_planetype = '777-300'
                            EXCEPTIONS wrong_planetype = 1.
  IF sy-subrc = 0.
    APPEND go_airplane TO gt_airplane.
  ENDIF.

  gt_airplane[ 1 ]->display_gv_n_o_airplanes( ).

  LOOP AT gt_airplane INTO go_airplane.
    go_airplane->display_attributes( ).
  ENDLOOP.
  lcl_airplane=>get_n_o_airpalnes( RECEIVING rv_result = gv_cnt ).
  WRITE:/ 'Number of airplane: ', gv_cnt.
```
</br>

- 결과 확인
<img width="339" height="262" alt="image" src="https://github.com/user-attachments/assets/8bceb2db-a542-446b-9e81-823f5b7ecf35" />
</br>
</br>
</br>
