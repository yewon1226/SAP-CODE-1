## <  핵심 개념 >
</br>

- **1) BDC (Batch Data Creation)**
- **2) SAP Job(백그라운드 잡) - SM36, SM37**
</br>

- **C01에서 더블클릭 이벤트 발생해도 자동으로 PAI/PBO 안 탐**
- **더블클릭 이후 로직은 기본적으로 C01에서만 처리**
</br>
</br>

---

</br>

## < SAP 자동 실행 처리 기법 >
</br>

### 1) BDC (Batch Data Creation)
- 실제 트랜잭션 화면 입력 과정을 BDCDATA에 기록해 프로그램으로 자동 실행하는 방식
</br>

**< CALL TRANSACTION - MODE 옵션 >**

| MODE | 설명 |
|------|------|
| A | 모든 화면 표시 / 진행 중 수정 가능 |
| E | 정상 흐름은 숨기고 오류 화면만 표시 |
| N | 화면 없이 백그라운드 처리 (사용자는 못 봄) |
| P | 오류 발생 시 화면 일시정지 |

**< CALL TRANSACTION - UPDATE 옵션 >**

| UPDATE | 설명 |
|--------|------|
| S | 동기 처리 (작업 완료 후 프로그램 복귀) |
| A | 비동기 처리 (즉시 복귀, 작업은 백그라운드 진행) |

</br>

```abap
*************** BDC Dynpro 시작 ****************
PERFORM set_bdcdata USING 'X' <PROGRAM> <SCREEN>.
* <PROGRAM> : Dynpro 프로그램명
* <SCREEN>  : Dynpro 번호


*************** BDC 화면 필드 입력 ****************
PERFORM set_bdcdata USING ' ' <FIELDNAME> <VALUE>.
* <FIELDNAME> : 화면 필드명 (예: BDC_OKCODE, PA_CAR2)
* <VALUE>     : 입력값


*************** BDC DATA 공통 FORM ****************
FORM set_bdcdata USING pv_dynbegin   " Dynpro 시작 여부 ('X' / ' ')
                       pv_fname      " 프로그램명 or 필드명
                       pv_fval.      " 화면번호 or 입력값

  CLEAR gs_bdcdata.
  IF pv_dynbegin EQ abap_true.        " Dynpro 시작
    gs_bdcdata-dynbegin = abap_true.
    gs_bdcdata-program  = pv_fname.
    gs_bdcdata-dynpro   = pv_fval.
  ELSE.                              " 화면 필드 입력
    gs_bdcdata-fnam = pv_fname.
    gs_bdcdata-fval = pv_fval.
  ENDIF.
  APPEND gs_bdcdata TO gt_bdcdata.    " BDCDATA 한 줄 적재
ENDFORM.
```
```abap
REPORT ZPROGB03_CALL.

*************** BDC DATA 선언부 ****************
DATA: gs_bdcdata      TYPE bdcdata,             " BDCDATA 단건 구조
      gt_bdcdata      TYPE STANDARD TABLE OF bdcdata,
      lt_bdc_message  TYPE STANDARD TABLE OF bdcmsgcoll.


*************** BDC DATA 적재 (CALL 쪽) ****************
PERFORM set_bdcdata USING:
* STARTID   PROGRAM / FIELDNAME    SCREEN / VALUE
  'X'       'ZPROGB03_CALLED'      '1000',      " Dynpro 시작
  ' '       'BDC_CURSOR'           'SO_CON2-HIGH',
  ' '       'BDC_OKCODE'           '=ONLI',
  ' '       'PA_CAR2'              'AA',
  ' '       'SO_CON2-LOW'          '17',
  ' '       'SO_CON2-HIGH'         '64',
  'X'       'SAPMSSY0'              '0120',     " 팝업 Dynpro
  ' '       'BDC_OKCODE'           '=BACK',
  'X'       'ZPROGB03_CALLED'      '1000',      " 원화면
  ' '       'BDC_OKCODE'           '/EE',
  ' '       'BDC_CURSOR'           'PA_CAR2'.

*************** BDC CALL TRANSACTION ****************
CALL TRANSACTION 'ZTCODEB03_CALLED'
  USING gt_bdcdata
  MODE 'A'
  UPDATE 'S'
  MESSAGES INTO lt_bdc_message.

*************** BDC DATA 함수 ****************
FORM set_bdcdata  USING    pv_dynbegin
                           pv_fname
                           pv_fval.
  CLEAR gs_bdcdata.
  IF pv_dynbegin EQ abap_true. " pv_dynbegin = 'X'
    gs_bdcdata-dynbegin = abap_true.
    gs_bdcdata-program = pv_fname.
    gs_bdcdata-dynpro = pv_fval.
  ELSE.
    gs_bdcdata-fnam = pv_fname.
    gs_bdcdata-fval = pv_fval.
  ENDIF.
  APPEND gs_bdcdata TO gt_bdcdata.
ENDFORM.
```
</br>

- system -> services -> batch input -> recorder 클릭
<img width="498" height="258" alt="image" src="https://github.com/user-attachments/assets/70fb2045-a16b-4189-a43b-6dc7289f1fb0" />
</br>
</br>

- new recording 누르고 start recording 클릭
<img width="441" height="413" alt="image" src="https://github.com/user-attachments/assets/2f12a82d-cd6e-4f78-804f-6c51306bbd57" />
</br>
</br>

- 녹화 후 Process 클릭하여 실행
<img width="471" height="379" alt="image" src="https://github.com/user-attachments/assets/25131805-f01f-4c9f-a0d4-f34736a3188c" />
</br>
</br>

- 만든 레코드 확인 가능
<img width="501" height="150" alt="image" src="https://github.com/user-attachments/assets/b56b127f-f634-4c8b-833d-1325e1f61d4d" />
</br>
</br>
</br>
</br>
</br>

### 2) SAP Job(백그라운드 잡) - SM36, SM37
- Job = 사람이 안 눌러도 정해진 조건/시간에 ABAP 프로그램을 자동 실행하는 작업
- **SM36** → 잡(Job) 생성
- **SM37** → 생성된 잡(Job) 조회 / 상태 확인
</br>

- 백그라운드 잡에서는 ALV 사용 불가 (화면 인스턴스 생성 불가)
- 시스템 변수 `sy-batch = 'X'` → 현재 백그라운드 실행 중
- 이 경우 ALV 대신 WRITE, 스풀, 파일 출력 등으로 처리
```abap
REPORT ZPROGB03_0032.

DATA: gt_data TYPE TABLE OF ZDBWORK_B03,
      gs_data LIKE LINE OF gt_data.

SELECT * FROM ZDBWORK_B03
  INTO TABLE gt_data
  ORDER BY WORKNO DESCENDING." 내림차순

CHECK sy-subrc = 0.

READ TABLE gt_DATA INTO GS_DATA INDEX 1.
ADD 1 TO gs_data-workno.

*********** 처음 넣은 데이터 ***********
gs_data-workno = 1.
gs_data-workdesc = 'hello work~~'.
gs_data-ernam = sy-uname. " 유저이름
gs_data-erdat = sy-datum. " 현재 일자
gs_data-erzet = sy-uzeit. " 현재 시간
***************************************

gs_data-workdesc = 'hello work~~'.
gs_data-ernam = sy-uname. " 유저이름
gs_data-erdat = sy-datum. " 현재 일자
gs_data-erzet = sy-uzeit. " 현재 시간

INSERT ZDBWORK_B02 FROM gs_data.
IF sy-subrc = 0.
  SELECT * FROM ZDBWORK_B03
    INTO TABLE gt_data
    ORDER BY workno DESCENDING.
  cl_demo_output=>display( gt_data ).
ENDIF.
```
</br>

- `SM36` 로 JOB 생성하기
- 프로그램 이름 지정
<img width="448" height="279" alt="image" src="https://github.com/user-attachments/assets/b2b681d2-7fc4-4bf3-bc4f-9779b6f4eea4" />
</br>
</br>

- JOB 시작 조건을 주기적 실행으로 설정해 20분마다 백그라운드 JOB을 자동 실행하도록 설정
<img width="459" height="369" alt="image" src="https://github.com/user-attachments/assets/da67cc6f-53a4-4032-9a56-7644a4695deb" />
</br>
</br>

- `SM37` 에서 생성된 JOB 확인 가능
<img width="458" height="328" alt="image" src="https://github.com/user-attachments/assets/81eb3a77-eb99-4185-aabb-f116a08e790b" />
</br>
</br>
</br>
</br>

---

</br>

## < ABAP Open SQL 핵심 문법 정리 >
</br>

### 1) CLIENT(MANDT) 지정 방식 – 구문법 vs 신문법
- Open SQL에서 특정 클라이언트(MANDT)의 데이터를 직접 지정해 조회
```abap
*************** Open SQL CLIENT 지정 – 구문법 (형식) ****************
SELECT <FIELDS>
  INTO TABLE <ITAB>
  FROM <DB_TABLE>
  CLIENT SPECIFIED
  WHERE mandt = <CLIENT>.


*************** Open SQL CLIENT 지정 – 신문법 (형식) ****************
SELECT <FIELDS>
  INTO TABLE @<ITAB>
  FROM <DB_TABLE>
  USING CLIENT <CLIENT>.
```
```abap
*************** Open SQL – CLIENT 지정 (구문법) ****************
SELECT * INTO TABLE gt_scarr
  FROM scarr
  CLIENT SPECIFIED
  WHERE mandt = '100'.   
* WHERE MANDT BETWEEN '000' AND '900'.

*************** Open SQL – CLIENT 지정 (신문법) ****************
SELECT * INTO TABLE @gt_scarr
  FROM scarr
  USING CLIENT '000'.    
```
</br>
</br>

### 2) Open SQL INSERT 구문
- 워크에어리어로 단건, 내부테이블로 여러 건 데이터를 DB에 저장
- `ACCEPTING DUPLICATE KEYS` 를 사용하면 중복 키는 건너뛰고 나머지 데이터만 INSERT됨
- 중복 키 상태에서 INSERT를 실행하면 → 덤프 발생
```abap
*************** 단건 INSERT ****************
INSERT INTO <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  VALUES <WORK_AREA>.        " 워크에어리어 1건 INSERT

INSERT <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  FROM <WORK_AREA>.          " VALUES와 동일 의미

*************** 다중 INSERT ****************
INSERT <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  FROM TABLE <ITAB>
  [ACCEPTING DUPLICATE KEYS]. " 내부테이블 여러 건 INSERT
```
```abap
REPORT ZPROGB03_0033.

DATA: gt_scustom TYPE TABLE OF ZTSCUSTOM_B03,
      gs_scustom TYPE ZTSCUSTOM_B03.
* DELETE FROM ZTSCUSTOM_B03. => ACCEPTING DUPLICATE KEYS 안하면 써야함

*************** 단건 INSERT ****************
SELECT SINGLE *
  FROM SCUSTOM
  INTO gs_scustom
  WHERE ID = 1.

INSERT INTO ZTSCUSTOM_B03 VALUES gs_scustom.
INSERT ZTSCUSTOM_B03 FROM gs_scustom.

*************** 다중 INSERT ****************
SELECT * FROM scustom
  INTO TABLE gt_scustom
  WHERE ID BETWEEN 1 AND 50.

INSERT ZTSCUSTOM_B03 FROM TABLE gt_scustom
  ACCEPTING DUPLICATE KEYS.
```
