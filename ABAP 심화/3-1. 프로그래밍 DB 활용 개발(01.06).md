## <  핵심 개념 >
</br>

- **1) BDC (Batch Data Creation)**
- **2) SAP Job(백그라운드 잡) - SM36, SM37**
- **3) CLIENT(MANDT) 지정 방식 – 구문법 vs 신문법**
- **4)  Open SQL INSERT 구문**
- **5) Open SQL UPDATE 구문**
</br>

- **`UPDATE` 는 기존 레코드만 수정하고, `MODIFY` 는 있으면 수정·없으면 INSERT까지 수행**
</br>
</br>

---

</br>

## < SAP 자동 실행 처리 기법 >
</br>

### 1) BDC (Batch Data Creation)
- 실제 트랜잭션 화면 입력 과정을 BDCDATA에 기록해 프로그램으로 자동 실행하는 방식
</br>

**< CALL TRANSACTION - MODE 옵션 >**

| MODE | 설명 |
|------|------|
| A | 모든 화면 표시 / 진행 중 수정 가능 |
| E | 정상 흐름은 숨기고 오류 화면만 표시 |
| N | 화면 없이 백그라운드 처리 (사용자는 못 봄) |
| P | 오류 발생 시 화면 일시정지 |

**< CALL TRANSACTION - UPDATE 옵션 >**

| UPDATE | 설명 |
|--------|------|
| S | 동기 처리 (작업 완료 후 프로그램 복귀) |
| A | 비동기 처리 (즉시 복귀, 작업은 백그라운드 진행) |

</br>

```abap
*************** BDC Dynpro 시작 ****************
PERFORM set_bdcdata USING 'X' <PROGRAM> <SCREEN>.
* <PROGRAM> : Dynpro 프로그램명
* <SCREEN>  : Dynpro 번호


*************** BDC 화면 필드 입력 ****************
PERFORM set_bdcdata USING ' ' <FIELDNAME> <VALUE>.
* <FIELDNAME> : 화면 필드명 (예: BDC_OKCODE, PA_CAR2)
* <VALUE>     : 입력값


*************** BDC DATA 공통 FORM ****************
FORM set_bdcdata USING pv_dynbegin   " Dynpro 시작 여부 ('X' / ' ')
                       pv_fname      " 프로그램명 or 필드명
                       pv_fval.      " 화면번호 or 입력값

  CLEAR gs_bdcdata.
  IF pv_dynbegin EQ abap_true.        " Dynpro 시작
    gs_bdcdata-dynbegin = abap_true.
    gs_bdcdata-program  = pv_fname.
    gs_bdcdata-dynpro   = pv_fval.
  ELSE.                              " 화면 필드 입력
    gs_bdcdata-fnam = pv_fname.
    gs_bdcdata-fval = pv_fval.
  ENDIF.
  APPEND gs_bdcdata TO gt_bdcdata.    " BDCDATA 한 줄 적재
ENDFORM.
```
```abap
REPORT ZPROGB03_CALL.

*************** BDC DATA 선언부 ****************
DATA: gs_bdcdata      TYPE bdcdata,             " BDCDATA 단건 구조
      gt_bdcdata      TYPE STANDARD TABLE OF bdcdata,
      lt_bdc_message  TYPE STANDARD TABLE OF bdcmsgcoll.


*************** BDC DATA 적재 (CALL 쪽) ****************
PERFORM set_bdcdata USING:
* STARTID   PROGRAM / FIELDNAME    SCREEN / VALUE
  'X'       'ZPROGB03_CALLED'      '1000',      " Dynpro 시작
  ' '       'BDC_CURSOR'           'SO_CON2-HIGH',
  ' '       'BDC_OKCODE'           '=ONLI',
  ' '       'PA_CAR2'              'AA',
  ' '       'SO_CON2-LOW'          '17',
  ' '       'SO_CON2-HIGH'         '64',
  'X'       'SAPMSSY0'              '0120',     " 팝업 Dynpro
  ' '       'BDC_OKCODE'           '=BACK',
  'X'       'ZPROGB03_CALLED'      '1000',      " 원화면
  ' '       'BDC_OKCODE'           '/EE',
  ' '       'BDC_CURSOR'           'PA_CAR2'.

*************** BDC CALL TRANSACTION ****************
CALL TRANSACTION 'ZTCODEB03_CALLED'
  USING gt_bdcdata
  MODE 'A'
  UPDATE 'S'
  MESSAGES INTO lt_bdc_message.

*************** BDC DATA 함수 ****************
FORM set_bdcdata  USING    pv_dynbegin
                           pv_fname
                           pv_fval.
  CLEAR gs_bdcdata.
  IF pv_dynbegin EQ abap_true. " pv_dynbegin = 'X'
    gs_bdcdata-dynbegin = abap_true.
    gs_bdcdata-program = pv_fname.
    gs_bdcdata-dynpro = pv_fval.
  ELSE.
    gs_bdcdata-fnam = pv_fname.
    gs_bdcdata-fval = pv_fval.
  ENDIF.
  APPEND gs_bdcdata TO gt_bdcdata.
ENDFORM.
```
</br>

- system -> services -> batch input -> recorder 클릭
<img width="498" height="258" alt="image" src="https://github.com/user-attachments/assets/70fb2045-a16b-4189-a43b-6dc7289f1fb0" />
</br>
</br>

- new recording 누르고 start recording 클릭
<img width="441" height="413" alt="image" src="https://github.com/user-attachments/assets/2f12a82d-cd6e-4f78-804f-6c51306bbd57" />
</br>
</br>

- 녹화 후 Process 클릭하여 실행
<img width="471" height="379" alt="image" src="https://github.com/user-attachments/assets/25131805-f01f-4c9f-a0d4-f34736a3188c" />
</br>
</br>

- 만든 레코드 확인 가능
<img width="501" height="150" alt="image" src="https://github.com/user-attachments/assets/b56b127f-f634-4c8b-833d-1325e1f61d4d" />
</br>
</br>
</br>
</br>
</br>

### 2) SAP Job(백그라운드 잡) - SM36, SM37
- Job = 사람이 안 눌러도 정해진 조건/시간에 ABAP 프로그램을 자동 실행하는 작업
- **SM36** → 잡(Job) 생성
- **SM37** → 생성된 잡(Job) 조회 / 상태 확인
</br>

- 백그라운드 잡에서는 ALV 사용 불가 (화면 인스턴스 생성 불가)
- 시스템 변수 `sy-batch = 'X'` → 현재 백그라운드 실행 중
- 이 경우 ALV 대신 WRITE, 스풀, 파일 출력 등으로 처리
```abap
REPORT ZPROGB03_0032.

DATA: gt_data TYPE TABLE OF ZDBWORK_B03,
      gs_data LIKE LINE OF gt_data.

SELECT * FROM ZDBWORK_B03
  INTO TABLE gt_data
  ORDER BY WORKNO DESCENDING." 내림차순

CHECK sy-subrc = 0.

READ TABLE gt_DATA INTO GS_DATA INDEX 1.
ADD 1 TO gs_data-workno.

*********** 처음 넣은 데이터 ***********
gs_data-workno = 1.
gs_data-workdesc = 'hello work~~'.
gs_data-ernam = sy-uname. " 유저이름
gs_data-erdat = sy-datum. " 현재 일자
gs_data-erzet = sy-uzeit. " 현재 시간
***************************************

gs_data-workdesc = 'hello work~~'.
gs_data-ernam = sy-uname. " 유저이름
gs_data-erdat = sy-datum. " 현재 일자
gs_data-erzet = sy-uzeit. " 현재 시간

INSERT ZDBWORK_B02 FROM gs_data.
IF sy-subrc = 0.
  SELECT * FROM ZDBWORK_B03
    INTO TABLE gt_data
    ORDER BY workno DESCENDING.
  cl_demo_output=>display( gt_data ).
ENDIF.
```
</br>

- `SM36` 로 JOB 생성하기
- 프로그램 이름 지정
<img width="448" height="279" alt="image" src="https://github.com/user-attachments/assets/b2b681d2-7fc4-4bf3-bc4f-9779b6f4eea4" />
</br>
</br>

- JOB 시작 조건을 주기적 실행으로 설정해 20분마다 백그라운드 JOB을 자동 실행하도록 설정
<img width="459" height="369" alt="image" src="https://github.com/user-attachments/assets/da67cc6f-53a4-4032-9a56-7644a4695deb" />
</br>
</br>

- `SM37` 에서 생성된 JOB 확인 가능
<img width="458" height="328" alt="image" src="https://github.com/user-attachments/assets/81eb3a77-eb99-4185-aabb-f116a08e790b" />
</br>
</br>
</br>
</br>

---

</br>

## < ABAP Open SQL 핵심 문법 정리 >
</br>

### 1) CLIENT(MANDT) 지정 방식 – 구문법 vs 신문법
- Open SQL에서 특정 클라이언트(MANDT)의 데이터를 직접 지정해 조회
```abap
*************** Open SQL CLIENT 지정 – 구문법 (형식) ****************
SELECT <FIELDS>
  INTO TABLE <ITAB>
  FROM <DB_TABLE>
  CLIENT SPECIFIED
  WHERE mandt = <CLIENT>.


*************** Open SQL CLIENT 지정 – 신문법 (형식) ****************
SELECT <FIELDS>
  INTO TABLE @<ITAB>
  FROM <DB_TABLE>
  USING CLIENT <CLIENT>.
```
```abap
*************** Open SQL – CLIENT 지정 (구문법) ****************
SELECT * INTO TABLE gt_scarr
  FROM scarr
  CLIENT SPECIFIED
  WHERE mandt = '100'.   
* WHERE MANDT BETWEEN '000' AND '900'.

*************** Open SQL – CLIENT 지정 (신문법) ****************
SELECT * INTO TABLE @gt_scarr
  FROM scarr
  USING CLIENT '000'.    
```
</br>
</br>

### 2) Open SQL INSERT 구문
- 워크에어리어로 단건, 내부테이블로 여러 건 데이터를 DB에 저장
- `ACCEPTING DUPLICATE KEYS` 를 사용하면 중복 키는 건너뛰고 나머지 데이터만 INSERT됨
- 중복 키 상태에서 INSERT를 실행하면 → 덤프 발생
- **`sy-dbcnt`** 로 실제 INSERT된 결과를 확인
```abap
*************** 단건 INSERT ****************
INSERT INTO <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  VALUES <WORK_AREA>.        " 워크에어리어 1건 INSERT

INSERT <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  FROM <WORK_AREA>.          " VALUES와 동일 의미

*************** 다중 INSERT ****************
INSERT <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  FROM TABLE <ITAB>
  [ACCEPTING DUPLICATE KEYS]. " 내부테이블 여러 건 INSERT
```
```abap
DATA: gt_scustom TYPE TABLE OF ZTSCUSTOM_B03,
      gs_scustom TYPE ZTSCUSTOM_B03.
* DELETE FROM ZTSCUSTOM_B03. => ACCEPTING DUPLICATE KEYS 안하면 써야함

*************** 단건 INSERT (Work Area) ****************
SELECT SINGLE *
  FROM SCUSTOM
  INTO gs_scustom
  WHERE ID = 1.

INSERT INTO ZTSCUSTOM_B03 VALUES gs_scustom.
INSERT ZTSCUSTOM_B03 FROM gs_scustom.

*************** 다중 INSERT (Internal Table) ****************
SELECT * FROM scustom
  INTO TABLE gt_scustom
  WHERE ID BETWEEN 1 AND 50.

INSERT ZTSCUSTOM_B03 FROM TABLE gt_scustom
  ACCEPTING DUPLICATE KEYS.
```
</br>
</br>

### 3) Open SQL UPDATE 구문
- 기존 DB 레코드를 PK 기준으로 1건 수정하거나, 조건(WHERE)에 맞는 여러 건을 한 번에 수정할 수 있음
- 수정된 레코드 수는 **`sy-dbcnt`** 로 확인 가능 (0이면 대상 없음)
- UPDATE는 기존 레코드만 수정하고, MODIFY는 있으면 수정·없으면 INSERT까지 수행
```abap
*************** 단건 UPDATE (Work Area) ****************
UPDATE <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  FROM <WORK_AREA>.          " PK 기준 1건 수정

*************** 단건 / 다중 UPDATE (SET / WHERE) ****************
UPDATE <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  SET <FIELD1> = <VALUE1>,
      <FIELD2> = <VALUE2>
  WHERE <FULL_QUALIFIED_KEY>. " 조건에 맞는 필드만 단건/다중 수정

*************** 다중 UPDATE (Internal Table 방식) ****************
UPDATE <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  FROM TABLE <ITAB>.          " 내부테이블 기준 여러 건 수정
```
```abap
*************** 단건 UPDATE (Work Area) ****************
gs_scustom-id = 1.
gs_scustom-name = 'change name'.
UPDATE ZTSCUSTOM_B03 FROM gs_scustom.

*************** 단건 / 다중 UPDATE (SET / WHERE) ****************
gs_scustom-id = 2.
gs_scustom-name = 'second change'.      " 단건 변경
UPDATE ZTSCUSTOM_B03
   SET name = gs_scustom-name
       street = 'hihi'
   WHERE ID = gs_scustom-id.

UPDATE ZTSCUSTOM_B03
  SET form = 'My form'                  " 여러건 변경
      city = 'Walldorf'
      country = 'DE'
  WHERE id BETWEEN 10 AND 20.

*************** 다중 UPDATE (Internal Table 방식) ****************
SELECT * FROM scustom
  INTO TABLE gt_scustom
  WHERE id BETWEEN 10 AND 20.

LOOP AT gt_scustom INTO gs_scustom.
  gs_scustom-form = 'My form'.
  gs_scustom-city = 'Walldorf'.
  gs_scustom-country = 'DE'.
  MODIFY gt_scustom FROM gs_scustom.
ENDLOOP.
UPDATE ZTSCUSTOM_B03 FROM TABLE gt_scustom.
```
</br>
</br>

### 4) Open SQL MODIFY 구문
- PK 기준으로 데이터가 있으면 UPDATE, 없으면 INSERT 수행
- **`sy-dbcnt`** 로 실제 반영된 수정 결과를 확인
- `APPENDING TABLE` : 기존 내부테이블을 비우지 않고 SELECT 결과를 뒤에 계속 추가하는 방식
```abap
*************** 단건 MODIFY (Work Area) ****************
MODIFY <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  FROM <WORK_AREA>.          " 있으면 UPDATE, 없으면 INSERT

*************** 다중 MODIFY (Internal Table 방식) ****************
MODIFY <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  FROM TABLE <ITAB>.          " 여러 건 UPSERT 처리
```
```abap
*************** 단건 MODIFY (Work Area) ****************
gs_scustom-id = 500.
gs_scustom-form = '변경~~'.
gs_scustom-name = 'MODIFY 변경~~'.
MODIFY ZTSCUSTOM_B03 FROM gs_scustom.

*************** 다중 MODIFY (Internal Table 방식) ****************
gs_scustom-name = 'modify name'.
MODIFY gt_scustom FROM gs_scustom
TRANSPORTING name WHERE id <> space.

SELECT *
  APPENDING TABLE gt_scustom
  FROM scustom
  WHERE ID IN ( 193, 195, 197 ).
" 완성된 itab을 db tab에 modify
MODIFY ZTSCUSTOM_B03 FROM TABLE gt_scustom.
```
</br>
</br>

### 5) Open SQL DELETE 구문
- PK 기준으로 단건 삭제하거나 조건(WHERE)에 맞는 여러 건 삭제 가능
- 삭제된 레코드 수는 **`sy-dbcnt`** 로 확인
- 조건이 맞는 데이터가 없으면 아무 것도 삭제되지 않음
```abap
*************** 단건 DELETE (Work Area) ****************
DELETE <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  FROM <WORK_AREA>.          " PK 기준 1건 삭제

*************** 단건 / 다중 DELETE (WHERE) ****************
DELETE FROM <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  WHERE <FULL_QUALIFIED_KEY>. " 조건에 맞는 단건/다중 삭제

*************** 다중 DELETE (Internal Table 방식) ****************
DELETE <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  FROM TABLE <ITAB>.          " 내부테이블의 PK 기준으로 여러 건 삭제
```
```abap
*************** 단건 DELETE (Work Area) ****************
gs_scustom-id = 1.
DELETE ZTSCUSTOM_B03 FROM gs_scustom.

*************** 단건 / 다중 DELETE (WHERE) ****************
DELETE FROM ZTSCUSTOM_B03 WHERE ID = 2.

*************** 다중 DELETE (Internal Table 방식) ****************
" DELETE FROM ZTSCUSTOM_B03 " (주의) 전체 삭제

SELECT * FROM ZTSCUSTOM_B03
  INTO TABLE gt_scustom
  WHERE ID <= 50.
DELETE ZTSCUSTOM_B03 FROM TABLE gt_scustom.
```
