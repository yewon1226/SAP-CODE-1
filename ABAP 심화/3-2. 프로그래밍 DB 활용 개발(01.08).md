## <  핵심 개념 >
</br>

- **서브스크린 생성시 LAYOUT에 서브스크린 지정 필수**
- **`MEMORY ID` 는 PARAMETERS, SELECT-OPTIONS에서만 선언 가능 (DATA는 불가능)**
</br>
</br>

---

</br>

## < ABAP LUW 기반 DB 처리 흐름 정리 >
- V1 Update는 즉시 실행되는 필수 DB 변경이며, V2 Update는 지연 실행되는 부가 작업임
- Lock은 V1 Update가 끝나면 자동 해제되고, V2 Update는 그 이후에 실행되며 Lock과는 무관함
- PERFORM ON COMMIT은 V1 Update가 끝난 뒤 DB COMMIT 직전에 자동 실행됨
</br>

### 1) COMMIT / ROLLBACK 구분 정리
</br>

- `COMMIT WORK` : 현재 LUW에서 수행된 모든 DB 변경사항을 확정 저장
- `ROLLBACK WORK` : 현재 LUW에서 수행된 모든 DB 변경사항을 취소 (COMMIT 이전까지만 가능)
</br>

**1-1) 암묵적 COMMIT**
- 화면이 변경되거나 프로그램이 비정상 종료될 때 자동 COMMIT
- RFC(Remote Function Call) 호출 시 / RFC 종료 시 자동 COMMIT
  
**1-2) 명시적 COMMIT**
- ABAP 구문으로 개발자가 직접 COMMIT 실행 : `COMMIT WORK`
  
**2-1) 암묵적 ROLLBACK**
- ABAP 덤프 발생 시 자동 ROLLBACK
- `MESSAGE TYPE 'A'` 또는 `MESSAGE TYPE 'X'` 발생 시 자동 ROLLBACK
  
**2-2) 명시적 ROLLBACK**
- ABAP 구문으로 개발자가 직접 ROLLBACK 실행 : `ROLLBACK WORK`
</br>


```abap
*************** 암묵적 COMMIT ****************
INSERT ztable FROM gs_data.
CALL SCREEN 200.     " 화면 전환 발생

INSERT ztable FROM gs_data.
LEAVE PROGRAM.      " 프로그램 비정상 종료 

INSERT ztable FROM gs_data.
CALL FUNCTION 'Z_RFC_FUNC'    " RFC 호출 / 종료 
  DESTINATION 'RFC_DEST'.

*************** 명시적 COMMIT ****************
INSERT ztable FROM gs_data.
COMMIT WORK.

*************** 암묵적 ROLLBACK ****************
INSERT ztable FROM gs_data.    " ABAP Dump 발생 → RUNTIME ERROR 발생

INSERT ztable FROM gs_data.
MESSAGE 'Fatal Error' TYPE 'A'.   " MESSAGE TYPE A / X 

*************** 명시적 ROLLBACK ****************
INSERT ztable FROM gs_data.
IF sy-subrc <> 0.
  ROLLBACK WORK.
ENDIF.
```
```abap
REPORT ZPROGB03_0034.

DATA: gt_scustom TYPE TABLE OF ZTSCUSTOM_B03,
      gs_scustom TYPE ZTSCUSTOM_B03.

DELETE FROM ZTSCUSTOM_B03.

SELECT * FROM scustom
  INTO TABLE gt_scustom
  WHERE ID BETWEEN 1 AND 30.

INSERT ZTSCUSTOM_B03 FROM TABLE gt_scustom.

UPDATE ZTSCUSTOM_B03
   SET name = 'First update~~~~~~'
   WHERE ID = 3.

COMMIT WORK. " LUW 종료되면서, 이전에 있던 변경사항이 DB에 반영됨

UPDATE ZTSCUSTOM_B03  " 여기서부터 새로운 LUW 시작
   SET name = 'Second update~~~~~'
   WHERE ID = 2.

UPDATE ZTSCUSTOM_B03
   SET name = 'Third update~~~~~'
   WHERE ID = 1.

ROLLBACK WORK.  " 해당 LUW에 있던 변경사항들 다 취소됨

IF sy-subrc = 0.
  WRITE: '성공'.
  ELSE.
    WRITE: '실패'.
ENDIF.
```
</br>
</br>
</br>

### 2) PERFORM ON COMMIT
- COMMIT WORK가 실행된 뒤 등록된 FORM들을 시스템 테이블에 쌓아두었다가 순서대로 실행
- 실행 시점은 DB COMMIT 이후이므로, FORM 안에서 에러(MESSAGE A/X)가 발생해도 이미 저장된 DB 변경은 되돌릴 수 없음
```abap
PERFORM x ON COMMIT.
PERFORM y ON COMMIT.
COMMIT WORK.
→ x 실행
→ y 실행
→ DB Commit 완료 (되돌릴 수 없음)
```
```abap
REPORT ZPROGB03_0034.

DATA: gt_scustom TYPE TABLE OF ZTSCUSTOM_B03,
      gs_scustom TYPE ZTSCUSTOM_B03.

DELETE FROM ZTSCUSTOM_B03.
SELECT *
  FROM scustom
  INTO TABLE gt_scustom
  WHERE id BETWEEN 1 AND 30.
INSERT ZTSCUSTOM_B03 FROM TABLE gt_scustom.

PERFORM update_1 ON COMMIT. " 커밋 대기
PERFORM update_2 ON COMMIT.

COMMIT WORK.

*&---------------------------------------------------------------------*

FORM update_1 .
  LOOP AT gt_scustom INTO gs_scustom.
    gs_scustom-name = 'Hone GIldong~~~~22'.
    MODIFY gt_scustom FROM gs_scustom.
  ENDLOOP.

  MODIFY ZTSCUSTOM_B03 FROM TABLE gt_scustom.
  IF sy-subrc = 0.
    WRITE: 'update 1번 성공'.
  ELSE.
    MESSAGE 'update 1번 실패' TYPE 'A'. " 롤백
  ENDIF.
ENDFORM.

*&---------------------------------------------------------------------*

FORM update_2 .
  READ TABLE gt_scustom INTO gs_scustom INDEX 10.
  gs_scustom-name = 'Hong Gildong~~~~~'.
  UPDATE ZTSCUSTOM_B03
     SET name = gs_scustom-name
   WHERE id = gs_scustom-id.

  IF sy-subrc = 0.
    WRITE: 'Update 2번 성공'.
  ELSE.
    MESSAGE 'Update 2번 실패' TYPE 'A'.
  ENDIF.
ENDFORM.
```
</br>
</br>
</br>

### 3) Update Module (업데이트 모듈)
- `CALL FUNCTION … IN UPDATE TASK` 로 등록된 후 COMMIT WORK 시점에 별도 Update Work Process에서 실행되는 DB 전용 Function Module
- IMPORTING 파라미터만 사용하며, DB 변경 중 오류(MESSAGE A/X) 발생 시 해당 Update LUW 전체가 롤백되고 즉시 종료됨
</br>

**1) 비동기 Update**
- `COMMIT WORK` 시 실제 DB 저장은 나중에 `Update Work Process` 가 따로 처리하고, 프로그램은 먼저 종료되는 방식
  
**2) 동기 Update**
- `COMMIT WORK AND WAIT` 를 사용해 Update 작업이 DB에 끝날 때까지 기다린 후 다음 로직(LUW 2)으로 넘어가는 방식
  
**3) Local Update**
- SET UPDATE TASK LOCAL로 Update Task를 같은 워크프로세스에서 즉시 실행해, 별도 Update Work Process 없이 현재 LUW 안에서 DB 반영되는 방식
  
</br>

```abap
******** Dialog Program ********
CALL FUNCTION 'F1' IN UPDATE TASK EXPORTING p1 = a.
CALL FUNCTION 'F2' IN UPDATE TASK EXPORTING q1 = b.
CALL FUNCTION 'F3' IN UPDATE TASK EXPORTING s1 = a.
COMMIT WORK.   " Update Task 실행 시작

******** Update Module ********
FUNCTION F1.
  UPDATE ztable.
     SET field = p1
  IF sy-subrc <> 0.
    MESSAGE 'Error' TYPE 'A'.   " Update LUW 롤백
  ENDIF.
ENDFUNCTION.
```
</br>
</br>

- `SE37` 로 확인 가능
<img width="489" height="270" alt="image" src="https://github.com/user-attachments/assets/cdc3eb43-91f7-4d3b-b09c-f00066d31b74" />
</br>
</br>

- Importing 파라미터만 받음
<img width="486" height="121" alt="image" src="https://github.com/user-attachments/assets/d0192e24-aa8a-40ee-988b-f09a9e39f165" />

</br>
</br>
</br>
</br>
</br>

### 4) Lock (SE11, SM12)
- 다른 사용자가 같은 데이터를 동시에 수정하지 못하게 막는 장치
- Lock Object 이름은 EY 또는 EZ로 시작해야 함
- `SM12` 에서는 현재 설정된 Lock 정보를 확인 가능
- Lock은 넘겨준 키 값만 정확히 잠그고, 안 넘긴 값은 전부 다 잠근다고 보면 됨
</br>

- 기존 Lock과 충돌: 다른 세션이 이미 Lock을 보유한 경우 → 예외 `FOREIGN_LOCK`
- Lock 관리 오류: 시스템 또는 Lock 서버 문제로 Lock 처리 실패 → 예외 `SYSTEM_FAILURE`
</br>


**1) Set lock**
- 특정 데이터(키)에 대해 새로운 Lock 설정

**2️) Promote optimistic lock**
- 기존 약한 Lock을 더 강한 Lock으로 승격

**3️) Check whether lock can be set or promoted**
- 기존 Lock 존재 여부 확인 후 Lock 설정/승격 가능 여부 판단
</br>

- 같은 프로그램에서는 S·O·E Lock은 누적 가능하지만, X Lock이 있으면 추가 Lock은 불가능
- Lock은 너무 일찍 잡거나 오래 유지하면 충돌과 성능 문제를 유발함
  
| Parameter / Mode        | Value        | Meaning |
|-------------------------|-------------|---------|
| mode_<table_name>       | 'S' / 'W'   | **Shared Lock** </br> → 모두 조회 가능, 누구도 수정 불가 </br> → 여러 프로그램에서 추가 Shared Lock 가능 |
|                         | 'O'         | **Optimistic Lock** </br> → 모두 조회/수정 가능 </br> → 실제 DB Update 시에만 나만 수정 가능하도록 E Lock으로 전환 |
|                         | 'E' / 'V'   | **Exclusive Lock (누적)** </br> → 나만 수정 가능, 다른 세션 조회/수정 불가 </br> → 동일 프로그램에서는 추가 Lock 설정 가능 |
|                         | 'X' / 'U'   | **Exclusive Lock (비누적)** </br> → 나만 수정 가능, 다른 세션 조회/수정 불가 </br> → 동일 프로그램에서도 추가 Lock 설정 불가 |
|                         | 'R' / 'C'   | Optimistic(O) Lock을 Exclusive(E) Lock으로 **승격** </br> 또는 승격 가능 여부 체크 |
| <lock_parameter>        | <val>       | Lock Object에 정의된 키 필드 값 </br> (Lock Argument 구성 요소) |
| x_<lock_parameter>      | space       | 해당 Lock Parameter 값 기준으로 Lock 설정 (기본값) |
|                         | 'X'         | 해당 필드 값이 Initial인 모든 레코드에 대해 Lock |
| _scope                  | '1'         | Lock이 현재 프로그램 내에서만 유지 |
|                         | '2'         | Lock을 V1 Update Task로 전달 (기본값) |
|                         | '3'         | 프로그램 + V1 Update Task 모두에서 Lock 유지 |
| _wait                   | space       | 외부 Lock 존재 시 대기 없이 즉시 실패 (기본값) |
|                         | 'X'         | 외부 Lock 존재 시 한 번 더 Lock 시도 |
| _collect                | space       | Lock Container 미사용 </br> 즉시 Lock table에 반영 (기본값) |
|                         | 'X'         | Lock Container 사용 </br> 여러 Lock을 모아두었다가 FLUSH_ENQUEUE로 한 번에 반영 |

</br>

```abap
*************** LOCK 설정 (ENQUEUE) ****************
CALL FUNCTION 'ENQUEUE_ESFLIGHT'
  EXPORTING
    carrid = lv_carrid
    connid = lv_connid
    fldate = lv_fldate
  EXCEPTIONS
    foreign_lock   = 1
    system_failure = 2.

CASE sy-subrc.
  WHEN 0.
    " Lock 설정 성공
  WHEN 1.
    " FOREIGN_LOCK : 다른 세션이 이미 Lock 보유
  WHEN 2.
    " SYSTEM_FAILURE : Lock 서버/시스템 오류
ENDCASE.

*************** LOCK 해제 (DEQUEUE) ****************
CALL FUNCTION 'DEQUEUE_ESFLIGHT'
  EXPORTING
    carrid = lv_carrid
    connid = lv_connid
    fldate = lv_fldate.
```
- 같은 창에서는 이미 Lock을 잡고 있어서 성공하고, 다른 창에서는 해당 Lock이 선점되어 있어 FOREIGN_LOCK으로 실패함
```abap
REPORT ZPROGB03_0034.

*************** LOCK 설정 (ENQUEUE) ****************
CALL FUNCTION 'ENQUEUE_EZ_WORKB03'
 EXPORTING
   MODE_ZDBWORK_B03       = 'E'
   MANDT                  = SY-MANDT
   WORKNO                 = 1
 EXCEPTIONS
   FOREIGN_LOCK           = 1
   SYSTEM_FAILURE         = 2
   OTHERS                 = 3.
IF sy-subrc <> 0.
  WRITE: '실패'.
  ELSE.
    WRITE: '성공'.
ENDIF.

*************** LOCK 해제 (DEQUEUE) ****************
CALL FUNCTION 'DEQUEUE_EZ_WORKB03'
 EXPORTING
   MODE_ZDBWORK_B03       = 'E'
   MANDT                  = SY-MANDT
   WORKNO                 = 1.
* CALL FUNCTION 'DEQUEUE_ALL'. " 모든 락 해제
```
</br>
</br>

- Lock을 걸 대상 테이블(SPFLI)과 어떤 방식으로 잠글지 정하는 화면
- `primary table` : 락을 설정할 테이블
<img width="503" height="220" alt="image" src="https://github.com/user-attachments/assets/d5d730e6-e767-445c-bbaf-8b2248ca9fc7" />
</br>

- 드롭다운 리스트에서 키 값(S, O, E, X 등) 을 함께 표시하도록 하는 옵션
<img width="501" height="261" alt="image" src="https://github.com/user-attachments/assets/056eaeb6-c3e6-4e45-b6ad-f4b03b9a7925" />
</br>
</br>

<img width="484" height="376" alt="image" src="https://github.com/user-attachments/assets/e735aae2-0c76-4f13-875d-69fbc9f1d63a" />
</br>
</br>

- 해당 Lock Object로 자동 생성된 ENQUEUE / DEQUEUE 함수 목록을 확인하는 버튼
<img width="401" height="82" alt="image" src="https://github.com/user-attachments/assets/08595954-e580-4572-8ceb-9b6f861d139d" />
</br>

<img width="375" height="107" alt="image" src="https://github.com/user-attachments/assets/80c173bf-0a89-41ce-bbb6-4760e0c5bdf1" />
</br>
</br>

- `SM12` : 현재 시스템에 설정된 Lock 정보 조회
<img width="467" height="236" alt="image" src="https://github.com/user-attachments/assets/e55af051-0840-4e6f-8561-cabdee10e5b3" />
</br>
</br>
</br>
</br>
</br>

### 5) CALL TRANSACTION MODE·UPDATE 및 호출 방식 요약
- `MODE 'A'` : 모든 화면 표시 (디버깅용)
- `MODE 'N'` : 화면 없이 백그라운드 실행
- `MODE 'E'` : 오류 발생 시에만 화면 표시
- `UPDATE 'S'` : 동기 Update, COMMIT 끝날 때까지 대기
- `UPDATE 'A'` : 비동기 Update, COMMIT 후 바로 진행

| 호출 방식 | Data 공유 | SAP LUW | 언제 사용? |
|----------|-----------|---------|------------|
| CALL FUNCTION<br>CALL METHOD | 분리됨 | 동일 | 같은 LUW 안에서 조회 / 변경 |
| SUBMIT AND RETURN<br>CALL TRANSACTION | 분리됨 | 분리됨 | 다른 LUW에서 조회 / 변경 |
| CALL FUNCTION<br>STARTING NEW TASK | 분리됨 | 분리됨 | 병렬 처리 (Parallel Task) |

```abap
CALL TRANSACTION '<T_CODE>'
  USING <BDC_ITAB>
  MODE   '<A/N/E>'
  UPDATE '<S/A>'.
```
```abap
" 화면 모두 표시
CALL TRANSACTION 'T1'
  USING bdc_itab
  MODE 'A'      " 모든 화면 표시
  UPDATE 'S'.   " 동기 Update (완료까지 대기)

" 화면 없이 실행
CALL TRANSACTION 'T2'
  USING bdc_itab
  MODE 'N'      " 백그라운드 실행
  UPDATE 'A'.   " 비동기 Update (대기 없음)

" 오류 시에만 화면 표시
CALL TRANSACTION 'T3'
  USING bdc_itab
  MODE 'E'      " 오류 발생 시 화면 표시
  UPDATE 'S'.   " 동기 Update
```
</br>
</br>
</br>

---

</br>

## < Number Range (TCODE: `SNRO`) >
- 번호 범위는 `From ~ To` 로 정의되며, 서로 겹칠 수 없음
- Ext 체크 여부로 내부 번호 (시스템 자동 증가) 부여 / 외부 번호 (사용자 입력) 부여를 결정함
- 같은 번호라도 Subobject가 다르면 중복 사용 가능
- 그룹 테이블로 분류값을 지정해, 특정 종류별로 다른 번호 범위를 사용하도록 구성 가능
</br>

- Number Range Object는 이름을 `Z` 또는 `Y` 로 시작해야 함
- `Number Length Domain` 은 필수값이며, 도메인에서 `NUMC` 또는 `CHAR` 타입으로 정의하고 최대 20자리까지 가능
- `% Warning` 은 번호 범위 사용률이 `0.1 ~ 99.9%` 에 도달하면 경고를 주는 기준이며, 보통 10.0으로 설정함
- `No rolling` 은 번호 범위를 다 써도 다시 처음으로 돌아가지 않고 더 이상 번호를 부여하지 않는 설정

<img width="508" height="316" alt="image" src="https://github.com/user-attachments/assets/dbcfea6c-aab7-424f-968d-1c70d07578c4" />
</br>
</br>

```abap
*************** Number Range 정보 조회 ****************
CALL FUNCTION 'NUMBER_GET_INFO'
  EXPORTING
    nr_range_nr = <number_range_number>      " Number Range Interval
    object      = <number_range_object_name> " Number Range Object
    subobject   = <number_range_sub_object>  " Subobject (옵션)
    toyear      = <to_fiscal_year>           " 회계연도 (옵션)
  IMPORTING
    interval    = <interval_info>             " Interval 정보
    NRIV        = <internal_info_table>       " 내부 관리 정보 테이블
  EXCEPTIONS
    interval_not_found = 1
    object_not_found  = 2.

*************** Number Range 다음 번호 채번 ****************
CALL FUNCTION 'NUMBER_GET_NEXT'
  EXPORTING
    nr_range_nr   = <number_range_number>       " Number Range Interval 번호
    object        = <number_range_object_name>  " Number Range Object
    quantity      = <quantity_of_numbers>       " 요청할 번호 개수 (보통 1)
    subobject     = <number_range_sub_object>   " Subobject (옵션)
    toyear        = <to_fiscal_year>             " 회계연도 기준 (옵션)
    ignore_buffer = <ignore_buffer_flag>        " 버퍼 무시 여부
  IMPORTING
    number        = <next_free_number>           " 할당된 다음 번호
    quantity      = <quantity_of_numbers_read>  " 실제 할당된 개수
    returncode    = <return_code>                " 처리 결과 코드
  EXCEPTIONS
    interval_not_found       = 1
    number_range_not_intern  = 2
    object_not_found         = 3
    quantity_is_0            = 4
    quantity_is_not_1        = 5
    interval_overflow        = 6
    buffer_overflow          = 7.

*************** External Number Range 값 검증 ****************
CALL FUNCTION 'NUMBER_CHECK'
  EXPORTING
    nr_range_nr   = <number_range_number>        " Number Range Interval 번호
    number        = <number_to_be_checked>       " 사용자가 입력한 번호
    object        = <number_range_object_name>   " Number Range Object
    subobject     = <number_range_sub_object>    " Subobject (옵션)
    toyear        = <to_fiscal_year>              " 회계연도 기준 (옵션)
    numeric_check = <numeric_check_flag>         " 숫자 여부 체크
  IMPORTING
    returncode    = <return_code>                 " space: 사용 가능 / 'X': 사용 불가
  EXCEPTIONS
    interval_not_found      = 1
    number_range_not_extern = 2
    object_not_found        = 3.
```
</br>
</br>

- 번호 범위를 정해두고 순서대로 번호를 발급하는 과정
<img width="492" height="282" alt="image" src="https://github.com/user-attachments/assets/83103505-1afd-4666-9bf2-7d1bde67045e" />
</br>

<img width="364" height="99" alt="image" src="https://github.com/user-attachments/assets/c187b9e3-1763-4e75-a57e-b5fe3cb53210" />
</br>

<img width="526" height="86" alt="image" src="https://github.com/user-attachments/assets/bcd30086-2172-4876-a8c3-4262f4f100e7" />
</br>

```abap
REPORT ZPROGB03_0035.

DATA: lv_number TYPE NUMC10.

CALL FUNCTION 'NUMBER_GET_NEXT'
  EXPORTING
    nr_range_nr = 'A1'
    object      = 'ZNUM_B03'
 IMPORTING
   NUMBER      = lv_number
 EXCEPTIONS
   INTERVAL_NOT_FOUND            = 1
   NUMBER_RANGE_NOT_INTERN       = 2
   OBJECT_NOT_FOUND              = 3
   QUANTITY_IS_0                 = 4
   QUANTITY_IS_NOT_1             = 5
   INTERVAL_OVERFLOW             = 6
   BUFFER_OVERFLOW               = 7
   OTHERS      = 8.

IF sy-subrc = 0.
  WRITE: lv_number.
ELSE.
  EXIT.
ENDIF.
```
</br>

- 현재까지 사용된 마지막 번호 확인
<img width="528" height="87" alt="image" src="https://github.com/user-attachments/assets/ee38de26-11bd-4415-9da0-856c7684d883" />
</br>

- NR Status에서 값을 직접 바꿔서 마지막 사용 번호를 수정
<img width="380" height="111" alt="image" src="https://github.com/user-attachments/assets/c2e42be0-a083-4666-9d3b-050bd211b684" />
</br>

<img width="523" height="90" alt="image" src="https://github.com/user-attachments/assets/c813b8e0-5523-4bf6-9346-99aad5b773d4" />
</br>

- 결과 확인
<img width="528" height="88" alt="image" src="https://github.com/user-attachments/assets/0910bf1b-eecd-49b6-b57e-b85958e6d321" />

