## <  핵심 개념 >
</br>

- **서브스크린 생성시 LAYOUT에 서브스크린 지정 필수**
- **`MEMORY ID` 는 PARAMETERS, SELECT-OPTIONS에서만 선언 가능 (DATA는 불가능)**
</br>
</br>

---

</br>

## < ABAP 데이터 무결성 제어 : COMMIT / ROLLBACK / Lock >
</br>

### 1) COMMIT / ROLLBACK 구분 정리
</br>

- `COMMIT WORK` : 현재 LUW에서 수행된 모든 DB 변경사항을 확정 저장
- `ROLLBACK WORK` : 현재 LUW에서 수행된 모든 DB 변경사항을 취소 (COMMIT 이전까지만 가능)
</br>

**1-1) 암묵적 COMMIT**
- 화면이 변경되거나 프로그램이 비정상 종료될 때 자동 COMMIT
- RFC(Remote Function Call) 호출 시 / RFC 종료 시 자동 COMMIT
  
**1-2) 명시적 COMMIT**
- ABAP 구문으로 개발자가 직접 COMMIT 실행 : `COMMIT WORK`
  
**2-1) 암묵적 ROLLBACK**
- ABAP 덤프 발생 시 자동 ROLLBACK
- `MESSAGE TYPE 'A'` 또는 `MESSAGE TYPE 'X'` 발생 시 자동 ROLLBACK
  
**2-2) 명시적 ROLLBACK**
- ABAP 구문으로 개발자가 직접 ROLLBACK 실행 : `ROLLBACK WORK`
</br>

| Parameter / Mode        | Value        | Meaning |
|-------------------------|-------------|---------|
| mode_<table_name>       | 'S' / 'W'   | **Shared Lock** 설정 또는 Lock 가능 여부 체크 → 여러 프로그램에서 추가 Shared Lock 가능 |
|                         | 'O'         | **Optimistic Lock** 설정 </br> → 여러 프로그램에서 추가 가능, 실제 DB 변경 시 Exclusive(E)로 승격 가능 |
|                         | 'E' / 'V'   | **Exclusive (누적)** Lock 설정 → 데이터 변경용, 동일 프로그램에서만 추가 Lock 가능 |
|                         | 'X' / 'U'   | **Exclusive (비누적)** Lock 설정 → 데이터 변경용, 동일 프로그램에서도 추가 Lock 불가 |
|                         | 'R' / 'C'   | Optimistic(O) Lock을 Exclusive(E) Lock으로 **승격**하거나 승격 가능 여부 체크 |
| <lock_parameter>        | <val>       | Lock Object에 정의된 키 필드 값 (Lock Argument 구성 요소) |
| x_<lock_parameter>      | space       | 해당 Lock Parameter 값 기준으로 Lock 설정 (기본값) |
|                         | 'X'         | 해당 필드 값이 Initial인 모든 레코드에 대해 Lock |
| _scope                  | '1'         | Lock이 현재 프로그램 내에서만 유지 |
|                         | '2'         | Lock을 V1 Update Task로 전달 (기본값) |
|                         | '3'         | 프로그램 + V1 Update Task 모두에서 Lock 유지 |
| _wait                   | space       | 외부 Lock 존재 시 대기 없이 즉시 실패 (기본값) |
|                         | 'X'         | 외부 Lock 존재 시 한 번 더 Lock 시도 |
| _collect                | space       | Lock Container 미사용, 즉시 Lock table에 반영 (기본값) |
|                         | 'X'         | Lock Container 사용, 여러 Lock을 모아두었다가 FLUSH_ENQUEUE로 한 번에 반영 |

</br>

```abap
*************** 암묵적 COMMIT ****************
INSERT ztable FROM gs_data.
CALL SCREEN 200.     " 화면 전환 발생

INSERT ztable FROM gs_data.
LEAVE PROGRAM.      " 프로그램 비정상 종료 

INSERT ztable FROM gs_data.
CALL FUNCTION 'Z_RFC_FUNC'    " RFC 호출 / 종료 
  DESTINATION 'RFC_DEST'.

*************** 명시적 COMMIT ****************
INSERT ztable FROM gs_data.
COMMIT WORK.

*************** 암묵적 ROLLBACK ****************
INSERT ztable FROM gs_data.    " ABAP Dump 발생 → RUNTIME ERROR 발생

INSERT ztable FROM gs_data.
MESSAGE 'Fatal Error' TYPE 'A'.   " MESSAGE TYPE A / X 

*************** 명시적 ROLLBACK ****************
INSERT ztable FROM gs_data.
IF sy-subrc <> 0.
  ROLLBACK WORK.
ENDIF.
```
</br>
</br>

### 2) Lock (SE11)
- 다른 사용자가 같은 데이터를 동시에 수정하지 못하게 막는 장치
- Lock Object 이름은 EY 또는 EZ로 시작해야 함
- Lock은 넘겨준 키 값만 정확히 잠그고, 안 넘긴 값은 전부 다 잠근다고 보면 됨
</br>

- 기존 Lock과 충돌: 다른 세션이 이미 Lock을 보유한 경우 → 예외 `FOREIGN_LOCK`
- Lock 관리 오류: 시스템 또는 Lock 서버 문제로 Lock 처리 실패 → 예외 `SYSTEM_FAILURE`
</br>


**1) Set lock**
- 특정 데이터(키)에 대해 새로운 Lock 설정

**2️) Promote optimistic lock**
- 기존 약한 Lock을 더 강한 Lock으로 승격

**3️) Check whether lock can be set or promoted**
- 기존 Lock 존재 여부 확인 후 Lock 설정/승격 가능 여부 판단
</br>

```abap
*************** LOCK 설정 (ENQUEUE) ****************
CALL FUNCTION 'ENQUEUE_ESFLIGHT'
  EXPORTING
    carrid = lv_carrid
    connid = lv_connid
    fldate = lv_fldate
  EXCEPTIONS
    foreign_lock   = 1
    system_failure = 2.

CASE sy-subrc.
  WHEN 0.
    " Lock 설정 성공
  WHEN 1.
    " FOREIGN_LOCK : 다른 세션이 이미 Lock 보유
  WHEN 2.
    " SYSTEM_FAILURE : Lock 서버/시스템 오류
ENDCASE.

*************** LOCK 해제 (DEQUEUE) ****************
CALL FUNCTION 'DEQUEUE_ESFLIGHT'
  EXPORTING
    carrid = lv_carrid
    connid = lv_connid
    fldate = lv_fldate.
```
