## <  핵심 개념 >
</br>

- **서브스크린 생성시 LAYOUT에 서브스크린 지정 필수**
- **`MEMORY ID` 는 PARAMETERS, SELECT-OPTIONS에서만 선언 가능 (DATA는 불가능)**
</br>
</br>

---

</br>

## < ABAP 데이터 무결성 제어 : COMMIT / ROLLBACK / Lock >
</br>

### 1) COMMIT / ROLLBACK 구분 정리
</br>

- `COMMIT WORK` : 현재 LUW에서 수행된 모든 DB 변경사항을 확정 저장
- `ROLLBACK WORK` : 현재 LUW에서 수행된 모든 DB 변경사항을 취소 (COMMIT 이전까지만 가능)
</br>

**1-1) 암묵적 COMMIT**
- 화면이 변경되거나 프로그램이 비정상 종료될 때 자동 COMMIT
- RFC(Remote Function Call) 호출 시 / RFC 종료 시 자동 COMMIT
  
**1-2) 명시적 COMMIT**
- ABAP 구문으로 개발자가 직접 COMMIT 실행 : `COMMIT WORK`
  
**2-1) 암묵적 ROLLBACK**
- ABAP 덤프 발생 시 자동 ROLLBACK
- `MESSAGE TYPE 'A'` 또는 `MESSAGE TYPE 'X'` 발생 시 자동 ROLLBACK
  
**2-2) 명시적 ROLLBACK**
- ABAP 구문으로 개발자가 직접 ROLLBACK 실행 : `ROLLBACK WORK`
</br>


```abap
*************** 암묵적 COMMIT ****************
INSERT ztable FROM gs_data.
CALL SCREEN 200.     " 화면 전환 발생

INSERT ztable FROM gs_data.
LEAVE PROGRAM.      " 프로그램 비정상 종료 

INSERT ztable FROM gs_data.
CALL FUNCTION 'Z_RFC_FUNC'    " RFC 호출 / 종료 
  DESTINATION 'RFC_DEST'.

*************** 명시적 COMMIT ****************
INSERT ztable FROM gs_data.
COMMIT WORK.

*************** 암묵적 ROLLBACK ****************
INSERT ztable FROM gs_data.    " ABAP Dump 발생 → RUNTIME ERROR 발생

INSERT ztable FROM gs_data.
MESSAGE 'Fatal Error' TYPE 'A'.   " MESSAGE TYPE A / X 

*************** 명시적 ROLLBACK ****************
INSERT ztable FROM gs_data.
IF sy-subrc <> 0.
  ROLLBACK WORK.
ENDIF.
```
```abap
REPORT ZPROGB03_0034.

DATA: gt_scustom TYPE TABLE OF ZTSCUSTOM_B03,
      gs_scustom TYPE ZTSCUSTOM_B03.

DELETE FROM ZTSCUSTOM_B03.

SELECT * FROM scustom
  INTO TABLE gt_scustom
  WHERE ID BETWEEN 1 AND 30.

INSERT ZTSCUSTOM_B03 FROM TABLE gt_scustom.

UPDATE ZTSCUSTOM_B03
   SET name = 'First update~~~~~~'
   WHERE ID = 3.

COMMIT WORK. " LUW 종료되면서, 이전에 있던 변경사항이 DB에 반영됨

UPDATE ZTSCUSTOM_B03  " 여기서부터 새로운 LUW 시작
   SET name = 'Second update~~~~~'
   WHERE ID = 2.

UPDATE ZTSCUSTOM_B03
   SET name = 'Third update~~~~~'
   WHERE ID = 1.

ROLLBACK WORK.  " 해당 LUW에 있던 변경사항들 다 취소됨

IF sy-subrc = 0.
  WRITE: '성공'.
  ELSE.
    WRITE: '실패'.
ENDIF.
```
</br>
</br>
</br>

### 2) Lock (SE11, SM12)
- 다른 사용자가 같은 데이터를 동시에 수정하지 못하게 막는 장치
- Lock Object 이름은 EY 또는 EZ로 시작해야 함
- `SM12` 에서는 현재 설정된 Lock 정보를 확인 가능
- Lock은 넘겨준 키 값만 정확히 잠그고, 안 넘긴 값은 전부 다 잠근다고 보면 됨
</br>

- 기존 Lock과 충돌: 다른 세션이 이미 Lock을 보유한 경우 → 예외 `FOREIGN_LOCK`
- Lock 관리 오류: 시스템 또는 Lock 서버 문제로 Lock 처리 실패 → 예외 `SYSTEM_FAILURE`
</br>


**1) Set lock**
- 특정 데이터(키)에 대해 새로운 Lock 설정

**2️) Promote optimistic lock**
- 기존 약한 Lock을 더 강한 Lock으로 승격

**3️) Check whether lock can be set or promoted**
- 기존 Lock 존재 여부 확인 후 Lock 설정/승격 가능 여부 판단
</br>

- 같은 프로그램에서는 S·O·E Lock은 누적 가능하지만, X Lock이 있으면 추가 Lock은 불가능
- Lock은 너무 일찍 잡거나 오래 유지하면 충돌과 성능 문제를 유발함
  
| Parameter / Mode        | Value        | Meaning |
|-------------------------|-------------|---------|
| mode_<table_name>       | 'S' / 'W'   | **Shared Lock** </br> → 모두 조회 가능, 누구도 수정 불가 </br> → 여러 프로그램에서 추가 Shared Lock 가능 |
|                         | 'O'         | **Optimistic Lock** </br> → 모두 조회/수정 가능 </br> → 실제 DB Update 시에만 나만 수정 가능하도록 E Lock으로 전환 |
|                         | 'E' / 'V'   | **Exclusive Lock (누적)** </br> → 나만 수정 가능, 다른 세션 조회/수정 불가 </br> → 동일 프로그램에서는 추가 Lock 설정 가능 |
|                         | 'X' / 'U'   | **Exclusive Lock (비누적)** </br> → 나만 수정 가능, 다른 세션 조회/수정 불가 </br> → 동일 프로그램에서도 추가 Lock 설정 불가 |
|                         | 'R' / 'C'   | Optimistic(O) Lock을 Exclusive(E) Lock으로 **승격** </br> 또는 승격 가능 여부 체크 |
| <lock_parameter>        | <val>       | Lock Object에 정의된 키 필드 값 </br> (Lock Argument 구성 요소) |
| x_<lock_parameter>      | space       | 해당 Lock Parameter 값 기준으로 Lock 설정 (기본값) |
|                         | 'X'         | 해당 필드 값이 Initial인 모든 레코드에 대해 Lock |
| _scope                  | '1'         | Lock이 현재 프로그램 내에서만 유지 |
|                         | '2'         | Lock을 V1 Update Task로 전달 (기본값) |
|                         | '3'         | 프로그램 + V1 Update Task 모두에서 Lock 유지 |
| _wait                   | space       | 외부 Lock 존재 시 대기 없이 즉시 실패 (기본값) |
|                         | 'X'         | 외부 Lock 존재 시 한 번 더 Lock 시도 |
| _collect                | space       | Lock Container 미사용 </br> 즉시 Lock table에 반영 (기본값) |
|                         | 'X'         | Lock Container 사용 </br> 여러 Lock을 모아두었다가 FLUSH_ENQUEUE로 한 번에 반영 |

</br>

```abap
*************** LOCK 설정 (ENQUEUE) ****************
CALL FUNCTION 'ENQUEUE_ESFLIGHT'
  EXPORTING
    carrid = lv_carrid
    connid = lv_connid
    fldate = lv_fldate
  EXCEPTIONS
    foreign_lock   = 1
    system_failure = 2.

CASE sy-subrc.
  WHEN 0.
    " Lock 설정 성공
  WHEN 1.
    " FOREIGN_LOCK : 다른 세션이 이미 Lock 보유
  WHEN 2.
    " SYSTEM_FAILURE : Lock 서버/시스템 오류
ENDCASE.

*************** LOCK 해제 (DEQUEUE) ****************
CALL FUNCTION 'DEQUEUE_ESFLIGHT'
  EXPORTING
    carrid = lv_carrid
    connid = lv_connid
    fldate = lv_fldate.
```
- 같은 창에서는 이미 Lock을 잡고 있어서 성공하고, 다른 창에서는 해당 Lock이 선점되어 있어 FOREIGN_LOCK으로 실패함
```abap
REPORT ZPROGB03_0034.

*************** LOCK 설정 (ENQUEUE) ****************
CALL FUNCTION 'ENQUEUE_EZ_WORKB03'
 EXPORTING
   MODE_ZDBWORK_B03       = 'E'
   MANDT                  = SY-MANDT
   WORKNO                 = 1
 EXCEPTIONS
   FOREIGN_LOCK           = 1
   SYSTEM_FAILURE         = 2
   OTHERS                 = 3.
IF sy-subrc <> 0.
  WRITE: '실패'.
  ELSE.
    WRITE: '성공'.
ENDIF.

*************** LOCK 해제 (DEQUEUE) ****************
CALL FUNCTION 'DEQUEUE_EZ_WORKB03'
 EXPORTING
   MODE_ZDBWORK_B03       = 'E'
   MANDT                  = SY-MANDT
   WORKNO                 = 1.
* CALL FUNCTION 'DEQUEUE_ALL'. " 모든 락 해제
```
</br>
</br>

- Lock을 걸 대상 테이블(SPFLI)과 어떤 방식으로 잠글지 정하는 화면
<img width="503" height="220" alt="image" src="https://github.com/user-attachments/assets/d5d730e6-e767-445c-bbaf-8b2248ca9fc7" />
</br>

<img width="501" height="261" alt="image" src="https://github.com/user-attachments/assets/056eaeb6-c3e6-4e45-b6ad-f4b03b9a7925" />
</br>
</br>

- 드롭다운 리스트에서 키 값(S, O, E, X 등) 을 함께 표시하도록 하는 옵션
<img width="484" height="376" alt="image" src="https://github.com/user-attachments/assets/e735aae2-0c76-4f13-875d-69fbc9f1d63a" />
</br>
</br>

- 해당 Lock Object로 자동 생성된 ENQUEUE / DEQUEUE 함수 목록을 확인하는 버튼
<img width="401" height="82" alt="image" src="https://github.com/user-attachments/assets/08595954-e580-4572-8ceb-9b6f861d139d" />
</br>

<img width="375" height="107" alt="image" src="https://github.com/user-attachments/assets/80c173bf-0a89-41ce-bbb6-4760e0c5bdf1" />
</br>
</br>

- `SM12` : 현재 시스템에 설정된 Lock 정보 조회
<img width="467" height="236" alt="image" src="https://github.com/user-attachments/assets/e55af051-0840-4e6f-8561-cabdee10e5b3" />
</br>
</br>
</br>
</br>
</br>
</br>

### 3) PERFORM ON COMMIT
- COMMIT WORK가 실행된 뒤 등록된 FORM들을 시스템 테이블에 쌓아두었다가 순서대로 실행
- 실행 시점은 DB COMMIT 이후이므로, FORM 안에서 에러(MESSAGE A/X)가 발생해도 이미 저장된 DB 변경은 되돌릴 수 없음
```abap
PERFORM x ON COMMIT.
PERFORM y ON COMMIT.
COMMIT WORK.
→ x 실행
→ y 실행
→ DB Commit 완료 (되돌릴 수 없음)
```
```abap
REPORT ZPROGB03_0034.

DATA: gt_scustom TYPE TABLE OF ZTSCUSTOM_B03,
      gs_scustom TYPE ZTSCUSTOM_B03.

DELETE FROM ZTSCUSTOM_B03.
SELECT *
  FROM scustom
  INTO TABLE gt_scustom
  WHERE id BETWEEN 1 AND 30.
INSERT ZTSCUSTOM_B03 FROM TABLE gt_scustom.

PERFORM update_1 ON COMMIT. " 커밋 대기
PERFORM update_2 ON COMMIT.

COMMIT WORK.

*&---------------------------------------------------------------------*

FORM update_1 .
  LOOP AT gt_scustom INTO gs_scustom.
    gs_scustom-name = 'Hone GIldong~~~~22'.
    MODIFY gt_scustom FROM gs_scustom.
  ENDLOOP.

  MODIFY ZTSCUSTOM_B03 FROM TABLE gt_scustom.
  IF sy-subrc = 0.
    WRITE: 'update 1번 성공'.
  ELSE.
    MESSAGE 'update 1번 실패' TYPE 'A'. " 롤백
  ENDIF.
ENDFORM.

*&---------------------------------------------------------------------*

FORM update_2 .
  READ TABLE gt_scustom INTO gs_scustom INDEX 10.
  gs_scustom-name = 'Hong Gildong~~~~~'.
  UPDATE ZTSCUSTOM_B03
     SET name = gs_scustom-name
   WHERE id = gs_scustom-id.

  IF sy-subrc = 0.
    WRITE: 'Update 2번 성공'.
  ELSE.
    MESSAGE 'Update 2번 실패' TYPE 'A'.
  ENDIF.
ENDFORM.
```
