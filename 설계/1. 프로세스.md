# DB 설계 방법

### 프로세스 (1/6) : 테이블은 어떻게 찾아낼까?
</br>

### < 테이블(엔티티)을 찾아내는 일반적인 순서 >
- 요구사항 수집 => 명사 도출 => 엔티티 정의
</br>
</br>

<img width="315" height="207" alt="image" src="https://github.com/user-attachments/assets/2dc5c65f-b8d2-4de7-bdfd-a397f20c8c45" />
</br>
</br>

<img width="522" height="459" alt="image" src="https://github.com/user-attachments/assets/0f8bb05f-6712-4cd6-9157-26c2fb2e6073" />
</br>
</br>

<img width="518" height="439" alt="image" src="https://github.com/user-attachments/assets/23cc3629-feab-4ed1-806e-b2a56049d66a" />

</br>
</br>
</br>

---

### 프로세스 (2/6) : 안전하고 효율적인 구조
- 중복 제거하기 (데이터 중복, 관계 중복)
</br>

### < 1차 정규화>
- 테이블의 각 컬럼이 원자값(하나의 값)을 가져야 하며, 같은 컬럼 내에서 중복된 값을 허용하지 않음.
- 한 칸에 하나의 데이터
<img width="512" height="372" alt="image" src="https://github.com/user-attachments/assets/0de09b09-18f3-42a4-b63c-61c7c980432e" />
</br>
</br>
</br>

### < 2차 정규화 >
- 1차 정규화를 만족하며, 복합키의 일부에만 종속되는 속성이 없어야 함 (부분 종속 없애기)
<img width="503" height="438" alt="image" src="https://github.com/user-attachments/assets/e03f4801-01e0-48e7-b349-cce43b673024" />
</br>
</br>
</br>

### < 3차 정규화 >
- 2차 정규화를 만족하며, 기본키가 아닌 다른 속성에 종속되는 속성이 없어야 함. (이행적 종속 없애기)
- 이행적 종속: A → B, B → C 이면, A → C 라고 할 수 있음. 여기서 C가 사실 A를 직접 의존하지 않고 B를 통해서만 알 수 있는 것.
<img width="514" height="411" alt="image" src="https://github.com/user-attachments/assets/73386214-d19e-429b-9c4a-18798b2976ef" />

</br>
</br>
</br>

---

### 프로세스 (3/6) : 쇼핑몰 주문관리 구축하기  #1
</br>

### < 주요 기능 및 요구사항 >
<img width="821" height="471" alt="image" src="https://github.com/user-attachments/assets/3dfeafc8-7868-4802-8140-345f81cecc74" />
</br>
</br>
</br>

### < 요구사항에서부터 도출한 엔티티 목록 >
<img width="322" height="371" alt="image" src="https://github.com/user-attachments/assets/9af0d164-de12-41e6-81dc-88eff995e369" />
</br>
</br>
</br>

### < 기능 설계 >
<img width="883" height="435" alt="image" src="https://github.com/user-attachments/assets/1860ae1c-b441-4016-96cf-0b26297b9626" />
</br>
</br>
</br>

### < 기능 - 엔티티 매핑 >
<img width="754" height="337" alt="image" src="https://github.com/user-attachments/assets/01c38304-4d73-4228-bccf-749489b557fc" />
</br>
</br>
</br>

### < ERD >
<img width="751" height="357" alt="image" src="https://github.com/user-attachments/assets/3a174ecb-a949-4fdb-8efa-56c027efa4c1" />
</br>
</br>
</br>

---

### 프로세스 (4/6) : 설계의 핵심요소 살펴보기
</br>

### < 설계의 기본 요소 >
<img width="815" height="272" alt="image" src="https://github.com/user-attachments/assets/499aaf4b-5c11-4396-9e7a-4747e089888e" />
</br>
</br>
</br>

### < 구체적인 설계 방법 >
<img width="640" height="292" alt="image" src="https://github.com/user-attachments/assets/efc9b4b7-9423-4422-860a-5c7dcf819831" />
</br>
</br>
</br>

### < 상태 다이어그램을 이용한 네비게이션 설계 >
<img width="774" height="188" alt="image" src="https://github.com/user-attachments/assets/14ebdb84-d289-4cfd-93af-7fd3cd6fad2b" />
</br>
</br>
</br>

### < 화면 레이아웃 - 장바구니 >
<img width="775" height="401" alt="image" src="https://github.com/user-attachments/assets/17b37a85-fc0b-4ef7-9d43-3ee5db623dcd" />
</br>
</br>
</br>

### < 화면 레이아웃 - 주문화면 >
<img width="630" height="586" alt="image" src="https://github.com/user-attachments/assets/26302f9e-105a-4da2-8e0d-9620920f71ed" />
</br>
</br>
</br>

### 프로세스 (5/6) : 쇼핑몰 주문관리 구축하기 #2
</br>

### < Primary Key 종류 >
- 1. 자동순번 : 데이터베이스에서 자동으로 증가하는 순번으로, 주로 숫자 형식
  2. 단일키 : 하나의 속성을 기본 키로 사용
  3. 복합키 : 두 개 이상의 속성 또는 열을 결합하여 기본 키로 사용
</br>

### < Customers >

```mermaid
erDiagram
    Customers ||--o{ Orders : places
    Customers ||--o{ ShippingAddress : has
    Customers ||--o{ Cart : owns

    Customers {
        int id PK
    }

    Orders {
        int id PK
        int customerId FK
    }

    ShippingAddress {
        int id PK
        int customerId FK
    }

    Cart {
        int id PK
        int customerId FK
    }

```
</br>

### < Orders >
- 주문 버튼을 클릭하면 Cart에서 선택된 상품만 OrderItems로 옮겨짐. 따라서 Orders와 Cart는 직접적인 연관은 없음.
```mermaid
erDiagram
    Orders ||--o| ShippingAddress : uses
    Orders ||--o{ OrderItems : contains

    Orders {
        int id PK
    }

    ShippingAddress {
        int id PK
        int orderId FK
    }

    OrderItems {
        int id PK
        int orderId FK
    }

    Cart {
        int id PK
    }
```
</br>

### < Products >
```mermaid
erDiagram
    Products ||--o{ Cart : listed_in
    Products ||--o{ OrderItems : has

    Products {
        int id PK
    }

    OrderItems {
        int id PK
        int productId FK
    }

    Cart {
        int id PK
        int productId FK
    }
```
</br>

### < 결과 >
```mermaid
erDiagram
    Customers ||--o{ Orders : places
    Customers ||--o{ ShippingAddress : has
    Customers ||--o{ Cart : owns
    Orders ||--o| ShippingAddress : uses
    Orders ||--o{ OrderItems : contains
    Products ||--o{ Cart : listed_in
    Products ||--o{ OrderItems : has

    Customers {
        int id PK
    }

    Orders {
        int id PK
        int customerId FK
        int shippingAddressId FK
    }

    ShippingAddress {
        int id PK
        int customerId FK
    }

    Cart {
        int id PK
        int customerId FK
        int productId FK
    }

    OrderItems {
        int id PK
        int orderId FK
        int productId FK
    }

    Products {
        int id PK
    }
```
</br>
</br>

---

### 프로세스 (6/6) : 쇼핑몰 주문관리 구축하기 #3
</br>

### < 엔티티 구성 >
</br>

### < Customers 테이블 >
<img width="445" height="265" alt="image" src="https://github.com/user-attachments/assets/8b0735b0-5a69-418a-ae5c-926d71d156a7" />
</br>
</br>
</br>

### < Order 테이블 >
<img width="518" height="450" alt="image" src="https://github.com/user-attachments/assets/98ec8326-2aea-4932-83c2-28c5c67d65ad" />
</br>
</br>
</br>

### < ShippingAddress 테이블 >
<img width="455" height="376" alt="image" src="https://github.com/user-attachments/assets/f97cc4b9-dd95-4953-a660-bb3f7196c1cf" />
</br>
</br>
</br>

### < Cart 테이블 >
<img width="516" height="410" alt="image" src="https://github.com/user-attachments/assets/c1e1ad1f-5d79-4682-8b2e-d80720a30fb6" />
</br>
</br>
</br>

### < OrderItems 테이블 >
<img width="422" height="226" alt="image" src="https://github.com/user-attachments/assets/6ad1edde-4bce-4275-beb9-0d4d7355ca23" />
</br>
</br>
</br>

### < Products 테이블 >
<img width="448" height="300" alt="image" src="https://github.com/user-attachments/assets/5442fe73-3c37-44a4-913b-332c94a1008c" />
</br>
</br>
</br>

### < orderStatus - 코드로 관리하는 방법 >
- 장점 :
- 1. 데이터 일관성 : 숫자나 상수를 사용하면 데이터의 일관성을 더 잘 유지할 수 있음.
  2. 데이터 크기 절약 : 문자열보다는 숫자나 상수를 사용하는 것이 데이터베이스 공간을 더 효율적으로 사용할 수 있음.
  3. 빠른 검색 속도 : 코드를 사용하면 데이터 조회 속도가 일반적으로 더 빠름.
  4. 국제화 용이 : 상태를 코드로 관리하면 다국어 환경에서의 변환이 쉬움. 예를 들어, '1'을 "배송중", "Shipping", "出荷中" 등으로 쉽게 매핑할 수 있음.
- 단점 :
- 1. 가독성 저하 : 코드 자체로는 의미를 바로 알기 어려워, 주석이나 문서가 필요.
  2. 유지보수 비용: 상태가 추가되거나 변경될 때마다, 해당 코드를 이해하고 있는 개발자가 수정해야 하므로 유지보수 비용이 발생할 수 있음.
</br>

- 추가 : 대응되는 테이블
</br>

<img width="155" height="229" alt="image" src="https://github.com/user-attachments/assets/48226769-3d13-4771-bb61-5bfb02b27fee" />
- 이런 식으로 'OrderStatus' 테이블을 따로 만들고, 해당 테이블의 '코드'와 '설명'을 매핑 가능. 이렇게 하면 'Orders' 테이블의 'orderStatus' 필드는 이 테이블의 '코드'를 참조할 수 있음.

</br>
</br>

### < orderStatus - 문자열로 관리하는 방법 >
- 장점 :
- 1. 가독성: 상태가 무엇인지 바로 알 수 있음.
  2. 직관적: 코드를 별도로 확인할 필요가 없으므로, 비개발자나 새로운 개발자에게도 직관적.
- 단점 :
- 1. 데이터 일관성: 문자열이므로 오타나 다른 문제로 인해 데이터 일관성을 잃을 위험이 있음.
  2. 데이터 크기 증가: 문자열을 사용하면 데이터베이스에 더 많은 공간이 필요.
  3. 검색 속도 저하: 문자열 검색은 일반적으로 코드 검색보다 느림.
  4. 국제화 어려움: 다양한 언어로의 변환이 어려움. 예를 들어, "배송중"을 다른 언어로 번역해야 할 경우 문제가 될 수 있음.

</br>
</br>

### < 캐시 적립 - CashBackHistory 테이블 >
<img width="517" height="301" alt="image" src="https://github.com/user-attachments/assets/0db4d2e0-3197-414c-9320-c3208ee33da6" />
</br>
</br>
</br>

### < 캐시 적립 - Customers 테이블 반정규화 >
- cashBack 필드가 Customers 테이블에 추가됨으로써, 고객 정보를 조회할 때마다 CashBackHistory 테이블을 참조하여 캐시백 금액을 계산할 필요가 없어짐. 이는 특히 빈번한 조회가 발생하는 서비스에서 성능 향상을 가져올 수 있음.
<img width="452" height="301" alt="image" src="https://github.com/user-attachments/assets/52456041-7629-4f31-889c-b72aa7f80b72" />
</br>
</br>
</br>

- 장점 :
- 1. 쿼리 성능이 향상될 수 있음.
  2. 캐시백 누적 금액을 빠르게 확인할 수 있음.
  3. 서비스 로직이 간단해질 수 있음.
- 단점 :
- 1. CashBackHistory 테이블과 Customers 테이블 사이의 데이터 무결성을 유지하기 어려움.
  2. 캐시백이 적립되거나 사용될 때, 두 테이블을 모두 업데이트 해야 함.
  3. 데이터가 중복되므로 저장 공간이 더 필요할 수 있음.
</br>

* cashBack는 CashBackHistory의 데이터를 계산해서 사용할 수 있으나, 이 방법은 실시간으로 누적 금액을 계산해야 하므로 성능 저하를 가져올 수 있음. 또한, 누적 금액이 자주 변경될 경우 계산 로직이 복잡해질 수 있음. 따라서 반정규화를 통해 이러한 단점을 상쇄할 수 있음. 하지만 이것이 반드시 좋은 방법이라고 할 수 없으며, 시스템의 특성과 요구사항에 따라 적절히 판단해야 함.

</br>
</br>

### < 인덱스 작성 시 주의사항 >
- 선택도(Selectivity) : 선택도가 높은 컬럼은 인덱스로 좋은 후보.
- 읽기와 쓰기의 비율 : 읽기가 빈번하다면 인덱스 추가가 유리.
- 인덱스의 크기 : 컬럼의 크기가 클 경우 인덱스 관리 비용이 증가.
- 복합 인덱스 : 컬럼의 순서가 중요. (선택도가 높은 컬럼을 먼저)
- 정렬 순서: 오름차순, 내림차순도 쿼리 성능에 영향을 줌.
- 과도한 인덱스: 쓰기 성능 저하와 디스크 공간 문제가 발생할 수 있음.
- 인덱스 갱신: 데이터 변경 시 인덱스도 갱신되어 성능에 부하가 있을 수 있음.
- 비트맵 인덱스: 낮은 카디널리티 컬럼의 경우 비트맵 인덱스 등의 특별한 인덱스 유형을 고려할 수 있음. (주로 읽기 작업이 많은 OLAP 환경에서 유용)
- 데이터 양: 데이터 양이 적더라도 특정 쿼리 성능이 중요하다면 인덱스를 고려.
- 변경이 많은 필드: 데이터가 자주 변경되면 인덱스 오버헤드가 발생할 수 있음.
- 클러스터링된 인덱스: 변경이 적고 검색이 많은 필드에 대해서는 클러스터링된 인덱스를 고려.
- 배치 작업: 변경이 주로 되며 배치 작업이 많은 테이블의 경우 인덱스를 피함. (배치 작업 전후로 인덱스를 재구성하는 전략을 고려할 수 있음)
