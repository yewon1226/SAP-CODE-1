# SQL 문법
### SQL 문법 (1/4) : 데이터 조회(SELECT) 
</br>

### <데이터 조회(SELECT)>
- 데이터 조작어(DML)이며, 데이터 분석에서 가장 많이 사용되는 명령어
<img width="940" height="285" alt="image" src="https://github.com/user-attachments/assets/ab3d35ff-bd0a-4496-9d08-73b0ffea5ff9" />
</br>
</br>
</br>

### <데이터 조회(SELECT)와 여러 절들>
- SELECT는 여러 절들과 함께 사용되어, 분석에 필요한 데이터를 조회
- 절: FROM, WHERE, GROUP BY, HAVING, ORDER BY
<img width="912" height="420" alt="image" src="https://github.com/user-attachments/assets/98849b10-9818-43c2-9e94-9be199aa538a" />
</br>
</br>
</br>

### <FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY>
- FROM -> WHERE -> GROUP BY 순으로 실행
- FROM -> GROUP BY 순으로도 작성 가능
- FROM: 테이블 확인
- WHERE: FROM절 테이블을 특정 조건으로 필터링
- GROUP BY: 열 별로 그룹화
- HAVING: 그룹화된 새로운 테이블을 특정 조건으로 필터링
- SELECT: 열 선택
- ORDER BY: 열 정렬
<img width="940" height="256" alt="image" src="https://github.com/user-attachments/assets/62153ff6-df2f-4634-8d34-32a7dfdb61d4" />
<img width="940" height="237" alt="image" src="https://github.com/user-attachments/assets/bbf63b66-2b96-4aef-86be-27f237051238" />
</br>
</br>
</br>

### <GROUP BY + 집계함수>
- GROUP BY는 집계함수와 주로 사용되는 명령어
- 여러 열 별로 그룹화가 가능
- GROUP BY에 있는 열들을 SELECT에도 작성해야 원하는 분석 결과를 확인 가능
<img width="940" height="222" alt="image" src="https://github.com/user-attachments/assets/9694bfa2-8bed-4350-bb38-d3e7a9043912" />
</br>
</br>
</br>

### <SQL 명령어 작성법>
- SQL 명령어를 보기 좋게 작성하기 위해서는 SPACE 및 TAB 키보드를 잘 활용해야 함
<img width="742" height="484" alt="image" src="https://github.com/user-attachments/assets/180cf115-7f04-4c4e-8502-35e5d72811b2" />

</br>
</br>

</br>
</br>

### 1. FROM
- 데이터를 가져올 테이블 지정
```sql
SELECT 컬럼명 FROM 테이블명;
```
```sql
SELECT * FROM CUSTOMER;   // CUSTOMER 테이블 전체 조회
```
</br>

### 2. WHERE
- 특정 조건으로 행(Row) 필터링
```sql
SELECT 컬럼명 FROM 테이블명 WHERE 조건;
```
```sql
SELECT * FROM CUSTOMER WHERE GENDER = 'MAN';  // 성별이 남성만 조회
```
</br>

### 3. GROUP BY
- 같은 값을 가진 행들을 묶어 그룹화 (집계함수와 함께 사용)
- GROUP BY 뒤에 작성된 열은 SELECT 뒤에도 작성
```sql
SELECT 그룹컬럼, 집계함수(컬럼) FROM 테이블명 GROUP BY 그룹컬럼;
```
```sql
SELECT  ADDR
	,COUNT(MEM_NO) AS 회원수
  FROM  CUSTOMER
 WHERE  GENDER = 'MAN'
 GROUP
    BY  ADDR;    // 지역별 회원 수 집계
```
</br>

### 4. COUNT (집계 함수)
- 행(Row)의 개수를 계산
```sql
COUNT(컬럼명)
```
```sql
SELECT COUNT(*) FROM CUSTOMER;                             // 전체 회원 수
SELECT ADDR, COUNT(MEM_NO) FROM CUSTOMER GROUP BY ADDR;    // 지역별 회원 수
```
</br>

### 5. HAVING
- 그룹화된 결과에 조건 적용 (집계 결과 필터링)
```sql
SELECT 그룹컬럼, 집계함수(컬럼)
  FROM 테이블명
 GROUP BY 그룹컬럼
HAVING 집계조건;
```
```sql
SELECT  ADDR
	,COUNT(MEM_NO) AS 회원수
  FROM  CUSTOMER
 WHERE  GENDER = 'MAN'
 GROUP
    BY  ADDR
HAVING  COUNT(MEM_NO) < 100;    // 회원수가 100 미만인 지역만
```
</br>

### 6. ORDER BY
- 조회 결과 정렬 (ASC: 오름차순, DESC: 내림차순)
- ASC → 오름차순 (기본값, 작은 값 → 큰 값)
- DESC → 내림차순 (큰 값 → 작은 값)
```sql
SELECT 컬럼명 FROM 테이블명 ORDER BY 컬럼명 ASC|DESC;
```
```sql
SELECT NAME, AGE FROM CUSTOMER ORDER BY AGE ASC;   // 나이 오름차순
SELECT NAME, AGE FROM CUSTOMER ORDER BY AGE DESC;  // 나이 내림차순
```
</br>

### 7. IN (특수 연산자)
- 특정 값이 리스트 안에 있는지 확인
```sql
컬럼명 IN (값1, 값2, 값3)
```
```sql
SELECT * FROM CUSTOMER WHERE ADDR IN ('SEOUL','INCHEON');		// 거주지역을 서울, 인천 조건으로 필터링

SELECT  ADDR
	,GENDER
	,COUNT(MEM_NO) AS 회원수
  FROM  CUSTOMER
 WHERE  ADDR IN ('SEOUL', 'INCHEON')
 GROUP
    BY  ADDR
	,GENDER;			// 거주지역을 서울, 인천 조건으로 필터링, 거주지역 및 성별로 회원수 집계
```
</br>
</br>

### - 예제
```sql
USE PRACTICE;

/***************FROM***************/

/* Customer 테이블 모든 열 조회 */
SELECT  *
  FROM  CUSTOMER;


/***************WHERE***************/

/* 성별이 남성 조건으로 필터링 */
SELECT  *
  FROM  CUSTOMER
 WHERE  GENDER = 'MAN';
 
 
/***************GROUP BY***************/

/* 지역별로 회원수 집계 */
SELECT  ADDR
		,COUNT(MEM_NO) AS 회원수
  FROM  CUSTOMER
 WHERE  GENDER = 'MAN'
 GROUP
    BY  ADDR;
    
/* COUNT: 행들의 개수를 구하는 집계함수 */


/***************HAVING***************/

/* 집계 회원수 100명 미만 조건으로 필터링 */
SELECT  ADDR
		,COUNT(MEM_NO) AS 회원수
  FROM  CUSTOMER
 WHERE  GENDER = 'MAN'
 GROUP
    BY  ADDR
HAVING  COUNT(MEM_NO) < 100;
    
/* < : 비교 연산자 / ~ 보다 작은*/


/***************ORDER BY***************/

/* 집계 회원수가 높은 순으로 */
SELECT  ADDR
		,COUNT(MEM_NO) AS 회원수
  FROM  CUSTOMER
 WHERE  GENDER = 'MAN'
 GROUP
    BY  ADDR
HAVING  COUNT(MEM_NO) < 100
 ORDER
	BY  COUNT(MEM_NO) DESC;
    
/* DESC : 내림차순 / ASC : 오름차순 */


/***************FROM -> (WHERE) -> GROUP BY***************/

/* FROM -> GROUP BY 순으로 작성해도 됩니다. */
SELECT  ADDR
		,COUNT(MEM_NO) AS 회원수
  FROM  CUSTOMER
/* WHERE  GENDER = 'MAN' */
 GROUP
    BY  ADDR;


/***************GROUP BY + 집계함수***************/
/* 거주지역을 서울, 인천 조건으로 필터링 */
/* 거주지역 및 성별로 회원수 집계 */
SELECT  ADDR
		,GENDER
		,COUNT(MEM_NO) AS 회원수
  FROM  CUSTOMER
 WHERE  ADDR IN ('SEOUL', 'INCHEON')
 GROUP
    BY  ADDR
		,GENDER;

/* IN : 특수 연산자 / IN (List) / 리스트 값만 */

/* GROUP BY에 있는 열들을 SELECT에도 작성해야 원하는 분석 결과를 확인할 수 있습니다. */
SELECT  GENDER
		,COUNT(MEM_NO) AS 회원수
  FROM  CUSTOMER
 WHERE  ADDR IN ('SEOUL', 'INCHEON')
 GROUP
    BY  ADDR
		,GENDER;
        

/***************SQL 명령어 작성법***************/
/* 회원테이블(Customer)을 */
/* 성별이 남성 조건으로 필터링하여 */
/* 거주지역별로 회원수 집계 */
/* 집계 회원수 100명 미만 조건으로 필터링 */
/* 모든 열 조회 */
/* 집계 회원수가 높은 순으로 */

SELECT  ADDR
		,COUNT(MEM_NO) AS 회원수
  FROM  CUSTOMER
 WHERE  GENDER = 'MAN'
 GROUP
    BY  ADDR
HAVING  COUNT(MEM_NO) < 100
 ORDER
    BY  COUNT(MEM_NO) DESC;
```
</br>

---

### SQL 문법 (2/4) : 테이블 결합(JOIN)
</br>

### 테이블결합(JOIN)
- 관계는 1:1, 1:N, N:N 세가지 형태로, 테이블 간의 연결이 가능하다는 것을 의미
- 테이블결합(JOIN)은 두 테이블 관계를 활용하여, 테이블을 결합하는 명령어
<img width="959" height="224" alt="image" src="https://github.com/user-attachments/assets/bcd847be-9b1b-482f-abb7-bc894c97188d" />
</br>
</br>
</br>

### ERM(Entity-Relationship Modelling)
- ERM(Entity-Relationship Modelling)은 개체-관계 모델링이며, 관계형 데이터베이스에 테이블을 모델링할 때 사용
- 개체(Entity): 하나 이상의 속성(Attribute)으로 구성된 개체 
- 관계(Relationship): 속성(Entity)들 간의 관계
<img width="940" height="353" alt="image" src="https://github.com/user-attachments/assets/06271e0c-1b6f-472f-9fcd-a12cc58f14b7" />
</br>
</br>
</br>

### ERD(Entity-Relationship Diagram)
- ERD(Entity-Relationship Diagram)은 개체 간의 관계를 도표로 표현할 때 사용
- FK(FOREIGN KEY) : 다른 테이블에서 PK(PRIMARY KEY) (Ex. 주문테이블의 회원번호는 회원테이블의 PK)
<img width="866" height="343" alt="image" src="https://github.com/user-attachments/assets/06a2abd4-f9cc-44de-9e1d-b2cd87f08fb8" />
</br>
</br>
</br>

### INNER, LEFT, RIGHT JOIN
- Inner Join: 두 테이블의 공통 값이 매칭되는 데이터만 결합
- left Join: 두 테이블의 공통 값이 매칭되는 데이터만 결합 + 왼쪽 테이블의 매칭되지 않는 데이터는 NULL
- Right Join: 두 테이블의 공통 값이 매칭되는 데이터만 결합+ 오른쪽 테이블의 매칭되지 않는 데이터는 NULL
<img width="940" height="347" alt="image" src="https://github.com/user-attachments/assets/a1e10349-bfc0-4d64-9d1e-5a7ad087bddc" />
</br>
</br>
</br>

### 테이블결합(JOIN) + 데이터조회(SELECT)
- 테이블 결합(JOIN) 및 데이터 조회(SELECT)를 활용하여, 여러 테이블들을 결합하여 조회 및 분석
- 테이블 결합(JOIN)은 3가지 이상 테이블 결합이 가능
<img width="940" height="399" alt="image" src="https://github.com/user-attachments/assets/0dd92d91-b5ab-4db1-b8dd-f5cc81817df1" />
</br>
</br>

</br>
</br>

### 1. INNER JOIN
- 두 테이블의 공통 값이 존재하는 행만 결합 (교집합)
```sql
SELECT 컬럼
  FROM 테이블1 AS A
 INNER
  JOIN 테이블2 AS B
    ON A.공통컬럼 = B.공통컬럼;
```
```sql
SELECT  *
  FROM  CUSTOMER AS A
 INNER
  JOIN  SALES AS B
    ON  A.MEM_NO = B.MEM_NO;		// 고객이 주문한 경우만 조회됨 (가입만 하고 주문하지 않은 회원은 제외)
```
</br>

### 2. LEFT JOIN
- 두 테이블의 공통 값이 매칭되는 데이터만 결합 + 왼쪽 테이블의 매칭되는 않는 데이터는 NULL
```sql
SELECT 컬럼
  FROM 테이블1 AS A
  LEFT
  JOIN 테이블2 AS B
    ON A.공통컬럼 = B.공통컬럼;
```
```sql
SELECT  *
  FROM  CUSTOMER AS A
  LEFT
  JOIN  SALES AS B
    ON  A.MEM_NO = B.MEM_NO;
```
</br>

### 3. RIGHT JOIN
- 두 테이블의 공통 값이 매칭되는 데이터만 결합 + 오른쪽 테이블의 매칭되는 않는 데이터는 NULL
```sql
SELECT 컬럼
  FROM 테이블1 AS A
 RIGHT
  JOIN 테이블2 AS B
    ON A.공통컬럼 = B.공통컬럼;
```
```sql
SELECT  *
  FROM  CUSTOMER AS A
  RIGHT
  JOIN  SALES AS B
    ON  A.MEM_NO = B.MEM_NO
 WHERE  A.MEM_NO IS NULL;
```

</br>
</br>

### - 예제
```sql
USE PRACTICE;

/***************INNER JOIN***************/
/* INNER JOIN: 두 테이블의 공통 값이 매칭되는 데이터만 결합customer */

/* Customer + Sales Inner JOIN */
SELECT  *
  FROM  CUSTOMER AS A
 INNER
  JOIN  SALES AS B
    ON  A.MEM_NO = B.MEM_NO;

/* Customer 및 Sales 테이블은 mem_no(회원번호) 기준으로 1:N 관계 */
SELECT  *
  FROM  CUSTOMER AS A
 INNER
  JOIN  SALES AS B
    ON  A.MEM_NO = B.MEM_NO
 WHERE  A.MEM_NO = '1000970';
 
 
/***************LEFT JOIN***************/
/* LEFT JOIN: 두 테이블의 공통 값이 매칭되는 데이터만 결합 + 왼쪽 테이블의 매칭되는 않는 데이터는 NULL */

/* Customer + Sales LEFT JOIN */
SELECT  *
  FROM  CUSTOMER AS A
  LEFT
  JOIN  SALES AS B
    ON  A.MEM_NO = B.MEM_NO;

/* NULL은 회원가입만하고 주문은 하지 않는 회원을 의미 */


/***************RIGHT JOIN***************/
/* RIGHT JOIN: 두 테이블의 공통 값이 매칭되는 데이터만 결합 + 오른쪽 테이블의 매칭되는 않는 데이터는 NULL */

/* Customer + Sales RIGHT JOIN */
SELECT  *
  FROM  CUSTOMER AS A
  RIGHT
  JOIN  SALES AS B
    ON  A.MEM_NO = B.MEM_NO
 WHERE  A.MEM_NO IS NULL;

/* 회원번호(9999999)는 비회원 */
/* IS NULL: 비교 연산자 / NULL인 값만 */


/***************테이블 결합(JOIN) + 데이터 조회(SELECT)***************/

/* 회원(Customer) 및 주문(Sales) 테이블 Inner JOIN 결합 */
SELECT  *
  FROM  CUSTOMER AS A
 INNER
  JOIN  SALES AS B
    ON  A.MEM_NO = B.MEM_NO;

/* 임시테이블 생성 */
CREATE TEMPORARY TABLE CUSTOMER_SALES_INNER_JOIN
SELECT  A.*
		,B.ORDER_NO
  FROM  CUSTOMER AS A
 INNER
  JOIN  SALES AS B
    ON  A.MEM_NO = B.MEM_NO;

/* 임시테이블 조회 */
SELECT * FROM CUSTOMER_SALES_INNER_JOIN;

/* 임시테이블(TEMPORARY TABLE)은 서버 연결 종료시 자동으로 삭제됩니다. */
   

/* 성별이 남성 조건으로 필터링하여 */
SELECT  *
  FROM  CUSTOMER_SALES_INNER_JOIN
 WHERE  GENDER = 'MAN';


/* 거주지역별로 구매횟수 집계 */
SELECT  ADDR
		,COUNT(ORDER_NO) AS 구매횟수
  FROM  CUSTOMER_SALES_INNER_JOIN
 WHERE  GENDER = 'MAN'
 GROUP
    BY  ADDR;


/* 구매횟수 100회 미만 조건으로 필터링 */
SELECT  ADDR
		,COUNT(ORDER_NO) AS 구매횟수
  FROM  CUSTOMER_SALES_INNER_JOIN
 WHERE  GENDER = 'MAN'
 GROUP
    BY  ADDR
HAVING  COUNT(ORDER_NO) < 100;


/* 모든 열 조회 */
/* 구매횟수가 낮은 순으로 */
SELECT  ADDR
		,COUNT(ORDER_NO) AS 구매횟수
  FROM  CUSTOMER_SALES_INNER_JOIN
 WHERE  GENDER = 'MAN'
 GROUP
    BY  ADDR
HAVING  COUNT(ORDER_NO) < 100
 ORDER
    BY  COUNT(ORDER_NO) ASC;
    
    
/***************3개 이상 테이블 결합***************/
/* 주문(Sales) 테이블 기준, 회원(Customer) 및 상품(Product) 테이블 LEFT JOIN 결합 */

SELECT  *
  FROM  SALES AS A
  LEFT
  JOIN  CUSTOMER AS B
    ON  A.MEM_NO = B.MEM_NO
  LEFT
  JOIN  PRODUCT AS C
    ON  A.PRODUCT_CODE = C.PRODUCT_CODE;
```
