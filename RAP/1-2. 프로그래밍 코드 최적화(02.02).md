## <  핵심 개념 >
</br>

- **1) `module pool program` 생성 방법 ( 일반 프로그램 생성 방법에서 include 파일 포함 )**
- **2) 모듈풀 프로그램은 무조건 `TCODE` 생성해야 함**

</br>

---

</br>

## < ABAP Expressions(표현식) 기본 개념 정리 >
</br>

### 1) replace
- 문자열에서 지정한 부분(sub)을 다른 문자열(with)로 바꾼 새 문자열을 반환하는 문자열 처리 함수
- 대소문자 구분 여부를 case 옵션으로 제어 가능
- `to_upper( )` → 문자열을 대문자로 변환
```abap
RESULT = replace(
           val  = <원본문자열>
           sub  = <찾을문자열>
           case = abap_false        " 대소문자 구분 안 함
           with = to_upper( <바꿀문자열> )
         ).
```
</br>
</br>

### 2) 문자열 연결 (Concatenation)
- 여러 문자열을 하나로 이어서 새 문자열을 만듦
```abap
*************** 기존 방식 ****************
CONCATENATE gv_var1 gv_var2
  INTO gv_result
  SEPARATED BY <sep>.

*************** 최신 방식 ****************
gv_result = gv_var1 && gv_var2.
```
</br>
</br>

### 3) 문자열 템플릿 (String Templates)
- 문자열 안에 변수나 표현식을 직접 삽입해 새 문자열을 만듦
```abap
*************** 기존 방식 ****************
DATA gv_string TYPE string.
gv_string = |Hello World|.

*************** 최신 방식 ****************
DATA gv_string TYPE string.
PARAMETERS pa_name TYPE string.
gv_string = |Hello { pa_name }|.
```
</br>

**ABAP 문자열 처리(Expression) 함수 목록** 


| 구분 | 함수명 | 한줄 설명 |
|----|-------|---------|
| 비교 | `distance` | 두 문자열 간의 차이(편집 거리)를 계산 |
| 공백 | `condense` | 문자열 내 불필요한 공백을 제거 |
| 결합 | `concat_lines_of` | 내부테이블 여러 줄을 하나의 문자열로 결합 |
| 변환 | `escape` | 특수문자를 이스케이프 처리 |
| 검색 | `find` | 문자열에서 특정 문자열 위치 검색 |
| 검색 | `find_end` | 문자열 끝 기준으로 문자열 검색 |
| 검색 | `find_any_of` | 지정 문자 집합 중 하나라도 포함된 위치 검색 |
| 검색 | `find_any_not_of` | 지정 문자 집합에 속하지 않는 문자 위치 검색 |
| 삽입 | `insert` | 문자열의 특정 위치에 문자열 삽입 |
| 반복 | `repeat` | 문자열을 지정한 횟수만큼 반복 |
| 치환 | `replace` | 문자열의 특정 부분을 다른 문자열로 치환 |
| 변환 | `reverse` | 문자열을 거꾸로 뒤집음 |
| 추출 | `segment` | 문자열의 특정 구간 추출 |
| 정렬 | `shift_left` | 문자열을 왼쪽으로 이동 (공백 제거 가능) |
| 정렬 | `shift_right` | 문자열을 오른쪽으로 이동 |
| 추출 | `substring` | 문자열의 일부 추출 |
| 추출 | `substring_from` | 지정 위치부터 끝까지 문자열 추출 |
| 추출 | `substring_before` | 특정 문자열 이전 부분 추출 |
| 추출 | `substring_after` | 특정 문자열 이후 부분 추출 |
| 추출 | `substring_to` | 시작부터 지정 위치까지 문자열 추출 |
| 대소문자 | `to_upper` | 문자열을 대문자로 변환 |
| 대소문자 | `to_lower` | 문자열을 소문자로 변환 |
| 대소문자 | `to_mixed` | 문자열을 혼합 대소문자 형식으로 변환 |
| 대소문자 | `from_mixed` | 혼합 대소문자를 일반 문자열로 변환 |
| 변환 | `translate` | 특정 문자들을 다른 문자로 일괄 변환 |
| 비교 | `matches` | 문자열이 패턴과 일치하는지 확인 |
| 비교 | `contains` | 문자열에 특정 문자열 포함 여부 확인 |
</br>

**ABAP 문자열 처리 함수 공통 파라미터 (Standard Arguments)**

| 파라미터 | 의미 | 설명 |
|--------|----|----|
| `val` | 대상 문자열 | 처리할 원본 문자열 |
| `sub` | 부분 문자열 | 찾거나(replace/find) 치환할 문자열 |
| `case` | 대소문자 구분 | 대소문자 구분 여부 (`abap_true` / `abap_false`) |
| `occ` | 발생 횟수 | 몇 번째 발생 위치를 대상으로 할지 지정 |
| `off` | 오프셋 | 문자열 내 시작 위치 |
| `len` | 길이 | 처리할 문자열 길이 |
| `regex` | 정규식 | 찾기·치환·매칭에 사용할 정규 표현식 |

</br>
</br>

### 4) SET COUNTRY / DATE FORMAT
- 국가(로케일) 기준에 맞게 날짜·숫자 등의 출력 형식을 설정하는 환경 설정 명령
```abap
SET COUNTRY 'US'.
SET DATE FORMAT 'ENVIRONMENT'.
```
</br>
</br>

### 5) ABAP Inline Data Declarations 정리
- 변수를 미리 선언하지 않고, 사용하는 위치에서 DATA( )로 바로 선언하는 ABAP 최신 문법
- Inline DATA는 타입을 추론할 수 있는 위치에서만 가능. 일반 대입문에서는 불가능.
- `IMPORTING` , `RECEIVING` , `INTO` , `CATCH` 처럼 값을 받는 쪽 에서만 가능
```abap
*************** INTO 구문 ****************
LOOP AT gt_itab INTO DATA(gs_line).
READ TABLE gt_itab INTO DATA(gs_line).
SELECT * FROM sflight INTO TABLE DATA(gt_tab).

*************** ASSIGNING 구문 ****************
LOOP AT gt_itab ASSIGNING FIELD-SYMBOL(<fs>).
READ TABLE gt_itab ASSIGNING FIELD-SYMBOL(<fs>).

*************** 메서드 파라미터 ****************
CALL METHOD obj->method
  IMPORTING ev_value = DATA(lv_val).

*************** 예외 처리 ****************
TRY.
  " 로직
CATCH cx_root INTO DATA(lo_exc).
ENDTRY.
```
```abap
*************** 예외 처리 ****************
DATA gx_excp TYPE REF TO cx_sy_move_cast_error.           " 기존 방식
TRY.
  go_oref2 ?= go_oref1.
CATCH cx_sy_move_cast_error INTO gx_excp.
ENDTRY.

TRY.
  go_oref2 ?= go_oref1.
CATCH cx_sy_move_cast_error INTO DATA(gx_excp).           " 최신 방식
ENDTRY.

*************** 내부테이블 + Work Area (LOOP) ****************
DATA gs_line TYPE LINE OF gt_itab.            " 기존 방식
LOOP AT gt_itab INTO gs_line.
  " 로직
ENDLOOP.

LOOP AT gt_itab INTO DATA(gs_line).           " 최신 방식
  " 로직
ENDLOOP.

*************** 내부테이블 + Work Area (READ) ****************
DATA gs_line TYPE LINE OF gt_itab.
READ TABLE gt_itab INTO gs_line INDEX n.                 " 기존 방식

READ TABLE gt_itab INTO DATA(gs_line) INDEX n.           " 최신 방식

*************** 메서드 IMPORTING 파라미터 ****************
DATA go_alv TYPE REF TO cl_salv_table.           " 기존 방식
cl_salv_table=>factory(
  IMPORTING
    r_salv_table = go_alv
  CHANGING
    t_table      = gt_data
).

cl_salv_table=>factory(
  IMPORTING
    r_salv_table = DATA(go_alv)                  " 최신 방식
  CHANGING
    t_table      = gt_data
).

*************** 필드심볼 LOOP ****************
FIELD-SYMBOLS <line> TYPE LINE OF gt_itab.                 " 기존 방식
LOOP AT gt_itab ASSIGNING <line>.
  " 로직
ENDLOOP.

LOOP AT gt_itab ASSIGNING FIELD-SYMBOL(<line>).           " 최신 방식
  " 로직
ENDLOOP.

*************** 필드심볼 READ ****************
FIELD-SYMBOLS <line> TYPE LINE OF gt_itab.
READ TABLE gt_itab ASSIGNING <line> INDEX n.                         " 기존 방식

READ TABLE gt_itab ASSIGNING FIELD-SYMBOL(<line>) INDEX n.           " 최신 방식
```
</br>
</br>

---

</br>


## < ABAP 최신 문법 – Expressions(표현식) >
</br>

### 1) NEW( ) 객체 생성
- 객체를 생성해 참조 변수에 할당하는 ABAP Expression 기반 객체 생성 문법
- 기존 `CREATE OBJECT` 를 `NEW( )` 표현식으로 대체 가능
```abap
*************** 기존 방식 ****************
DATA: go_custom TYPE REF TO cl_gui_custom_container,
      go_alv    TYPE REF TO cl_gui_alv_grid.
CREATE OBJECT go_custom
  EXPORTING container_name = 'CUSTOM100'.
CREATE OBJECT go_alv
  EXPORTING i_parent = go_custom.

*************** 최신 방식 ****************
DATA: go_custom TYPE REF TO cl_gui_custom_container,
      go_alv    TYPE REF TO cl_gui_alv_grid.
go_custom = NEW #( container_name = 'CUSTOM100' ).
go_alv    = NEW #( i_parent = go_custom ).

*************** 최신 방식 (Explicit Type 지정) ****************
DATA: go_custom TYPE REF TO cl_gui_custom_container,
      go_alv    TYPE REF TO cl_gui_alv_grid.
go_custom = NEW cl_gui_custom_container( container_name = 'CUSTOM100' ).
go_alv = NEW cl_gui_alv_grid( i_parent = go_custom ).

*************** 최신 방식 (중첩 NEW) ****************
DATA go_alv TYPE REF TO cl_gui_alv_grid.
go_alv = NEW cl_gui_alv_grid( i_parent = NEW cl_gui_custom_container( container_name = 'CUSTOM100' ) ).
```
</br>
</br>

### 2) CAST( ) / INSTANCE OF / CASE TYPE OF
- `CAST( )` : 참조 타입을 명시적으로 변환
- `INSTANCE OF` : 객체가 특정 타입인지 검사
- `CASE TYPE OF` : 객체 타입에 따라 분기 + 자동 캐스팅
```abap
*************** CAST( ) 기존 방식 ****************
DATA: gt_ddic_fields  TYPE ddfields,
      go_typedescr    TYPE REF TO cl_abap_typedescr,
      go_structdescr TYPE REF TO cl_abap_structdescr.
go_typedescr = cl_abap_typedescr=>describe_by_name( 'SFLIGHT' ).
go_structdescr ?= go_typedescr.
gt_ddic_fields = go_structdescr->get_ddic_fields( ).

*************** CAST( ) 최신 방식 ****************
DATA gt_ddic_fields TYPE ddfields.
gt_ddic_fields = CAST cl_abap_structdescr(
    cl_abap_typedescr=>describe_by_name( 'SFLIGHT' )
  )->get_ddic_fields( ).

*************** INSTANCE OF 기존 방식 ****************
DATA: go_vehicle TYPE REF TO cl_vehicle,
      go_truck   TYPE REF TO cl_truck,
      go_class   TYPE REF TO cl_abap_classdescr.
CREATE OBJECT go_truck.
go_vehicle = go_truck.
go_class ?= cl_abap_typedescr=>describe_by_object_ref( go_vehicle ).
IF go_class->get_relative_name( ) = 'CL_TRUCK'.
  go_truck ?= go_vehicle.
ENDIF.

*************** INSTANCE OF 최신 방식 ****************
IF go_vehicle IS INSTANCE OF cl_truck.
  go_truck ?= go_vehicle.
ENDIF.

*************** CASE TYPE OF ****************
CASE TYPE OF go_vehicle.
  WHEN TYPE cl_truck INTO go_truck.
    " 트럭 처리 로직
  WHEN TYPE cl_bus INTO go_bus.
    " 버스 처리 로직
  WHEN OTHERS.
    " 기타 타입 처리
ENDCASE.
```
</br>
</br>

### 3) VALUE( )
- 구조/테이블 값을 즉석에서 만들어 쓰는 문법
- `BASE` 는 기존 값을 유지한 채 일부 필드만 덮어써서 새 값을 만드는 옵션
- `#` 는 타입이 이미 정의돼 있으면 사용하고, 아니면 타입을 직접 써야 함
```abap
*************** 기존 방식 ****************
DATA: gt_range TYPE RANGE OF sflight-carrid,
      gs_range LIKE LINE OF gt_range.
gs_range-sign   = 'E'.   " 제외
gs_range-option = 'EQ'.  " 같음
gs_range-low    = 'UA'.

APPEND gs_range TO gt_range.
class=>method( it_range = gt_range ).

*************** 최신 방식 (VALUE #) ****************
class=>method(
  it_range = VALUE #(
    ( sign   = 'E'
      option = 'EQ'
      low    = 'UA' )
  )
).

*************** 최신 방식 (VALUE + DATA( )) ****************
DATA(gt_range) = VALUE RANGE OF sflight-carrid(
  ( sign   = 'E'
    option = 'EQ'
    low    = 'UA' )
).
class=>method( it_range = gt_range ).

*************** 최신 방식 (VALUE + BASE) ****************
DATA(gt_range2) = VALUE RANGE OF sflight-carrid(
  BASE gt_range
  ( sign   = 'I'
    option = 'CP'   " 패턴 매칭
    low    = 'A*' )
).
class=>method( it_range = gt_range2 ).
```
```abap
REPORT zprogb03_0041.

TYPES: BEGIN OF ty_data,
         id(20)   TYPE c,
         name(20) TYPE c,
       END OF ty_data,
       ty_list TYPE STANDARD TABLE OF ty_data WITH DEFAULT KEY.
DATA: gs_data TYPE ty_data,
      gt_data TYPE TABLE OF ty_data.

****** 변수 선언과 동시에 값 넣기 (itab 버전)
* ty_list TYPE STANDARD TABLE OF ty_data WITH DEFAULT KEY.
* Table type의 경우 위와 같이 형태를 명확하게 지정해야 함
DATA(gt_list) = VALUE ty_list(
 ( id = '001' name = 'KIM' )
 ( id = '002' name = 'LEE' )
 ( id = '003' name = 'PARK' )
).

****** Structure 변수에 값 넣기
*DATA(gs_data) = VALUE ty_data( id = '001' name = 'KIM' ).
gs_data = VALUE #( id = '001' name = 'KIM' ).
gs_data = VALUE #( BASE gs_data name = 'Gildong' ).

****** Internal table 변수에 값 넣기
gt_data = VALUE #(
  ( id = '001' name = 'KIM' )
  ( id = '002' name = 'LEE' )
  ( id = '003' name = 'PARK' )
 ).
gt_data = VALUE #( BASE gt_data
                  ( id = '004' name = 'MOON' )
                 ).

****** 값 출력
cl_demo_output=>display(
  data    = gt_data
  name    = 'Results'
).
```
</br>
</br>

### 4) REF( )
- 데이터 객체의 메모리 참조(주소)를 만들어 반환하는 표현식
- `->*` 는 참조 변수가 가리키는 실제 값을 꺼내는 역참조 연산자
```abap
*************** 기존 방식 ****************
GET REFERENCE OF <data_object> INTO <ref_var>.

*************** 최신 방식 (REF) ****************
<ref_var> = REF #( <data_object> ).
```
```abap
REPORT zprogb03_0041.

DATA: BEGIN OF gs_data,
        carrid   TYPE s_carr_id,
        connid   TYPE s_conn_id,
        fldate   TYPE s_date,
        carrname TYPE s_carrname,
      END OF gs_data.
DATA: ref_all TYPE REF TO data.

gs_data = VALUE #(
  carrid = 'AA' connid = '17' fldate = '20250101'
).

" 메모리 주소만 넘겨주기 (REF)
GET REFERENCE OF gs_data INTO ref_all. " 구문법
ref_all = REF #( gs_data ). " 신문법

" 이 때, ref_all 안에 들어간 주소의 값이 궁금하다면?
WRITE: ref_all->*. " 역참조

" 추가) 필드심볼 사용할 수도 있음
FIELD-SYMBOLS: <fs>.
ASSIGN ref_all->* TO <fs>. " ref_all 메모리 주소를 동일하게 바라봄
```
</br>
</br>

### 5) CONV( )
- 값을 원하는 타입으로 명시적으로 변환해서 전달하는 표현식
```abap
*************** 기존 형식 (타입 지정 후 대입) ****************
DATA <result> TYPE <target_type>.
<result> = <source_value>.

*************** 최신 형식 (CONV 표현식) ****************
RESULT = CONV <target_type>( <source_value> ).
```
```abap
REPORT zprogb03_0041.

TYPES ty_str TYPE C LENGTH 2.
DATA lv_num TYPE I.
lv_num = 100.

" 유연한 변환
DATA(lv_str) = CONV ty_str( lv_num ).
" 엄격한 변환
DATA(lv_str) = EXACT ty_str( lv_num ).

WRITE: lv_str.
```
</br>
</br>

### 6) EXACT( )
- EXACT는 타입 변환을 하되, 값이 정확히 맞을 때만 허용하는 엄격한 변환
- EXACT는 타입 변환보다는 값이 정확한지 체크하는 목적의 표현식
```abap
*************** 기존 형식 (타입 변환 + 사전 체크) ****************
DATA <result> TYPE <target_type>.
<result> = <source_value>.           " 값 손실 가능성 존재 (에러 없음)

*************** 최신 형식 (EXACT 표현식) ****************
RESULT = EXACT <target_type>( <source_value> ).
```
```abap
REPORT zprogb03_0041.

DATA: gv_connid TYPE s_conn_id.
gv_connid = 'ABCD'.
WRITE: gv_connid. "0000 출력 (데이터 소실)

ULINE.

gv_connid = EXACT #( 'ABCD' ). " 데이터 소실이 일어나므로 예외발생
gv_connid = EXACT #( '1234' ). " 데이터 소실이 없으므로 (숫자->숫자형문자) 변환 + 정상 출력
WRITE: gv_connid.
```
</br>
</br>

### 7) CORRESPONDING( )
- 구조가 달라도 필드명이 같은 값만 자동 매핑하는 표현식
- `MOVE-CORRESPONDING` 과 동일한 동작이지만 중간 변수 없이 바로 사용 가능
- `BASE` : 기존 구조의 값을 기본으로 유지하고, 매핑되는 필드만 덮어쓰는 기준값 지정.
- `EXCEPT` : 매핑 대상에서 제외할 필드 지정
```abap
*************** 기존 방식 (MOVE-CORRESPONDING) ****************
MOVE-CORRESPONDING <source_structure> TO <target_structure>.
RESULT = <target_structure>.

*************** 최신 방식 (CORRESPONDING 표현식) ****************
RESULT = CORRESPONDING <target_type>( <source_structure> ).

*************** 최신 방식 (CORRESPONDING + BASE + EXCEPT) ****************
RESULT = CORRESPONDING <target_type>(
  BASE ( <base_structure> )
  <source_structure>
  EXCEPT <field1> <field2>
).
```
```abap
REPORT zprogb03_0041.

DATA: BEGIN OF gs_data,
        carrid   TYPE s_carr_id,
        connid   TYPE s_conn_id,
        fldate   TYPE s_date,
        carrname TYPE s_carrname,
      END OF gs_data.
DATA: gs_carrier TYPE scarr,
      gs_flight  TYPE sflight.

* 간단 실습 !
" 신문법을 사용해서, 아래 필드에 값을 넣어주세요
" gs_carrier 에는 carrid, carrname
" gs_flight 에는 carrid, connid, fldate

gs_carrier = VALUE #( carrid = 'LH' carrname = 'Airline' ).
gs_flight = VALUE #( carrid = 'AA' connid = '400' fldate = sy-datum ).

gs_data = CORRESPONDING #( gs_carrier ).
*gs_data = CORRESPONDING #( gs_flight ). " 기존 데이터 삭제
*gs_data = CORRESPONDING #( BASE ( gs_data ) gs_flight ). " 기존 데이터 유지
gs_data = CORRESPONDING #( BASE ( gs_data ) gs_flight EXCEPT carrid ). " carrid 제외 나머지만 적용

WRITE: gs_data-carrid, gs_data-carrname, gs_data-connid, gs_data-fldate.
```
</br>
</br>

### 8) COND( )
- 조건에 따라 값을 선택해 반환하는 조건 표현식
- `IF … ELSE` 를 한 줄 표현식으로 대체
```abap
*************** 기존 방식 (IF / ELSE) ****************
DATA gv_kind_label TYPE string.
IF <condition>.
  gv_kind_label = <value1>.
ELSE.
  gv_kind_label = <value2>.
ENDIF.

*************** 최신 방식 (COND 표현식) ****************
RESULT = COND <target_type>(
  WHEN <condition> THEN <value1>
  ELSE <value2>
).
```
```abap
REPORT zprogb03_0041.

DATA: BEGIN OF ls_list,
        ID(20) TYPE C,
        name(20) TYPE C,
      END OF ls_list.
DATA: lt_list LIKE TABLE OF ls_list.
DATA: lv_score TYPE I VALUE 88,
      lv_vip TYPE C VALUE 'X'.

" 점수에 따라 등급을 결정해서 변수에 할당
DATA(lv_grade) = COND string(
  WHEN lv_score >= 90 THEN 'A'
  WHEN lv_score >= 80 THEN 'B'
  ELSE 'C'
).

lt_list = VALUE #(
  BASE lt_list " 기존 데이터 (있다면) 유지
  ( id = '001' name = 'BASIC' ) " 무조건 추가
  ( COND #( WHEN lv_vip = 'X' " 조건에 따라 추가
            THEN VALUE #( id = '101' name = 'VIP' )
            ELSE VALUE #( id = '102' name = 'BASIC' )
           )
  )
).
cl_demo_output=>display( lt_list ).
```
</br>
</br>

### 9) SWITCH( )
- 하나의 기준값에 대해 여러 경우를 비교해 값 반환
- `CASE … WHEN` 의 표현식 버전
```abap
*************** 기존 방식 (CASE) ****************
DATA gv_kind_label TYPE string.
CASE <value>.
  WHEN <case1>.
    gv_kind_label = <value1>.
  WHEN <case2>.
    gv_kind_label = <value2>.
  WHEN OTHERS.
    gv_kind_label = <default>.
ENDCASE.

*************** 최신 방식 (SWITCH 표현식) ****************
RESULT = SWITCH <target_type>( <value>
  WHEN <case1> THEN <value1>
  WHEN <case2> THEN <value2>
  ELSE <default>
).
```
```abap
REPORT zprogb03_0041.

DATA: BEGIN OF ls_list,
        ID(20) TYPE C,
        name(20) TYPE C,
      END OF ls_list.
DATA: lt_list LIKE TABLE OF ls_list.
DATA: lv_score TYPE I VALUE 88,
      lv_vip TYPE C VALUE 'X'.

" 점수에 따라 등급을 결정해서 변수에 할당
DATA(lv_grade) = COND string(
  WHEN lv_score >= 90 THEN 'A'
  WHEN lv_score >= 80 THEN 'B'
  ELSE 'C'
).

lt_list = VALUE #(
  BASE lt_list " 기존 데이터 (있다면) 유지
  ( id = '001' name = 'BASIC' ) " 무조건 추가
  ( SWITCH #( lv_vip
              WHEN 'X' THEN VALUE #( id = '101' name = 'VIP' )
              ELSE VALUE #( id = '102' name = 'BASIC' )
            )
  )
).
cl_demo_output=>display( lt_list ).
```
</br>
</br>

---

</br>

## < 실습 코드 >
</br>

### 실습 1
- 엑셀 업로드 연습
```abap
REPORT ZBC400_B03_PRACTICE13.

TYPES: BEGIN OF ts_data,
        ID(20),
        NAME(20),
        AGE(20),
        ADDRESS(20),
       END OF ts_data.


PARAMETERS: pa_file TYPE localfile.
DATA: gt_filename TYPE filetable,
      gv_rc TYPE I,
      gt_excel_data TYPE TABLE OF alsmex_tabline.
DATA: gt_data TYPE TABLE OF ts_data,
      gs_data LIKE LINE OF gt_data.
FIELD-SYMBOLS: <fs> TYPE ANY.
CONSTANTS gc_filters TYPE string VALUE 'EXCEL FILES (*.XLSX)|*.XLSX|EXCEL FILES (*.XLS)|*.XLS|'.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR pa_file.
  cl_gui_frontend_services=>file_open_dialog(
    EXPORTING
      window_title            = '파일찾기'                 " Title Of File Open Dialog
      default_filename        = space                 " Default File Name
      file_filter             = gc_filters                 " File Extension Filter String
      initial_directory       = 'C:'                 " Initial Directory
    CHANGING
      file_table              = gt_filename                 " Table Holding Selected Files
      rc                      = gv_rc                 " Return Code, Number of Files or -1 If Error Occurred
    EXCEPTIONS
      file_open_dialog_failed = 1                " "Open File" dialog failed
      cntl_error              = 2                " Control error
      error_no_gui            = 3                " No GUI available
      not_supported_by_gui    = 4                " GUI does not support this
      others                  = 5
  ).
  IF SY-SUBRC = 0.
    READ TABLE gt_filename INTO pa_file INDEX 1.
  ENDIF.

START-OF-SELECTION.
  IF pa_file IS NOT INITIAL.
    CALL FUNCTION 'ALSM_EXCEL_TO_INTERNAL_TABLE'
      EXPORTING
        filename                = pa_file
        i_begin_col             = 2
        i_begin_row             = 5
        i_end_col               = 5
        i_end_row               = 50
      TABLES
        intern                  = gt_excel_data
      EXCEPTIONS
        inconsistent_parameters = 1
        upload_ole              = 2
        others                  = 3.
    IF SY-SUBRC = 0.
      SORT gt_excel_data BY row col.
      LOOP AT gt_excel_data INTO DATA(gs_excel_data).
        UNASSIGN <fs>.
        ASSIGN COMPONENT gs_excel_data-col OF STRUCTURE gs_data TO <fs>.
        <fs> = gs_excel_data-value.

        AT END OF row.
          APPEND gs_data TO gt_data.
          CLEAR gs_data.
        ENDAT.
      ENDLOOP.
      cl_demo_output=>display( gt_data ).
    ENDIF.
  ENDIF.
```
</br>
</br>

### 실습 2
- 기존 코드를 `VALUE #( )` 으로 바꾸는 실습
```abap
REPORT zd750aw_03_expr_03.


CLASS lcl_flights DEFINITION.
  PUBLIC SECTION.
    TYPES: tt_range   TYPE RANGE OF sflight-carrid,
           tt_flights TYPE STANDARD TABLE OF sflight WITH NON-UNIQUE DEFAULT KEY.
    CLASS-METHODS get_flights IMPORTING it_range          TYPE tt_range
                              RETURNING VALUE(rt_flights) TYPE tt_flights.
ENDCLASS.

CLASS lcl_flights IMPLEMENTATION.
  METHOD get_flights.
    SELECT * FROM sflight INTO TABLE rt_flights WHERE carrid IN it_range.
  ENDMETHOD.
ENDCLASS.


PARAMETERS pa_car TYPE sflight-carrid.

DATA: gt_flights TYPE lcl_flights=>tt_flights,
      go_alv     TYPE REF TO cl_salv_table.


START-OF-SELECTION.
  gt_flights = lcl_flights=>get_flights( VALUE #( ( sign = 'I' option = 'EQ' low = pa_car ) ) ).

  cl_salv_table=>factory(
    IMPORTING
      r_salv_table   = go_alv
    CHANGING
      t_table        = gt_flights ).

  go_alv->display( ).
```
