## <  핵심 개념 >
- **1) ABAP Dictionary 및 CDS 객체 구조**
- **2) SAP UI5 테마 커스터마이징 (TCODE - FIORI LAUNCHPAD : `/n/ui2/flp`), TCODE - 테마 : `/n/ui5/theme_designer`)**
- **3) Eclipse에서 ABAP 패키지 생성 절차**
- **4) Eclipse에서 Domain 생성 절차**
- **5) `Ctrl + Shift + F` : Pretty Print**
</br>
</br>

---

</br>

## < ABAP 타입 정의 위치별 차이와 Nested/Flat 구조 비교 >

</br>

#### 1) Global Class에서 정의한 타입
- 클래스 내부 TYPES는 사용할 때 `=>` 로 접근
```abap
CLASS cl_class DEFINITION.
  PUBLIC SECTION.
    TYPES the_type TYPE c LENGTH 10.
ENDCLASS.

DATA var1 TYPE cl_class=>the_type.
```

#### 2) Global Interface에서 정의한 타입
- 인터페이스 내부 TYPES도 `=>` 로 접근
```abap
INTERFACE if_intf.
  TYPES the_type TYPE c LENGTH 10.
ENDINTERFACE.

DATA var2 TYPE if_intf=>the_type.
```

#### 3) ABAP Dictionary (Data Element) 타입
- 딕셔너리 타입은 `=>` 없이 바로 사용
```abap
DATA var3 TYPE zmy_de.
```

#### 4) Data Element (Reference to Class/Interface) 타입
- 딕셔너리에서 참조타입으로 만들면 ABAP에서는 TYPE REF TO와 동일 의미
```abap
TYPES ref_type TYPE REF TO zcl_s4d400_class.
```

#### 5) Data Element (Predefined Type)
- 딕셔너리에서 기본타입(DATS)으로 만들면 ABAP에서는 TYPE d와 동일 의미
```abap
TYPES predef_type TYPE d.
```

#### 6-1) ABAP Dictionary Structure 타입
- 딕셔너리에서 여러 필드를 묶어 하나의 구조 타입 생성
```abap
define structure zs4d430_address {
  street       : /dmo/street;
  postal_code  : /dmo/postal_code;
  city         : /dmo/city;
  country_code : land1;
  status       : abap.char(1);
}
```

#### 6-2) ABAP 코드에서 Structure 타입 정의
- ABAP 소스코드에서는 `BEGIN OF` ~ `END OF` 로 구조 정의
```abap
TYPES:
  BEGIN OF st_address,
    street       TYPE /dmo/street,
    postal_code  TYPE /dmo/postal_code,
    city         TYPE /dmo/city,
    country_code TYPE land1,
    status       TYPE c LENGTH 1,
  END OF st_address.
```

#### 7-1) ABAP Dictionary Nested Structure 타입
- `ls_person-address-city` 처럼 상위-하위-필드로 접근
```abap
define structure zs4d430_person_nested {
  first_name : /dmo/first_name;
  last_name  : /dmo/last_name;
  address    : zs4d430_address;   " 다른 구조 포함
}
```

#### 7-2) ABAP 코드에서 Nested Structure 정의
- `ls_person-address-city` 처럼 구조-구조-필드로 접근
```abap
TYPES:
  BEGIN OF st_person_nested,
    first_name TYPE /dmo/first_name,
    last_name  TYPE /dmo/last_name,
    address    TYPE st_address,   " 구조 안에 구조 포함
  END OF st_person_nested.
```

#### 8-1) ABAP Dictionary Flat Structure 타입
- `ls_person-city` 처럼 바로 필드 접근 가능
```abap
define structure zs4d430_person_flat {
  first_name : /dmo/first_name;
  last_name  : /dmo/last_name;
  address    : include zs4d430_address;      " include z03s_name as name; 도 가능
}
```
#### 8-2) ABAP 코드에서 Flat Structure 정의
- `ls_person-city` 처럼 중간 구조 없이 바로 접근 가능
```abap
TYPES:
  BEGIN OF st_person_flat,
    first_name TYPE /dmo/first_name,
    last_name  TYPE /dmo/last_name,
    INCLUDE TYPE st_address AS address,
  END OF st_person_flat.
```

#### 9-1) ABAP Dictionary Deep Structure 타입 (Table-like Component)
- `ls_person-addresses[ 1 ]-city` 처럼 테이블 인덱스 거쳐 접근
```abap
define structure zs4d430_person_deep {
  first_name : /dmo/first_name;
  last_name  : /dmo/last_name;
  addresses  : zs4d430_t_addresses;   " Table Type
}
```

#### 9-2) ABAP 코드에서 Deep Structure 정의
- `ls_person-addresses[ 1 ]-city` 처럼 내부테이블[ ]-필드 접근
```abap
TYPES:
  BEGIN OF st_person_deep,
    first_name TYPE /dmo/first_name,
    last_name  TYPE /dmo/last_name,
    addresses  TYPE st_addresses,   " 내부 테이블 타입
  END OF st_person_deep.
```
</br>
</br>
</br>

---

</br>

## < Eclipse에서 Type 생성 절차 >
</br>

#### 1) ABAP Dictionary Table Type 생성

<img width="509" height="279" alt="image" src="https://github.com/user-attachments/assets/0da4c6fd-720e-43ef-b33b-2e863c2e49a2" />
</br>
</br>

#### 2) Table Type 이름 및 패키지 설정

<img width="509" height="284" alt="image" src="https://github.com/user-attachments/assets/b92aa9bd-9ddc-4bfe-a16c-48f8bf3d4eeb" />
</br>
</br>

<img width="509" height="293" alt="image" src="https://github.com/user-attachments/assets/d40527cb-ba36-4e21-8026-fa3c7b4b7734" />
</br>
</br>

<img width="502" height="292" alt="image" src="https://github.com/user-attachments/assets/b2e9e88e-f47d-4d7a-8af2-c08d922e6f89" />
</br>
</br>

#### 3) Table Type 세부 설정 (Row Type, Access, Key 설정 화면)

<img width="511" height="371" alt="image" src="https://github.com/user-attachments/assets/d0b2cd77-8af5-4e5c-95bf-4de31939803d" />
</br>
</br>

<img width="505" height="349" alt="image" src="https://github.com/user-attachments/assets/c1f9623f-059e-4d31-bc4c-a90544c9920a" />
</br>
</br>
</br>
</br>
</br>
</br>
</br>

## < Eclipse에서 CDS View Entity 생성 절차 >
- 테이블에 저장된 데이터를 조회(읽기)하기 위한 가상 뷰 구조
```abap
define view entity <CDS_엔티티이름>
  as select from <데이터소스(테이블/다른CDS)>
{
    <필드1>,
    <필드2>,
    <필드3>
}
```
</br>

#### 1) CDS View(Entity)를 생성

<img width="493" height="412" alt="image" src="https://github.com/user-attachments/assets/54dcfcdf-e410-4567-9d91-edddb2128694" />
</br>
</br>

#### 2) 구문법 defineView(AS ABAP 7.57부터 obsolete)를 선택

<img width="524" height="323" alt="image" src="https://github.com/user-attachments/assets/03ca9f3b-fe73-401a-b122-775e8618ec72" />
</br>

<img width="522" height="415" alt="image" src="https://github.com/user-attachments/assets/35238a04-6caa-4cc5-96cf-e8835e4ec5a5" />
</br>
</br>

#### 3) 구문법 define view를 사용해 SCARR 테이블을 기반으로 SQL View(ZCDSSCARR_B03_S)를 생성
```abap
@AbapCatalog.sqlViewName: 'ZCDSSCARR_B03_S'
@AbapCatalog.compiler.compareFilter: true
@AbapCatalog.preserveKey: true
@AccessControl.authorizationCheck: #NOT_REQUIRED
@EndUserText.label: 'Scarr SCDS View'
@Metadata.ignorePropagatedAnnotations: true
define view ZCDSSCARR_B03 as select from scarr
{
    key carrid as Carr_Id,
    carrname as Carr_Name,
    currcode,
    url 
}
```

</br>
</br>
</br>
</br>
</br>
</br>
</br>

---


</br>

## < ABAP 타입 정의 위치별 차이와 Nested/Flat 구조 비교 >

## < 실습 코드 >
</br>

### 실습 1
- nested, flat 구조 실습
- 클래스 카피해서 코드 수정
</br>

<img width="285" height="154" alt="image" src="https://github.com/user-attachments/assets/fe126750-2d78-4629-9b19-9c13a8720060" />
</br>
</br>

#### 1) DDIC Structure 생성
- z03s_address structure
```abap
@EndUserText.label : 'address'
@AbapCatalog.enhancement.category : #NOT_EXTENSIBLE
define structure z03s_address {

  street      : /dmo/street;
  postal_code : /dmo/postal_code;
  city        : /dmo/city;
  country     : land1;

}
```
- z03s_name structure
```abap
@EndUserText.label : 'Name'
@AbapCatalog.enhancement.category : #NOT_EXTENSIBLE
define structure z03s_name {

  first_name : /dmo/first_name;
  last_name  : /dmo/last_name;

}
```
- z03s_person structure
```abap
@EndUserText.label : 'Person'
@AbapCatalog.enhancement.category : #NOT_EXTENSIBLE
define structure z03s_person {

  name    : z03s_name;
  address : z03s_address;

}
```
- z03s_person_inc structure
```abap
@EndUserText.label : 'PERSON_INC'
@AbapCatalog.enhancement.category : #NOT_EXTENSIBLE
define structure z03s_person_inc {

  name    : include z03s_name;
  address : include z03s_address;

}
```
</br>

#### 2) 클래스 코드에 적용
```abap
CLASS zc203s_structure DEFINITION
  PUBLIC
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    INTERFACES if_oo_adt_classrun .

* Task 1: Simple Structure
**********************************************************************
    TYPES:
      BEGIN OF st_address,
        street      TYPE /dmo/street,
        postal_code TYPE /dmo/postal_code,
        city        TYPE /dmo/city,
        country     TYPE land1,
      END OF st_address.

* Task 2: Nested Structure
**********************************************************************
    TYPES:
      BEGIN OF st_name,
        first_name TYPE /dmo/first_name,
        last_name  TYPE /dmo/last_name,
      END OF st_name.

    TYPES: BEGIN OF st_person,
             name    TYPE st_name,
             address TYPE st_address,
           END OF st_person.


*Task 3: Named Includes
**********************************************************************
    TYPES BEGIN OF st_person_inc.
    INCLUDE TYPE st_name    AS name.
    INCLUDE TYPE st_address AS address.
    TYPES END OF st_person_inc.

protected section.
private section.
ENDCLASS.



CLASS ZC203S_STRUCTURE IMPLEMENTATION.


  METHOD if_oo_adt_classrun~main.

* Task 1
**********************************************************************
    DATA address TYPE z03s_address.

    address-street      = 'Dietmar-Hopp-Allee 16'.
    address-postal_code = '69190'.
    address-city        = 'Walldorf'.
    address-country     = 'DE'.

* Task 2
**********************************************************************
    DATA person TYPE z03s_person.

    person-name-first_name     = 'Dictionary'.
    person-name-last_name      = 'ABAP'.
    person-address-street      = 'Dietmar-Hopp-Allee 16'.
    person-address-postal_code = '69190'.
    person-address-city        = 'Walldorf'.
    person-address-country     = 'DE'.

* Task 2
**********************************************************************
    DATA person2 TYPE z03s_person_inc.

    person2-name-first_name     = 'Dictionary'.
    person2-name-last_name      = 'ABAP'.
    person2-address-street      = 'Dietmar-Hopp-Allee 16'.
    person2-address-postal_code = '69190'.
    person2-address-city        = 'Walldorf'.
    person2-address-country     = 'DE'.
* or -------------------------------------------------------
    person2-first_name  = 'Dictionary'.
    person2-last_name   = 'ABAP'.
    person2-street      = 'Dietmar-Hopp-Allee 16'.
    person2-postal_code = '69190'.
    person2-city        = 'Walldorf'.
    person2-country     = 'DE'.

  ENDMETHOD.
ENDCLASS.
```
</br>
</br>
</br>

### 실습 2
- 테이블 타입 생성 실습
</br>

#### 1) DDIC 타입으로 지정할 요소들 생성
- Table Type 생성

<img width="690" height="319" alt="image" src="https://github.com/user-attachments/assets/fb45fbe2-028a-4068-9175-c93054303465" />
</br>

<img width="670" height="310" alt="image" src="https://github.com/user-attachments/assets/3bd095e4-e67b-45fe-8bc7-b18b9ea61c3c" />
</br>

- `Z03S_PERSON_DEEP` Structure 생성
```abap
@EndUserText.label : 'Z03S_PERSON_DEEP'
@AbapCatalog.enhancement.category : #NOT_EXTENSIBLE
define structure z03s_person_deep {

  first_name : /dmo/first_name;
  last_name  : /dmo/last_name;
  addresses  : z03t_address;

}
```
</br>

#### 2) 클래스 코드에 적용
- 신문법 `VALUE #( )` 를 사용하면 `APPEND` 없이 내부 테이블 데이터를 한 번에 생성할 수 있음
```abap
DATA <itab> TYPE <table_type>.

<itab> = VALUE <table_type>(
  ( <field1> = <value1>
    <field2> = <value2>
    <sub_table> = VALUE <sub_table_type>(
                     ( <sub_field1> = <value> )
                     ( <sub_field1> = <value> )
                   )
  )
).
```
```abap
CLASS ZCL_03_TABLE_TYPE IMPLEMENTATION.


  METHOD if_oo_adt_classrun~main.

* Task 1
**********************************************************************
    DATA addresses TYPE Z03T_ADDRESS.

    addresses =
      VALUE #(
              ( street      = 'Dietmar-Hopp-Allee 16'
                postal_code = '69190'
                city        = 'Walldorf'
                country     = 'DE'
              )
              ( street      = '3999 West Chester Pike'
                postal_code = '19073'
                city        = 'Newtown Square, PA'
                country     = 'US'
              )
             ).

* Task 2
**********************************************************************
    DATA person TYPE z03s_person_deep.

    person-first_name = 'Dictionary'.
    person-last_name  = 'ABAP'.
    person-addresses  = addresses.

* Task 3
**********************************************************************
    DATA persons TYPE Z03T_PERSONS.

    persons =
       VALUE #(
          ( person )
          (
            first_name = 'CDS'
            last_name  = 'ABAP'
            addresses =
              VALUE #(
                      ( street      = 'SAP-Allee 29'
                        postal_code = '68789'
                        city        = 'St.Leon-Rot'
                        country     = 'DE'
                      )
                      ( street      = '35 rue d''Alsace'
                        postal_code = '92300'
                        city        = 'Levallois-Perret'
                        country     = 'FR'
                      )
                      ( street      = 'Bedfont Road'
                        postal_code = 'TW14 8HD'
                        city        = 'Feltham'
                        country     = 'GB'
                      )
                     )
           )
         ).

  ENDMETHOD.
ENDCLASS.
```
