# ABAP 기초
</br>

# 프로그래핑 문법과 로직 (11.14)
</br>

### SAP GUI 기본 구성 요소
1. Command Field (커맨드필드)
   
   - TCODE(트랜잭션 코드) 입력하는 칸
2. Title Bar (타이틀바)
   - 현재 화면의 제목 표시
3. Application Toolbar (어플리케이션 툴바)
   - 프로그램 기능 버튼들이 위치하는 영역
</br>

<img width="463" height="363" alt="image" src="https://github.com/user-attachments/assets/cd48b735-5b5d-4984-9c00-e7dc92999f3f" />

</br>
</br>

### TCODE / 명령어
- `/N` : 현재 TCODE 정료
- `/NXXXX` : 현재 창에서 TCODE 종료
- `/ON` : 새창 열기
- `/OXXXX` : 새창열고 TCODE 실행
- `/ne` : 모든 창닫고 로그오프
- `/nend` : 팝업으로 확인 후 닫고 로그오프
- `/i` : 현재 화면 닫기
</br>

### TCODE 생성 방법
- `SE93` 검색 -> Create (생성) 버튼을 클릭 -> `Program and selection screen (report transaction)`을 선택함
  - `Program and dynpro` : 화면(Screen/Dynpro) 번호를 지정하여, 그 화면부터 상호작용을 시작
  - `Program and selection screen` : 선택 화면(Selection Screen)을 먼저 띄워서 사용자에게 조건을 입력받고 결과를 출력
  - `Method of a class`: ABAP Class의 특정 메서드(Method)를 실행하여 비즈니스 로직을 시작
  - `Transaction with parameters` : 기존 TCODE를 실행하되, 특정 파라미터를 미리 세팅하여 자동 실행
- 생성한 TCODE를 창에 입력하면 이동. ex) `YPROGB03_ASSIGNMENT1`
    
  <img width="370" height="368" alt="image" src="https://github.com/user-attachments/assets/c0b9c4cf-b765-4e4a-b6f5-02971aa88c8d" />

</br>
</br>

### SAP Input Help
- 특정 입력 필드에서 값 목록을 보여주는 기능을 총칭
- 모두 같은 개념으로 F4 키를 누르면 뜨는 팝업
  
- 1) Search Help
  2) Value Help
  3) Possible Entry
  4) F4 Help
  5) Input Help
</br>

### ABAP 기본 개념
- SAP 시스템에서 사용하는 프로그래밍 언어
- 초기에는 COBOL 기반의 절차지향 언어, 이후 객체지향(OOP) 기능 추가
- 소문자 구분 없음 → 내부적으로는 대문자로 처리
- 단, 문자열(‘HQ0’) 내부의 값은 자동 대문자 변환이 되지 않음 → 직접 대문자로 입력해야 함
- 옵션을 통해 소문자 값 전달도 가능
</br>

### SAP ERP란?
- 기업의 다양한 데이터와 프로세스를 통합하여 관리하는 시스템
</br>

### SAP 주요 모듈
- FI(financial accounting) : 재무회계 관리를 위한 모듈. 회사 데이터 처리와 재무 보고서 작성
-	CO(controlling) : 내부 회계 및 경영 회계를 관리, 비용관리/수익성분석/예산처리
-	MM (matrials managements) : 자재 관리하는 모듈, 구매/입고/조회를 관리함
-	PP(product planning) : 제조 및 생산과정을 관리하고 계획
-	SD(sales and distribution) : 판매와 유통관리를 위한 모듈, 주문/배송/물류 관리
-	HR(Human Resource) : 인사관리를 위한 모듈. 인사정보/급여. 교육관리
</br>

### SAP 시스템 버전
1. SAP ECC (ERP Central Component)
   
   - 기존 SAP Business Suite의 핵심 ERP
   - R/3 기반 ERP 시스템
3. SAP S/4 HANA (2015~)
   
   - SAP의 최신 ERP 제품
   - In-Memory DB인 SAP HANA 기반으로 성능 대폭 향상
   - 실시간 분석 및 처리 가능
</br>

### SAP 3-Tier 구조
1) Presentation Layer (프레젠테이션 계층)
   
   - 사용자가 SAP를 사용하는 화면(UI)
   - SAP GUI, 웹(Fiori) 등이 해당

3) Application Layer (애플리케이션 계층)
   - ABAP 프로그램이 실행되는 계층
   - 비즈니스 로직 처리 (주문 생성, 재고 계산 등)
   - Presentation ↔ Database 사이에서 중간 역할

3) Database Layer (데이터베이스 계층)
   - 모든 SAP 데이터를 저장하는 곳
   - HANA, Oracle 등 DBMS 사용
</br>

### SAP Client 구성
- SAP는 여러 Client를 두어 데이터를 독립적으로 관리
- 일반 Client 번호 예시:
  
  - 100 : 개발(DEV)
  - 200 : 품질(QAS)
  - 300 : 운영(PRD)
- Cross-Client(800번): 개발·품질 공용 설정, 클라이언트 구분 없이 적용
</br>

### SAP Object 종류
- Standard Object: SAP에서 제공하는 기본 오브젝트(프로그램, 테이블 등)
- CBO (Customer Bolt-On): 고객사 개발 오브젝트(프로그램, 테이블, 기타)
  
  - CBO(Customer Bolt-On) 네이밍 규칙
    
    - SAP에서 새로 개발하는 오브젝트는 Z 또는 Y로 시작 (이관 가능)

      - Z: 일반 커스텀 오브젝트
      - Y: 회사 내부 표준 오브젝트
   - 예시
     - 패키지: ZPACB##_01
     - 프로그램: /OSE09, /NSE09
       
       - O : 새로운 SAP GUI 창(세션)을 열고 트랜잭션 실행
       - N : 현재 세션에서 트랜잭션 실행
</br>

### 패키지(Package)와 로컬 객체(Local Object)
1) Package
   
   - 이관 대상 Object를 담는 패키지
   - 개발 완료 후 다른 서버(QAS, PRD)로 이관 가능

2) Local Object ($TMP)
   
   - 개인 계정에서 사용하는 임시 패키지
   - 이관 불가, 개인 테스트용
</br>

### SAP 주요 개발 툴 (T-Code)
- SAP 개발 시 자주 사용하는 트랜잭션 코드(T-Code)와 기능 정리

| T-Code | 기능 |
|--------|-------|
| **SE51** | Screen Painter (화면 개발) |
| **SE41** | Menu Painter (메뉴 개발) |
| **SE38** | ABAP Editor (프로그램 작성) |
| **SE37** | Function Builder (함수 모듈 개발) |
| **SE24** | Class Builder (클래스 개발) |
| **SE11** | ABAP Dictionary – **가장 중요** (테이블, 도메인, 뷰 등 데이터 정의) |
| **SE80** | Object Navigator (ABAP Workbench) – **가장 중요**, 오브젝트 통합 관리 |
| **SE93** | 트랜잭션 코드(T-Code)를 생성·조회·관리하는 화면 |

</br>

### Transport(이관) 흐름
- 개발 → 품질 → 운영 순으로 안전하게 이동
- **Tip:** STMS(Transaction Management System)에서 **안쪽 오브젝트부터 순서대로 릴리즈** 후 이관
- 릴리즈 = 이관하기 전에 ‘개발 완료’라고 확정하는 버튼

| 흐름 | 설명 | 도구 |
|------|------|------|
| 개발(DEV) → 품질(QAS) | 개발 완료 후 기능 검증 | CTS (Change and Transport System) |
| 품질(QAS) → 운영(PRD) | 테스트 완료 후 실제 업무 환경 적용 | CTS |
<img width="451" height="231" alt="image" src="https://github.com/user-attachments/assets/da843ad7-23e0-42f0-ae7e-474d71d2361f" />

</br>
</br>

- 순서대로 코드 문법 체크 => 활성화(activate) => 디버그
<img width="508" height="43" alt="image" src="https://github.com/user-attachments/assets/552be000-918d-4fbd-a0cd-735d7deef1bd" />
</br>
</br>

- 상위 레벨에 어디에 들어가 있는지 파악 가능
<img width="506" height="47" alt="image" src="https://github.com/user-attachments/assets/3e423dce-8130-46d1-8f1a-a9f0e6a42f96" />
</br>
</br>
</br>
</br>


### ABAP 프로그램 유형
- SAP에서 자주 사용하는 ABAP 프로그램 유형(Type)과 특징 정리

| Type | 용도 | 특징 |
|------|------|------|
| **1 (Report Program)** | 조회용(R) | 데이터를 조회하고 리포트 출력 (R 기능) |
| **M (Screen Program)** | 화면 기반 CRUD | 생성, 조회, 수정, 삭제 기능 가능 |
</br>

---
</br>

## < ABAP 기본 문법 >
- 모든 문장은 마지막에 마침표(.)
- 문자열은 반드시 홑따옴표 `' '` 사용
  
  - `" "`(쌍따옴표)는 문자열 아님 → 주석
</br>

**1) PARAMETERS**
- 사용자로부터 입력값을 받기 위한 키워드
- 타입을 안 적으면 기본 타입은 C(문자) 길이 1
- 옵션들은 대부분 순서에 상관없이 쓸 수 있음
```abap
PARAMETERS <변수명> TYPE <데이터타입>.
```
```abap
PARAMETERS pa_name TYPE string.  " 문자열 입력값 받음
PARAMETERS pa_num  TYPE I.       " 정수형 입력값 받음
PARAMETERS pa_num  TYPE C LENGTH 4.
PARAMETERS pa_num(4)  TYPE C.      " 위와 같은 코드
```
</br>

**1-1) PARAMETERS 옵션 - OBLIGATORY**
- 필수 입력값. 사용자가 값을 입력하지 않으면 프로그램 실행 불가.
```abap
PARAMETERS pv_data TYPE c OBLIGATORY.      " pv_data는 반드시 입력해야 함
```
</br>

**1-2) PARAMETERS 옵션 - DEFAULT '값'**
- 해당 파라미터가 처음 실행될 때 자동으로 기본값을 넣어줌.
```abap
PARAMETERS pv_data TYPE c DEFAULT 'Hi'.      " 프로그램 실행 시 pv_data에 자동으로 'Hi' 값이 들어감
```
</br>

**1-3) PARAMETERS 옵션 - LOWER CASE**
- 소문자 입력 허용.
- 기본적으로 PARAMETERS는 입력값을 대문자로 변환함 → LOWER CASE 사용 시 그대로 유지.
```abap
PARAMETERS pv_data2 TYPE c LOWER CASE.
```
</br>

**1-4) PARAMETERS 옵션 - VISIBLE LENGTH n**
- 입력필드가 화면에 표시되는 길이만 제한.
- 실제 필드 길이와 화면 표시 길이는 다르게 설정 가능.
```abap
PARAMETERS pv_data2(10) TYPE c VISIBLE LENGTH 2.      " 데이터 길이는 10이지만 화면에는 입력창이 2칸만 보임
```
</br>
</br>

**2) WRITE**
- 화면에 값을 출력하는 키워드
```abap
WRITE <값>. 또는 WRITE: <값1>, <값2>.
```
```abap
WRITE 'Hello World!'.       " 문자열 출력
WRITE: 'Hello', pa_name.    " 문자열과 변수 값 함께 출력
WRITE: 'YOUR input: ', pa_num.
WRITE: 'Result: ', gv_result.

WRITE:/ 'Result: ',
      / gv_result,
      / pa_num.             " / + 띄어쓰기 : 줄바꿈 효과가 남
```
</br>
</br>

**3) NEW-LINE**
- 화면 출력 시 줄바꿈
```abap
NEW-LINE.
```
</br>
</br>

**4) DATA**
- 변수를 선언하는 키워드
```abap
DATA <변수명> TYPE <데이터타입>.
```
```abap
DATA gv_result TYPE I.  " 정수형 변수 선언
```
</br>
</br>

**5) MOVE**
- 값을 다른 변수에 할당
```abap
MOVE <원본> TO <대상>.
```
```abap
MOVE pa_num TO gv_result.  " pa_num 값을 gv_result에 복사
```
</br>
</br>

**6) ADD**
- 산술 연산으로 값을 더함
```abap
ADD <숫자/변수> TO <변수>.
```
```abap
ADD 1 TO gv_result.  " gv_result에 1 더하기
```
</br>
</br>

**7) RADIOBUTTON GROUP**
- 동일한 그룹 안에서 하나만 선택 가능한 옵션 버튼
```abap
PARAMETERS pv_rad1 RADIOBUTTON GROUP rad1.      " pv_rad1과 pv_rad2는 같은 그룹(rad1)
PARAMETERS pv_rad2 RADIOBUTTON GROUP rad1.      " 둘 중 한 개만 'X' 값을 가질 수 있음

pv_rad1 RADIOBUTTON GROUP rad1 DEFAULT 'X'.      " 실행 시 기본으로 pv_rad1이 선택됨
```   
</br>
</br>

**8) AS CHECKBOX**
- 체크박스 형태 입력.
- 체크됨 → `'X'`, 체크 안됨 → `' '` (공백)
```abap
PARAMETERS pv_chk AS CHECKBOX.
```
</br>
</br>

**9) 주석(Comment)**
- `"` 또는 `*` 사용
  
  - `"` : 한 줄의 끝까지 주석
  - `*` : 라인 맨 앞에 쓰면 전체 라인을 주석 처리
```abap
PARAMETERS pa_num TYPE I. " 숫자타입 pa_num 입력값 받음
DATA gv_result TYPE I.    " 변수 선언
```
</br>
</br>

---
</br>

## < 실습 코드 >
### 실습 1
```abap
REPORT ZPROGB03_0001.
PARAMETERS pa_num TYPE I. " 숫자타입 pa_num 입력값 받음
DATA gv_result TYPE I.  " 숫자타입 gv_result 변수 선언

MOVE pa_num TO gv_result. " pa_num 값을 gv_result에 넣음

ADD 1 TO gv_result.   " gv_result에 1을 더함

WRITE: 'YOUR input: ', pa_num.  " 문자와 pa_num 값 함께 출력

NEW-LINE. " 줄바꿈

WRITE: 'Result: ', gv_result.   " 문자와 gv_result 값 함께 출력
```
</br>
</br>

### 실습 2
```abap
REPORT ZBC400_03_HELLO.

PARAMETERS pa_name TYPE string.

WRITE 'Hello World!'.

NEW-LINE.

WRITE: 'Hello', pa_name.
```
</br>
</br>

### 실습 3
```abap
REPORT yprogb03_0002.

PARAMETERS input TYPE I.
ADD 10 TO input.
WRITE input.
```
</br>
</br>

### 실습 4
```abap
PARAMETERS: pv_data(10)  TYPE c OBLIGATORY  DEFAULT 'Hi',
            pv_data2(10) TYPE c LOWER CASE VISIBLE LENGTH 2.

" OBLIGATORY : 필수값 처리
" LOWER CASE : 소문자 허용
" DEFAULT : 기본값 적용
" VISIBLE LENGTH : 화면에 보여지는 입력필드의 길이 저장

PARAMETERS: pv_rad1
            RADIOBUTTON GROUP rad1 DEFAULT 'X',
            pv_rad2
            RADIOBUTTON GROUP rad1,
            pv_chk  AS CHECKBOX.

WRITE: pv_data, pv_data2.

NEW-LINE.

WRITE: 'Radio, Check', pv_rad1, pv_rad2, pv_chk.
```

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (11.17).md
</br>

### 데이터 요소(Data Element) 타입으로 올 수 있는 3가지 종류
- `DATA`는 메모리와 값을 갖는 변수 생성, `TYPE`은 값 없이 타입만 정의
  
#### 1) Standard Data Type
   - SAP가 제공하는 기본 데이터 타입
      #### 1-1) Complete Type
      | Type       | 설명                                                                 |
      |------------|----------------------------------------------------------------------|
      | D          | 날짜(Date)                                                             |
      | T          | 시간(Time)                                                             |
      | I          | 4바이트 정수(Integer 4)                                               |
      | INT8       | 8바이트 정수(Integer 8)                                               |
      | F          | 부동 소수점(Float)                                                     |
      | STRING     | 가변 길이 문자열(Variable-length string), 사용자가 입력하는 만큼 동적 할당됨 |
      | XSTRING    | 가변 길이 이진(Binary) 문자열, 사용자가 입력하는 만큼 동적 할당됨      |
      | DECFLOAT16 | 16자리 부동 소수점(decimal floating)                                  |
      | DECFLOAT34 | 34자리 부동 소수점(decimal floating)                                  |
      
      #### 1-2) Incomplete Type
      | Type | 설명                                                      |
      |------|-----------------------------------------------------------|
      | C    | 문자(Character), 길이 지정 필요                            |
      | N    | 숫자형 문자(Numeric character), 길이 지정 필요              |
      | X    | 16진수(Hexadecimal), 길이 지정 필요                       |
      | P    | 고정소수점. Packed Decimal(BCD), 소수점 위치 지정 필요                 |
     
        - P TYPE
        - `총 자릿수 = LENGTH * 2 - 1`
          - LENGTH : P 타입 선언 시 지정하는 바이트 수
          - *2 → 1바이트 = 2자리 숫자를 저장
          - -1 → 마지막 절반 바이트는 부호(+, -)용
          - 총 자릿수가 DECIMALS 자릿수보다 작으면 에러
          
            ```abap
            DATA lv_amount TYPE P LENGTH 5 DECIMALS 2.
            ```
            </br>
      
#### 2) Local Type
   - 특정 프로그램 내에서 정의하여 사용하는 타입
   - 다른 프로그램에서는 사용할 수 없음
       #### 2-1) TYPES
       - 로컬 타입을 정의할 때 사용하는 키워드, 실제 변수를 만드는 것이 아님
        </br>
         
       ```abap
       TYPES <타입명> TYPE <데이터타입/구조>.
       ```
       ```abap
       TYPES tv_c_type TYPE C LENGTH 8.
       TYPES tv_n_type TYPE N LENGTH 5.
       TYPES tv_p_type TYPE P LENGTH 3 DECIMALS 2.
    
       TYPES ty_employee TYPE string.         " 문자열 타입 정의
       DATA lv_emp_name TYPE ty_employee.     " 타입 사용 변수 선언
       ```

       #### 2-2) LIKE
       - 기존 변수나 데이터 요소의 타입과 속성을 그대로 가져와 새로운 변수 선언
        </br>
         
       ```abap
       DATA <새변수> LIKE <기존변수|데이터요소>.
       ```
       ```abap
       DATA gv_amount TYPE P LENGTH 7 DECIMALS 2.   " 기존 변수 선언
       DATA lv_amount LIKE gv_amount.               " gv_amount와 같은 타입으로 선언
       ```
     </br>
  
#### 3) Global Data Type
   - SE11에서 정의되어 모든 프로그램에서 사용 가능한 타입
   - 데이터 요소, 구조, 테이블 타입 등으로 활용 가능

     #### 3-1) Data Element Type
      - 하나의 값(필드 하나)을 표현하는 타입
      - 길이/형식 같은 기본 속성을 정의함
   
      #### 3-2) Structure Type
      - 여러 필드가 모여 하나의 덩어리를 이루는 타입
      - 하나의 레코드(행) 같은 구조
        
      #### 3-3) Table Type (Internal Table)
      - 동일한 구조를 여러 개 담는 “내부 테이블”을 위한 타입
      - 여러 행을 저장하는 컬렉션 형태

</br>
</br>

### ABAP 변수와 타입 선언: 초기값 vs 기본값 정리
#### 1) 초기값 (Initial Value)
- 모든 변수에는 타입에 따라 자동으로 존재하는 값
- 변수 값을 초기화하면 이 값으로 초기값이 변경됨
```abap
DATA gv_count TYPE I.   " 초기값 0 자동 존재
DATA gv_char  TYPE C.   " 초기값 공백
```

#### 2) 기본값 (Default Value)
- 변수 선언 시 임의로 지정한 값
- 초기값과 달리 개발자가 지정한 값으로 변수 시작
```abap
DATA gv_count TYPE I VALUE 10.  " 기본값 10
DATA gv_name  TYPE C LENGTH 5 VALUE 'ABAP'.  " 기본값 'ABAP'
```
</br>
</br>

---

</br>

## < ABAP 기본 문법 >
#### 1) VALUE
- 변수를 선언하면서 초기값을 지정할 때 사용
</br>
 
```abap
DATA <변수명> TYPE <데이터타입> VALUE <초기값>.
```
```abap
DATA gv_count TYPE I VALUE 10.               " 정수형 변수 초기값 10
DATA lv_name  TYPE string VALUE 'ABAP'.      " 문자형 변수 초기값 'ABAP'
```
</br>

#### 2) CONSTANTS
- 변하지 않는 값(상수)을 선언할 때 사용
- 선언 후 값 변경 불가
```abap
CONSTANTS <상수명> TYPE <데이터타입> VALUE <값>.
```
```abap
CONSTANTS: gc_str TYPE string VALUE 'OKOK',
           gc_num TYPE I VALUE 100.
```
</br>

#### 3) WRITE
- (필드) : 필드 길이에 맞춰 출력
- text-001 : SE51에서 정의한 텍스트 요소, 자리 표시자(&1, &2) 사용 가능
- text-001 다국어 처리 방법 : `Goto → Translation 선택 -> 원하는 언어(EN/KO) 문자열 입력 → 저장 -> 실행 시 환경 언어에 맞춰 자동 출력`
```abap
WRITE: 'My selected variable : '(GRE),
       gc_num,
       text-001.
```
- WRITE 구문에서 필드 길이 지정
- (n) : 출력 시 지정한 길이만큼 공간 확보
```abap
WRITE: (10) gv_data,   " gv_data 값을 10자리 폭으로 출력
       (8)  gv_data2.  " gv_data2 값을 8자리 폭으로 출력
```
</br>

#### 4) MOVE
- 값을 다른 변수에 대입할 때 사용하는 구문(현재는 `=` 와 동일하게 동작)
```abap
MOVE <source> TO <target>.
```
```abap
DATA gv_num1 TYPE I VALUE 10.
DATA gv_num2 TYPE I.

MOVE gv_num1 TO gv_num2.     " gv_num2 = 10
```
</br>

#### 5) CLEAR
- 변수 또는 내부 테이블의 값을 초기값으로 리셋할 때 사용 (타입별 초기값으로 설정됨)
```abap
CLEAR <변수명>.
```
```abap
DATA gv_num TYPE I VALUE 10.
DATA gv_text TYPE c LENGTH 5 VALUE 'ABAP'.

CLEAR gv_num.    " 결과: 0
CLEAR gv_text.   " 결과: '     ' (공백)
```
</br>

#### 6) STRLEN
- 문자열의 길이(문자 수)를 구할 때 사용
```abap
<변수> = STRLEN( <문자열> ).
```
```abap
DATA gv_text TYPE string VALUE 'ABAP'.
DATA gv_len  TYPE i.

gv_len = STRLEN( gv_text ).     " 결과: 4
```
</br>

#### 7) IF문
- 조건에 따라 코드 블록을 실행할 때 사용
- 괄호 양 옆에 띄어쓰기 필수
  
  - 비교 연산자 : EQ (=), NE (≠), GT (>), LT (<), GE (≥), LE (≤), = (같다), <> (같지 않다), > (크다), < (작다), >= (크거나 같다), <= (작거나 같다)
  - 논리 연산자 : AND (그리고), OR (또는), NOT (부정)
  - 초기값 확인 : IS INITIAL (초기값인지 확인), IS NOT INITIAL (초기값이 아닌지 확인)
```abap
IF <조건1> AND <조건2>.
    " 두 조건 모두 참일 때 실행
ELSEIF <조건1> OR <조건3>.
    " 조건1 또는 조건3 중 하나라도 참이면 실행
ELSEIF NOT gv_flag.
    " gv_flag가 FALSE일 때 실행
ELSEIF gv_var IS NOT INITIAL.
    " gv_var가 초기값이 아닐 때 실행
ELSE.
    " 위 조건이 모두 아니면 실행
ENDIF.
```
```abap
DATA gv_num1 TYPE i VALUE 10.
DATA gv_num2 TYPE i VALUE 0.
DATA gv_flag TYPE abap_bool VALUE abap_false.
DATA gv_text TYPE string.

IF gv_num1 > 5 AND gv_num2 = 0.
    WRITE '조건 1과 2 모두 만족'.
ELSEIF gv_num1 = 5 OR gv_num2 = 1.
    WRITE '조건 1 또는 2 만족'.
ELSEIF NOT gv_flag.
    WRITE 'gv_flag가 FALSE'.
ELSEIF gv_text IS NOT INITIAL.
    WRITE 'gv_text 값 있음'.
ELSE.
    WRITE '모든 조건 불만족'.
ENDIF.
```
</br>

#### 8) CASE문
- 하나의 변수 값에 따라 여러 경우를 처리할 때 사용
```abap
CASE <변수>.
    WHEN <값1>.
        <실행문>.
    WHEN <값2>.
        <실행문>.
    WHEN OTHERS.
        <실행문>.
ENDCASE.
```
```abap
DATA gv_code TYPE c LENGTH 1 VALUE 'B'.

CASE gv_code.
    WHEN 'A'.
        WRITE 'Apple'.
    WHEN 'B'.
        WRITE 'Banana'.
    WHEN OTHERS.
        WRITE 'Unknown'.
ENDCASE.
```
</br>

#### 9) MESSAGE
- 프로그램 실행 중 사용자에게 알림, 경고, 오류 등을 출력
```abap
MESSAGE '<메시지 내용>' TYPE '<메시지 타입>'.
```
```abap
MESSAGE '나이를 입력해주세요' TYPE 'E'.  " 오류 메시지
```

</br>
</br>

---
</br>

## < 연산자(Operators) >
- ABAP에서 사용되는 기본 산술 연산자
```abap
+   : 더하기
-   : 빼기
*   : 곱하기
/   : 나누기
**  : 지수(제곱) → 2 ** 3 = 8
DIV : 정수 나눗셈의 몫
MOD : 나머지
```
```abap
DATA a TYPE i VALUE 10.
DATA b TYPE i VALUE 3.
DATA r TYPE i.

r = a + b.      " 13
r = a ** b.     " 1000 (10의 3승)
r = a DIV b.    " 3   (몫)
r = a MOD b.    " 1   (나머지)
```
</br>

### 내장함수
- `abs()` : 숫자의 절대값을 반환
- `strlen()` : 문자열 길이를 반환
- `sqrt()` : 숫자의 제곱근을 반환
- `ipow()` : 정수 거듭제곱 계산 (base^exp)
```abap
DATA: gv_num TYPE I,
      gv_len TYPE string,
      gv_sqrt TYPE I,
      gv_ipow TYPE I.

gv_num = abs( -20 ).
gv_len = strlen( 'Hello World' ).
gv_sqrt = sqrt( abs( 9 ) ).
gv_ipow = ipow( base = 5 exp = 3 ).

write:/ '절대값 abs : ', gv_num,     " 20
      / '문자열길이 len : ', gv_len,  " 11
      / '제곱근 sqrt : ', gv_sqrt,   " 3
      / '지수 ipow : ', gv_ipow.    " 125
```
</br>

### 문자열 처리 함수
- `&&` : 두 문자열을 간단히 이어 붙일 때 사용.
- `CA` : 왼쪽 문자열에 오른쪽 문자열의 문자 중 하나라도 포함되어 있으면 TRUE. 대소문자 구분함.
- `CONCATENATE` : 여러 문자열을 순서대로 연결. `SEPARATED BY`로 각 문자열 사이에 넣을 구분자 지정 가능.
```abap
DATA lv_result TYPE string.
lv_result = 'Hello' && ' World'.    " 결과: 'Hello World'

DATA lv_str TYPE string.
lv_str = 'ABC123'.
IF lv_str CA '123'.
  WRITE: / '숫자를 포함함'.
ENDIF.

DATA: lv_text1 TYPE string VALUE '여기는 서울',
      lv_text2 TYPE string VALUE '날씨가 맑습니다',
      result   TYPE string.
CONCATENATE lv_text1 '이고' lv_text2 '입니다'
INTO result SEPARATED BY space.
WRITE: / result.
" 결과: '여기는 서울 이고 날씨가 맑습니다 입니다'
```
</br>
</br>

---

</br>

## < 실습 코드 >
### 실습 1
```abap
" 변수 선언 시
" => gv_ 글로벌 Data obj
" => lv_ 로컬 Data obj
" 타입 선언 시
" => tv_ : Type value
" 파라미터 선언 시
" => pv_ : 첫 글자에 Parameter 약자 P
" 상수 선언 시
" => gc_ : 첫 글자에 Constants 약자

" 연습
TYPES: tv_char(10) TYPE C,
       tv_dec TYPE P LENGTH 3 DECIMALS 2.

PARAMETERS: pv_data TYPE C LENGTH 3 DEFAULT 'HI'.

DATA: gv_dec TYPE tv_dec,
      gv_date TYPE D,
      gv_char2 TYPE tv_char,
      gv_num TYPE I VALUE 20,
      gv_carrname TYPE S_CARRNAME,
      gv_conn TYPE S_CONN_ID.
DATA: gv_carrname2 LIKE gv_carrname VALUE 'TEST'.

CONSTANTS: gc_str TYPE string VALUE 'OKOK',
           gc_num TYPE I VALUE 100.

WRITE: 'My selected variable : '(GRE),
       gc_num,
       text-001.

" Message Class / Text symbols 를 사용하여 메세지 관리를 하는데,
" Text symbols 에서는 변수 사용할 수 없음
" 변수 사용하려면 Message Class를 사용하자
```
</br>
</br>

### 실습 2
```abap
PARAMETERS name(10) TYPE C.
WRITE: name, 'trainee can learn ABAP programming.'(GRE).

" GRE 더블클릭해서 Text symbols의 값 trainee can learn ABAP programming. 로 설정 -> Translation 선택 -> 원하는 언어(EN/KO) 문자열 입력 → 저장
```
</br>
</br>

### 실습 3
```abap
PARAMETERS: pa_num1 TYPE i,
            pa_num2 TYPE i.

DATA: gv_result TYPE i.

gv_result = pa_num1 + pa_num2.    " 5 + 2 = 7
gv_result = pa_num1 - pa_num2.    " 5 - 2 = 3
gv_result = pa_num1 * pa_num2.    " 5 + 2 = 7
gv_result = pa_num1 / pa_num2.    " 5 / 2 = 3 -> 정수끼리 나눗셈 후 반올림
gv_result = pa_num1 ** pa_num2.   " 5 ** 2 = 25
gv_result = pa_num1 DIV pa_num2.  " 5 DIV 2 = 2 -> 반올림 없음
gv_result = pa_num1 MOD pa_num2.  " 5 MOD 2 = 1

WRITE:/ gv_result.
*Pretty printer(코드정리) 사용시 Shift + F1
```
</br>
</br>

### 실습 4
```abap
PARAMETERS pa_age TYPE I.

IF pa_age IS INITIAL.
    MESSAGE '나이를 입력해주세요' TYPE 'E'.

ELSEIF pa_age GE 8 AND pa_age LE 13.
    WRITE '초등학생입니다.'.

ELSEIF pa_age GT 13 AND pa_age LE 16.
    WRITE '중학생입니다.'.

ELSEIF pa_age GT 16 AND pa_age LT 20.
    WRITE '고등학생입니다.'.

ELSE.
    WRITE '성인입니다.'.
ENDIF.
```
</br>
</br>

### 실습 5
```abap
PARAMETERS pa_curr TYPE C LENGTH 3.

CASE pa_curr.
  WHEN 'USD'.
    WRITE: '달러를 선택하였습니다.'.
  WHEN 'EUR'.
    WRITE: '유로를 선택하였습니다.'.
  WHEN 'KRW'.
    WRITE: '한화를 선택하였습니다.'.
  WHEN OTHERS.
    MESSAGE 'USD, EUR, KRW 중 하나를 입력하세요' TYPE 'E'.
ENDCASE.
```
</br>
</br>

### 실습 6
```abap
PARAMETERS: pa_check AS CHECKBOX.

CASE 'X'.
  WHEN pa_check.  " 체크박스에 체크 됐을 때
    WRITE: '체크되었습니다'.
  WHEN OTHERS.    " 체크박스에 체크가 안됐을 때
    WRITE: '체크되지 않았습니다.'.
ENDCASE.
```
</br>
</br>

### 실습 7
```abap
PARAMETERS score TYPE I.
PARAMETERS pa_check AS CHECKBOX.

IF ( score LE 100 AND score GE 80 ).
  IF ( pa_check EQ 'X' ).
    WRITE '성적 : A 우수상'.
  else.
    WRITE '성적 : A'.
  ENDIF.
ELSEIF ( score LT 80 AND score GE 60 ).
  WRITE '성적 : B'.
ELSEIF ( score LT 60 AND score GE 40 ).
  WRITE '성적 : C'.
ELSE.
  WRITE '성적 : F'.
ENDIF.
```
```abap
PARAMETERS score TYPE I.
PARAMETERS pa_check AS CHECKBOX.

IF ( score <= 100 AND score >= 80 ).
  IF pa_check EQ 'X'.
    WRITE '성적 : A 우수상'.
  else.
    WRITE '성적 : A'.
  ENDIF.
ELSEIF ( score < 80 AND score >= 60 ).
  WRITE '성적 : B'.
ELSEIF ( score < 60 AND score >= 40 ).
  WRITE '성적 : C'.
ELSE.
  WRITE '성적 : F'.
ENDIF.
```
</br>
</br>

### 실습 8
```abap
PARAMETERS: pa_int1 TYPE i,
            pa_int2 TYPE i,
            pa_op   TYPE c.

TYPES: ty_result TYPE p LENGTH 16 DECIMALS 2.

DATA gv_result TYPE ty_result.


CASE pa_op.
  WHEN '+'.
    gv_result = pa_int1 + pa_int2.
  WHEN '-'.
    gv_result = pa_int1 - pa_int2.
  WHEN '*'.
    gv_result = pa_int1 * pa_int2.
  WHEN '/'.
    IF ( pa_int1 = 0 OR pa_int2 = 0 ).
      MESSAGE '0을 나눌 순 없습니다.' TYPE 'E'.
    ENDIF.
    gv_result = pa_int1 / pa_int2.
  WHEN '%'.
    PERFORM CALC_PERCENTAGE USING pa_int1 pa_int2 CHANGING gv_result.
  WHEN OTHERS.
    MESSAGE '타당하지 않는 연산자입니다.' TYPE 'E'.
ENDCASE.

WRITE: gv_result.

FORM CALC_PERCENTAGE USING VALUE(PV_ACT) TYPE I
                           VALUE(PV_MAX) TYPE I
                     CHANGING VALUE(CV_RESULT) TYPE ty_result.
  IF ( PV_MAX = 0 ).
    MESSAGE '0이 들어올 수 없습니다.' TYPE 'E'.
  ELSE.
    CV_RESULT = ( PV_ACT / PV_MAX ) * 100.
  ENDIF.
ENDFORM.
```

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (11.18).md
</br>

# 반복문

## 📌 ABAP 반복문 관련 시스템 변수

| 시스템 변수 | 기능 / 의미 | 반복문과의 관계 |
|-------------|------------|----------------|
| **sy-subrc** | ABAP 문법 실행 결과 코드 <br> - 0: 성공 / 데이터 존재 <br> - 4: 조건에 맞는 데이터 없음 <br> - 8: 키 조합 오류 | SELECT, 함수, 조건문 실행 후 결과 확인 |
| **sy-dbcnt** | SELECT … ENDSELECT 루프 인덱스 (몇 번째 DB 레코드를 읽었는지) | SELECT 루프에서 자동 증가 |
| **sy-tabix** | 내부 테이블 LOOP 행 번호 | LOOP AT 내부 테이블 반복 시 현재 행 번호 |
| **sy-index** | DO / WHILE 반복문 인덱스 | 일반 반복문(DO, DO n TIMES, WHILE)에서 반복 횟수 |
</br>
</br>

### 1) DO … ENDDO
- 반복 횟수를 지정하지 않으면 무한 반복
- `EXIT`나 `CHECK` 등으로 빠져나와야 함
- `sy-index` 사용 가능
```abap
DO.
  " 반복 코드
ENDDO.
```
```abap
PARAMETERS: pa_cnt TYPE i.

DO.
  IF SY-INDEX > pa_cnt.
    EXIT.
  ENDIF.
  WRITE:/ sy-index.
ENDDO.
```
```abap
DATA lv_cnt TYPE i VALUE 0.

DO.
  lv_cnt = lv_cnt + 1.
  IF lv_cnt > 3.
    EXIT.
  ENDIF.
ENDDO.
```
</br>

### 2) DO n TIMES … ENDDO
- 지정한 n번 반복
- 반복 횟수는 sy-index에 자동 저장됨(1부터 시작)
- `sy-index` 사용 가능
```abap
DO n TIMES.
  " 반복 코드
ENDDO.
```
```abap
PARAMETERS: pa_cnt TYPE i.

DO pa_cnt TIMES.
  WRITE:/ sy-index.
ENDDO.
```
```abap
DO 5 TIMES.
  WRITE: / '횟수:', sy-index.
ENDDO.
```
</br>

### 3) WHILE … ENDWHILE
- 조건이 TRUE일 동안 반복
- 조건이 FALSE가 되면 종료
- `sy-index` 사용 가능
```abap
WHILE 조건.
  " 반복 코드
ENDWHILE.
```
```abap
PARAMETERS: pa_cnt TYPE i.

WHILE sy-index < pa_cnt.
  WRITE:/ sy-index.
ENDWHILE.
```
```abap
DATA lv_i TYPE i VALUE 1.

WHILE lv_i <= 5.
  WRITE: / lv_i.
  lv_i = lv_i + 1.
ENDWHILE.
```
</br>

### 4) SELECT … ENDSELECT
- DB를 row-by-row 방식으로 조회
- SELECT된 각 레코드를 반복 처리
- `sy-dbcnt` 사용 가능
```abap
SELECT <필드목록>                  " <필드목록> : 가져올 컬럼 이름 (예: carrid, connid)
  FROM <테이블명>                  " <테이블명> : DB 테이블 이름 (예: sflight)
  INTO <워크에어리어 변수>          " <워크에어리어 변수> : 데이터를 담을 ABAP 변수/구조
  [WHERE <조건문>]                 " WHERE : 선택 조건 (선택 사항)
  [ORDER BY <정렬필드>].            " ORDER BY : 정렬 조건 (선택 사항)
  
  " 처리 로직 작성 (레코드 하나씩 처리)
  
ENDSELECT.
```
```abap
DATA: gv_carrid TYPE scarr-carrid. " S_CARR_ID랑 동일
" Transparent Table 이라 세부적으로 들어갈 수 있음

" 만약 조건이 없으면 테이블의 전체 건수 만큼 루프문 실행
" 조건이 있으면 조건에 맞는 데이터를 가져옴
SELECT carrid
  INTO gv_carrid
  FROM scarr
  WHERE carrid='AA'.
    " 여기서 데이터 처리 로직 구현
    WRITE:/ sy-dbcnt, gv_carrid.
ENDSELECT.
```
```abap
DATA: wa_sflight TYPE sflight.  " 작업 영역 선언

" sflight 테이블 전체 레코드를 하나씩 읽어서 처리
SELECT * 
  FROM sflight
  INTO wa_sflight.

  WRITE: / wa_sflight-carrid, wa_sflight-connid, wa_sflight-fldate.

ENDSELECT.
```
</br>

### 5) LOOP AT … ENDLOOP
- 내부 테이블을 한 행씩 반복 처리
- 현재 행 번호는 sy-tabix
- `sy-tabix` 사용 가능
- `TABLE OF` : 특정 구조나 타입을 가지는 내부 테이블을 선언할 때 사용
- `LINE OF` : 내부 테이블에서 한 행(row)의 타입을 가져올 때 사용
```abap
LOOP AT <internal_table> INTO <work_area> [FROM <시작행>] [TO <끝행>] [WHERE <조건>].

  " 반복 처리 로직 작성 (각 행마다 실행)

ENDLOOP.
```
```abap
DATA: gs_sflight TYPE BC400_S_FLIGHT,      " Structure
      gt_sflight LIKE TABLE OF gs_sflight. " gt : 글로벌 테이블
" DATA: gs_sflight2 LIKE LINE OF gt_sflight. " Structure

SELECT * FROM SFLIGHT
  INTO CORRESPONDING FIELDS OF TABLE @gt_sflight  " DB 테이블에서 데이터 가져와서 internal 테이블에 넣음
  WHERE CARRID = 'AA'
    AND CONNID = '0017'.

IF sy-subrc = 0. " 만약 데이터 조회 성공한다면 (데이터 존재시)
  " Internal Table에 조회한 데이터들이 들어와 있는 상황
  " gt_flight를 한 건씩 돌면서 처리. 이 때 gs_flight 에 담아서 처리
  LOOP AT gt_sflight INTO gs_sflight. " Work-area라고 부름
    " gt_sflight 와 gs_sflights 는 필드 구조가 동일해야함.
    WRITE:/ sy-tabix,
            gs_sflight-carrid,
            gs_sflight-connid,
            gs_sflight-fldate.
  ENDLOOP.
ENDIF.
```
```abap
DATA: lt_data TYPE TABLE OF sflight,
      wa_data TYPE sflight.

SELECT * FROM sflight INTO TABLE lt_data.

LOOP AT lt_data INTO wa_data.
  WRITE: / wa_data-carrid, wa_data-connid.
ENDLOOP.
```
</br>
</br>

---

</br>

# ABAP Message Class (SE91) & 메시지 타입 정리
### 1) Message Class (SE91)
- 메시지를 번호로 관리하는 저장소. 이름은 Z나 Y로 시작.
- WITH 뒤에 메시지의 & 자리에 들어갈 값 지정
- 메시지는 `&` 로 변수 값을 받을 수 있음. 최대 4개까지 가능 → &1, &2, &3, &4 또는 단순 & 순서대로.
- 다국어(번역) 지원 → SAP 로그인 언어에 따라 자동으로 해당 언어 메시지 표시됨
</br>

### 2) 메시지 타입 정리

| 타입 | 이름 | 동작 | 상세 설명 |
|------|------|------|------------|
| **I** | Information | 팝업 메시지 표시 | 단순 정보 안내. OK 누르면 계속 진행 |
| **S** | Success | 상태바(하단)에 녹색 메시지 | 성공 메시지. 실행 계속됨 |
| **W** | Warning | **하단 상태바에 노란색 경고 메시지 표시** | 엔터 누르면 계속 진행. 단, *입력 화면(Selection-Screen)* 안에서만 유효 |
| **E** | Error | **하단 상태바에 빨간색 에러 메시지 표시 후 처리 중단** | AT SELECTION-SCREEN에서는 입력 화면으로 돌아감. 프로그램 실행 중에는 현재 이벤트 종료 |
| **A** | Abort | 비정상 종료 | 메시지 출력 후 프로그램 즉시 종료 |
| **X** | Exception | Short Dump 발생 | 시스템 덤프 생성(SAP 오류 강제 발생) |
</br>

### 3) MESSAGE-ID 미사용
- <메시지클래스> 반드시 명시해야 함
```abap
MESSAGE <type><번호>(<메시지클래스>) WITH 값1 값2 ...
```
```abap
REPORT ZPROGB03_0006.

PARAMETERS: pa_name TYPE string.
CONSTANTS: gc_const TYPE string VALUE 'CODE'.
MESSAGE i002(ZMCB03) WITH pa_name gc_const.
```
</br>

### 4) MESSAGE-ID 사용
- 프로그램 가장 위( REPORT 문 뒤 ) 선언
- 메시지 호출 시 클래스 이름 생략 가능
```abap
REPORT <프로그램명> MESSAGE-ID <메시지클래스>.
```
```abap
REPORT ZPROGB03_0006 MESSAGE-ID ZMCB03.          " MESSAGE-ID 사용

PARAMETERS: pa_name TYPE string.
CONSTANTS: gc_const TYPE string VALUE 'CODE'.
MESSAGE i002 WITH pa_name gc_const.              " 생략
```
</br>
</br>

---
</br>

## 디버깅
1. 소스코드에 BREAK-POINT. 키워드
2. 커멘드필드창에 /h 입력
3. 소스코드의 특정 라인 선택
</br>

### 디버깅 창에서 application toolbar의 버튼 4개

1. F5 한줄씩 실행 (메서드 안쪽까지 들어감)
2. F6 함수 블럭을 넘기고 다음 라인 실행. 함수 내부에서 실행 시 F5와 같이 동작함.
3. F7 함수 블럭 안에서, 메인 소스의 현재 위치 바로 다음줄로 이동
4. F8 다음 Break Point로 이동
```abap
BREAK-POINT.
```
</br>
</br>

---

</br>

## < 실습 코드 >
### 실습 1
- 숫자 2개 사이 값의 홀수 출력
```abap
PARAMETERS: pa_num1 TYPE I,   " 입력받은 두 숫자
            pa_num2 TYPE I.
DATA: gv_num TYPE I,
      gv_num1 LIKE gv_num,
      gv_num2 LIKE gv_num.           " 출력할 숫자 검사를 시작할 변수 선언

IF ( pa_num1 > pa_num2 ).     " 앞에 숫자 값이 더 클 때
  gv_num = pa_num2 + 1.
  gv_num1 = pa_num1.
  gv_num2 = pa_num2.
ELSE.
  gv_num = pa_num1 + 1.
  gv_num1 = pa_num2.
  gv_num2 = pa_num1.
ENDIF.

DO.
  IF ( sy-index > gv_num1 - gv_num2 - 1 ).
    EXIT.
  ENDIF.
  IF ( gv_num MOD 2 = 1 ).
    WRITE / gv_num.
  ENDIF.
  gv_num = gv_num + 1.
ENDDO.
```
</br>
</br>

### 실습 2
- 두 숫자 사이 3의 배수 구하기
```abap
PARAMETERS: pa_small TYPE I, pa_big TYPE I.
CONSTANTS: gc_const TYPE I VALUE 3.

IF ( ( pa_small IS INITIAL ) OR ( pa_big IS INITIAL ) ).
  MESSAGE TEXT-001 TYPE 'E'.
ENDIF.

IF ( pa_big <= pa_small ).
  MESSAGE TEXT-002 TYPE 'E'.
ENDIF.

DO.
  IF ( pa_small > pa_big ).
    EXIT.
  ELSEIF ( pa_small MOD gc_const = 0 ).
    WRITE / pa_small.
  ENDIF.
  pa_small = pa_small + 1.
ENDDO.
```
</br>
</br>

### 실습 3
```abap
PARAMETERS: pa_int1 TYPE I,
            pa_int2 TYPE I,
            pa_op TYPE C.

DATA gv_result TYPE P LENGTH 16 DECIMALS 2.


CASE pa_op.
  WHEN '+'.
    gv_result = pa_int1 + pa_int2.
  WHEN '-'.
    gv_result = pa_int1 - pa_int2.
  WHEN '*'.
    gv_result = pa_int1 * pa_int2.
  WHEN '/'.
    IF ( pa_int1 = 0 OR pa_int2 = 0 ).
      MESSAGE '0을 나눌 순 없습니다.' TYPE 'E'.
    ENDIF.
    gv_result = pa_int1 / pa_int2.
  WHEN OTHERS.
    MESSAGE '타당하지 않는 연산자입니다.' TYPE 'E'.
ENDCASE.

WRITE: gv_result.
```

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (11.19).md
</br>

# ABAP 모듈화(Modularization)
- 코드를 따로 만들어 놓고 필요할 때 호출해서 쓰는 것
- 가독성 ↑, 재사용성 ↑, 유지보수 ↑
</br>

**1) Local Modularization (로컬 모듈화)**
- 현재 프로그램 안에서만 사용 가능, 재사용성 낮음
- Subroutine (FORM), Local Class

**2) Global Modularization (전역 모듈화)**
- SAP 전체 프로그램이 공용으로 사용 가능, 어디서든 호출 가능, 재사용성 매우 좋음.
- Function Group / Function Module, Global Class (SE24) / Method
</br>

### 데이터 캡슐화
- 객체 내부 데이터를 숨기고(PRIVATE) 외부에서는 메서드(PUBLIC)로만 접근하도록 제한하는 것
- 데이터 보호 + 잘못된 접근 방지를 위한 객체지향의 기본 원칙
</br>

--- 

</br>

# 모듈화 기술 함수

## 1) Subroutine (FORM … ENDFORM)
- 로컬 모듈화 방식: 같은 프로그램 안에서만 호출 가능
- 글로벌 변수 사용 가능하지만 최소화하여 독립적·재사용 가능하게 작성

- 파라미터
  - `Formal Parameter` : 서브루틴/함수 선언 시 정의되는 변수
  - `Actual Parameter` : 호출 시 전달되는 값
  - **파라미터에 인터널 테이블을 쓸 수 있지만 `LIKE` 나 `TYPE` 을 이용해 명시해줘야함**
- 호출 방식
  - `CALL BY VALUE` : 호출 시 값만 복사해서 전달, 호출부 값은 바뀌지 않음.
  - `CALL BY VALUE AND RESULT` : 값 전달 후, 서브루틴에서 수정된 값을 호출부로 반환.
  - `CALL BY REFERENCE` : 변수의 메모리 주소를 공유, 서브루틴에서 바꾸면 호출부 값도 바로 바뀜.
- `USING`이나 `CHANGING` 파라미터에서 길이(LENGTH)를 지정하면 FORM 문법상 오류
```abap
* -------------------------------
* Subroutine 호출부
* -------------------------------
PERFORM <subroutine_name> 
        USING <param1> VALUE <param2> 
        CHANGING <param3> <param4>.

* -------------------------------
* Subroutine 선언부
* -------------------------------
FORM <subroutine_name> 
     USING VALUE(<param1>) VALUE(<param2>) 
     CHANGING <param3> <param4>.
  " 처리 로직 작성
ENDFORM.
```
</br>

### < ABAP 서브루틴 파라미터 전달 방식 정리 >
- USING / CHANGING 키워드와 VALUE() 사용 여부에 따른 호출 방식 표

| 키워드    | VALUE() 사용 여부 | 호출 방식                  | 특징                       | 호출부 반영 여부                |
|-----------|----------------|---------------------------|----------------------------|-------------------------------|
| USING     | VALUE()         | Call by Value             | 값만 전달                  | 호출부 변수 변경 안됨          |
| USING     | 없음            | Call by Reference         | 값 전달 + 수정 가능        | 호출부 변수 변경됨             |
| CHANGING  | VALUE()         | Call by Value and Result  | 값 전달 + 결과 반환        | 호출부 변수 변경됨             |
| CHANGING  | 없음            | Call by Reference         | 값 전달 + 수정 가능        | 호출부 변수 변경됨             |
- `USING VALUE(fa)` → 값만 전달, 호출부 변수 변경 안됨  
- `USING fa` → 값 전달 + 호출부 변수 공유  
- `CHANGING VALUE(fd)` → 값 전달 후 수정 결과 반환  
- `CHANGING fd` → 호출부 변수 공유, 바로 수정
```abap
DATA: gv_a TYPE C VALUE 'A',
      gv_b TYPE C VALUE 'B',
      gv_c TYPE C VALUE 'C',
      gv_d TYPE C VALUE 'D'.

PERFORM test USING gv_a gv_b
             CHANGING gv_c gv_d.

NEW-LINE.
WRITE: 'PERFORM IN : ', gv_a, gv_b, gv_c, gv_d.

FORM test  USING    VALUE(fa)
                    fb
           CHANGING VALUE(fc)
                    fd.
  fa = 'W'.
  fb = 'X'.
  fc = 'Y'.
  fd = 'Z'.
  WRITE: 'PERFORM END : ', fa, fb, fc, fd.

ENDFORM.
```
</br>
</br>

## 2) Function Module (FM)
- SE37 (Function Builder): SAP에서 Function Module을 생성, 수정, 테스트할 수 있는 트랜잭션 코드.
- Function Module(FM) 은 Function Group(FG) 안에 소속됨.
- Function Group = 하나의 프로그램처럼 동작.
- Function Module 가져올 때 끌어오거나 pattern 클릭 후 가져올 수 있음

</br>
  
- FG 내부 변수들은 FG 안의 Function Module끼리만 접근 가능, 일반 ABAP 프로그램에서는 직접 접근 불가
  - FM의 파라미터(interface)를 통해서만 값 전달·수정 가능.
- 하나의 FG 안에는 여러 개의 Function Module이 들어갈 수 있음.
```abap
* Function Module 호출

CALL FUNCTION '<FUNCTION_MODULE_NAME>'.
```

**RAISE**
- Function Module 내부에서 예외(Exception)를 발생시킬 때 사용
```abap
" function module 에서

FUNCTION zfm_test.

  IF iv_carrid IS INITIAL.
    RAISE invalid_carrid.
  ENDIF.

ENDFUNCTION.
```
```abap
" 프로그램에서

CALL FUNCTION 'ZFM_TEST'
  EXPORTING
    iv_carrid = ''
  EXCEPTIONS
    invalid_carrid = 1.
```
</br>
</br>

### < Function Module 파라미터 >
**1) Function Module 파라미터 옵션**
1) OPTIONAL
   - 체크하면 해당 파라미터를 전달하지 않아도 FM 호출 가능 (선택값)
   - 체크하지 않으면 필수값, 반드시 전달해야 함
     
2) Pass by Value / Reference
   - Pass by Value (체크 O) : FM에 값만 전달, FM 내부에서 변경해도 호출부 변수는 영향 없음
   - Pass by Reference (체크 X) : FM과 호출부 변수가 같은 메모리 주소를 공유, FM 내부 변경 시 호출부에도 반영

3) EXCEPTIONS (예외 처리)
   - FM 실행 중 발생할 수 있는 오류 상황을 처리
   - 호출부에서 특정 예외를 감지하고 대응 가능
</br>
</br>

**2) Function Module 파라미터 종류 (Interface)**
- FM에서 파라미터 영역을 **Interface**라고 부름
  - 프로그램과 FM이 값을 주고받는 통로
  
| 파라미터 종류 | 의미 |
|---------------|------------------------------------------------|
| **IMPORT**    | 프로그램 → FM 값 전달 |
| **EXPORT**    | FM → 프로그램 값 반환 |
| **CHANGING**  | 양방향 데이터 전달 (주고받기) |
| **EXCEPTIONS**| 예외 처리 |
</br>
</br>

**3) 프로그램 ↔ Function Module 파라미터 대응표**
- 프로그램이 **EXPORTING** 으로 보내면 FM에서는 반드시 **IMPORTING** 으로 받아야 함.

| 프로그램에서 전달 | Function Module에서 받음 |
|------------------|---------------------------|
| **EXPORTING**    | **IMPORTING** |
| **IMPORTING**    | **EXPORTING** |
| **CHANGING**     | **CHANGING** |
| **Tables**     | **Tables** |
| **sy-subrc**     | **Exceptions** |

</br>
</br>

### < Function Module 선언 (SE37에서 생성) >
```abap
FUNCTION <function_module_name>.
*"----------------------------------------------------------------------
*"*" Local Interface:
*"  IMPORTING
*"     VALUE(<import_param1>) TYPE <type>
*"  EXPORTING
*"     VALUE(<export_param1>) TYPE <type>
*"  CHANGING
*"     VALUE(<changing_param1>) TYPE <type>
*"  EXCEPTIONS
*"      <exception_name1> 1
*"      <exception_name2> 2
*"----------------------------------------------------------------------

  " 처리 로직 작성
  <export_param1> = <import_param1> + 10.

ENDFUNCTION.
```
</br>

### <Function Module 호출 (프로그램에서) >
```abap
DATA: lv_result TYPE i.

CALL FUNCTION '<function_module_name>'
  EXPORTING
    <import_param1> = 5
  IMPORTING
    <export_param1> = lv_result
  CHANGING
    <changing_param1> = lv_result
  EXCEPTIONS
    <exception_name1> = 1
    OTHERS = 2.

IF sy-subrc <> 0.
  WRITE: '예외 발생'.
ELSE.
  WRITE: / '결과: ', lv_result.
ENDIF.
```

</br>
</br>

---

</br>

## < ABAP 추가적인 문법 >
</br>

**1) ULINE**
- 화면에 ————— (라인) 을 출력하는 명령
- WRITE 없이 단독으로 사용 가능
```abap
ULINE.
```
</br>

**2) WRITE: 숫자(숫자) → 출력 위치 + 필드 길이 지정**
```abap
WRITE: position(length) <값>.
```
```abap
WRITE: 5(10) pa_num, '단 :'.    " 5(10) → 화면 5번째 칼럼부터 10칸 공간 확보
```
</br>

---
</br>

## < 실습 코드 >
### 실습 1
```abap
PARAMETERS pa_num TYPE I.
DATA gv_result TYPE I.

IF ( pa_num <= 1 ).
  MESSAGE '2 이상을 입력하세요' TYPE 'E'.
ELSEIF ( pa_num >= 10 ).
  MESSAGE '9 이하를 입력하세요' TYPE 'E'.
ELSE.
  DO 9 TIMES.
    gv_result = pa_num * sy-index.
    WRITE:/ pa_num, ' * ', sy-index, ' = ', gv_result.
  ENDDO.
ENDIF.
```
```abap
PARAMETERS: pa_num TYPE I.
DATA: gv_result TYPE I.

IF pa_num < 2 OR pa_num > 9.
  MESSAGE '2 이상 9 이하의 숫자를 입력하세요.' TYPE 'I'.
  ELSE.
    WRITE: 5(10) pa_num, '단 :'.
    ULINE.

    DO 9 TIMES.
      gv_result = pa_num * sy-index.
      WRITE:
        10(2) pa_num,
        12(2) '*',
        14(2) sy-index,
        16(2) '=',
        18(2) gv_result.
      NEW-LINE.
    ENDDO.
ENDIF.
```
</br>
</br>

### 실습 2
```abap
PARAMETERS: gv_num1 TYPE i,
            gv_op   TYPE c LENGTH 1,
            gv_num2 TYPE i.

DATA: gv_result TYPE i.

PERFORM get_compute USING gv_num1 gv_num2 gv_op
                    CHANGING gv_result.

WRITE: gv_result.

* 서브루틴 정의
FORM get_compute USING VALUE(p_pa_num1)
                       VALUE(p_pa_num2)
                       VALUE(p_pa_op)
                 CHANGING VALUE(p_pa_result).
  CASE p_pa_op.
    WHEN '+'.
      p_pa_result = p_pa_num1 + p_pa_num2.
    WHEN '-'.
      p_pa_result = p_pa_num1 - p_pa_num2.
    WHEN '*'.
      p_pa_result = p_pa_num1 * p_pa_num2.
    WHEN '/'.
      p_pa_result = p_pa_num1 / p_pa_num2.
    WHEN OTHERS.
  ENDCASE.

ENDFORM.
```
</br>
</br>

### 실습 3
```abap
PARAMETERS: pa_int1 TYPE i,
            pa_int2 TYPE i,
            pa_op   TYPE c.

DATA gv_result TYPE p LENGTH 16 DECIMALS 2.


CASE pa_op.
  WHEN '+'.
    gv_result = pa_int1 + pa_int2.
  WHEN '-'.
    gv_result = pa_int1 - pa_int2.
  WHEN '*'.
    gv_result = pa_int1 * pa_int2.
  WHEN '/'.
    IF ( pa_int1 = 0 OR pa_int2 = 0 ).
      MESSAGE '0을 나눌 순 없습니다.' TYPE 'E'.
    ENDIF.
    gv_result = pa_int1 / pa_int2.
  WHEN '%'.
    PERFORM CALC_PERCENTAGE USING pa_int1 pa_int2 CHANGING gv_result.
  WHEN OTHERS.
    MESSAGE '타당하지 않는 연산자입니다.' TYPE 'E'.
ENDCASE.

WRITE: gv_result.

FORM CALC_PERCENTAGE USING VALUE(PV_ACT) TYPE I 
                           VALUE(PV_MAX) TYPE I
                     CHANGING VALUE(CV_RESULT).
  IF ( PV_MAX = 0 ).
    MESSAGE '0이 들어올 수 없습니다.' TYPE 'E'.
  ELSE.
    CV_RESULT = ( PV_ACT / PV_MAX ) * 100.
  ENDIF.
ENDFORM.
```

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (11.20).md
</br>

## < SE11 ABAP Dictionary에서 정의하는 타입 >
**1) 데이터필드 (단일 필드 데이터 타입)**
- 숫자 1개, 문자열 1개 등 값 하나만 저장하는 타입
```abap
DATA 변수명 TYPE 데이터타입.
```
```abap
DATA gv_price TYPE p DECIMALS 2.
DATA gv_name  TYPE char20.
```
</br>
</br>

**2-1) Structure 타입**
- 여러 개의 필드(컴포넌트)를 묶은 하나의 "작업공간(Work Area)"
- SE11에서 Structure 로 정의된 타입 사용 가능
- 또는 LOCAL TYPES 로 직접 선언 가능
```abap
DATA 구조체변수명 TYPE 글로벌_구조체명.
```
```abap
DATA gs_flight TYPE bc400_s_flight.
```
</br>

**2-2) Local Structure 정의 후 사용**
- 프로그램 안에서만 쓰는 로컬 구조체를 직접 만드는 것
- SE11(글로벌 타입) 안 쓰고, TYPES 로 구조체를 만들고 DATA 로 변수 생성
```abap
TYPES: BEGIN OF 구조체타입명,
         필드명 TYPE 데이터타입,
         필드명 TYPE 데이터타입,
       END OF 구조체타입명.

DATA 구조체변수명 TYPE 구조체타입명.
```
```abap
TYPES: BEGIN OF ts_flight,
         carrid   TYPE s_carr_id,
         connid   TYPE s_conn_id,
         fldate   TYPE s_date,
       END OF ts_flight.

DATA gs_flight TYPE ts_flight.
```
</br>

**2-3) Local Structure + INCLUDE TYPE (구조체 확장)**
- 기존 글로벌 Structure를 포함하고, 프로그램 전용 필드를 추가하여 로컬 구조체 확장
```abap
DATA: BEGIN OF <로컬구조체변수명>.
        INCLUDE TYPE <글로벌Structure명>.
DATA: <추가필드명1> TYPE <데이터타입>,
      <추가필드명2> TYPE <데이터타입>,
      END OF <로컬구조체변수명>.
```
```abap
DATA: BEGIN OF gs_flight.
        INCLUDE TYPE BC400_S_FLIGHT.  " 글로벌 Structure 포함
DATA: custom1 TYPE CHAR1,
      custom2 TYPE CHAR1,
      END OF gs_flight.

gs_flight-carrid = 'AA'.       " 글로벌 필드
gs_flight-custom1 = 'X'.       " 로컬 필드

WRITE: / gs_flight-carrid, / gs_flight-custom1.
```
</br>

**2-4) CUKY / CURR, UNIT / QUAN 주의**
- `CUKY / CURR` : 금액과 통화키 필드는 항상 짝
- `UNIT / QUAN` : 수량과 단위 필드도 항상 짝 맞춰야 함
- 짝이 맞지 않으면 런타임 에러 발생 가능

<img width="509" height="183" alt="image" src="https://github.com/user-attachments/assets/322a985b-def8-4c42-b439-837586fc4215" />
</br>
</br>

- currency/quantity 에서 수정해야 함
<img width="510" height="196" alt="image" src="https://github.com/user-attachments/assets/0d875068-b49d-4bc5-916d-7d8c099c26fe" />

</br>
</br>
</br>
</br>

**3) DB Table 기반 구조체**
- SE11에서 정의된 Transparent Table을 기준으로 변수를 만들면
  - `DATA gs_scarr TYPE scarr.` → 구조체 (Work Area, 테이블 한 행)
  - `DATA gv_carrid TYPE scarr-carrid.` → 단일 필드 (Work Area 아님)
- 테이블 컬럼이 그대로 구조체 필드로 생성됨
```abap
DATA gs_scarr TYPE scarr.       " 구조체: 테이블 한 행을 담음
DATA gv_carrid TYPE scarr-carrid. " 단일 필드
```
</br>
</br>

**4) MOVE-CORRESPONDING**
- 구조체/테이블 간 필드 이름이 같은 것만 복사
- MOVE와 달리 필드 위치 상관없이 안전하게 매핑
- `MOVE` → 메모리 구조 그대로 복사 (위험), `MOVE-CORRESPONDING` → 동일 이름 필드만 안전하게 복사
```abap
MOVE-CORRESPONDING 원본변수 TO 대상변수.
```
```abap
DATA gs_flight    TYPE zsflight_b03.
DATA gs_b_flight  TYPE bc400_s_flight.

MOVE-CORRESPONDING gs_flight TO gs_b_flight.
```

</br>
</br>

---
</br>

## < ABAP 추가적인 문법 >

**1) CONCATENATE**
- 여러 문자열을 하나로 이어 붙임
- `SEPARATED BY` → 문자열 사이에 넣을 구분자(공백, 콤마 등)
```abap
CONCATENATE <문자1> <문자2> <문자3> ... INTO <결과변수>
             [SEPARATED BY <구분자>].
```
- CONCATENATE 의 INTO절에 RESPECTING BLANKS 추가 시, 빈칸을 허용함
```abap
CONCATENATE 문자1 문자2 문자3 INTO lv_result RESPECTING BLANKS.
```
```abap
DATA gv_result TYPE string.
PERFORM getToday CHANGING gv_result.
WRITE: gv_result.

FORM getToday CHANGING VALUE(p_result).
  CONCATENATE '오늘은' sy-datum+0(4) '년' sy-datum+4(2) '월' sy-datum+6(2) '일 입니다' INTO p_result.
ENDFORM.
```
</br>
</br>

**2) sy-datum**
- 현재 시스템 날짜가 자동으로 들어 있는 SAP 시스템 필드
```abap
sy-datum  →  YYYYMMDD (8자리 날짜)
```
- `+숫자(숫자)` 는 문자열에서 원하는 위치(offset)와 길이(length)만큼 잘라오는 부분 문자열 표현
- `<offset>` 위치부터 `<length>` 길이만큼 부분 문자열(substring) 을 잘라서 가져오는 문법
```abap
<변수>+<offset>(<length>)
```
</br>

---
</br>

## < 실습 코드 >
### 실습 1
- FROM 함수 이용한 날짜 출력
```abap
DATA gv_result TYPE string.
PERFORM getToday CHANGING gv_result.
WRITE: gv_result.

FORM getToday CHANGING VALUE(p_result).
  CONCATENATE '오늘은' sy-datum+0(4) '년' sy-datum+4(2) '월' sy-datum+6(2) '일 입니다' INTO p_result.
ENDFORM.
```
</br>
</br>

### 실습 2
- function group과 function module 이용
  
**1) function group 생성**

<img width="510" height="298" alt="image" src="https://github.com/user-attachments/assets/6df20037-fa62-4ad6-916a-7e099d4ff48f" />
</br>
</br>

**2) function module 생성**

<img width="531" height="135" alt="image" src="https://github.com/user-attachments/assets/db2e443c-dc3f-4e7f-8a91-4de7d08aca43" />
</br>
</br>

**3) importing, exporting, exceptions 표 채우기**

<img width="506" height="98" alt="image" src="https://github.com/user-attachments/assets/093db934-1818-4570-8cb7-ee485303aa09" />
</br>

<img width="509" height="98" alt="image" src="https://github.com/user-attachments/assets/691cef49-9590-451f-94ac-154a8eb7a623" />
</br>

<img width="510" height="119" alt="image" src="https://github.com/user-attachments/assets/bba68691-5626-47db-8631-e231139dab62" />
</br>
</br>

**4) function module 코드 수정**
```abap
FUNCTION z_bc400_03_comp_percentage.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(IV_ACT) TYPE  BC400_ACT
*"     REFERENCE(IV_MAX) TYPE  BC400_MAX
*"  EXPORTING
*"     REFERENCE(EV_PERCENTAGE) TYPE  BC400_PERC
*"  EXCEPTIONS
*"      DIVISION_BY_ZERO
*"----------------------------------------------------------------------

  IF iv_max = 0.
    ev_percentage = 0.
    RAISE division_by_zero.
  ELSE.

  ENDIF.

ENDFUNCTION.
```
</br>

**5) program 코드 수정**
```abap
*&---------------------------------------------------------------------*
*& Report ZBC400_03_COMP
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
REPORT ZBC400_03_COMP.

TYPES tv_result TYPE p LENGTH 16 DECIMALS 2.

PARAMETERS:
  pa_int1  TYPE i,
  pa_op    TYPE c LENGTH 1,
  pa_int2  TYPE i.

DATA gv_result TYPE tv_result.

IF ( pa_op = '+' OR
     pa_op = '-' OR
     pa_op = '*' OR
     pa_op = '/' AND pa_int2 <> 0 OR
     pa_op = '%' OR
     pa_op = 'P' ).

  CASE pa_op.
    WHEN '+'.
      gv_result = pa_int1 + pa_int2.
    WHEN '-'.
      gv_result = pa_int1 - pa_int2.
    WHEN '*'.
      gv_result = pa_int1 * pa_int2.
    WHEN '/'.
      gv_result = pa_int1 / pa_int2.
    WHEN '%'.
      PERFORM calc_percentage
        USING
          pa_int1
          pa_int2
        CHANGING
          gv_result.

      CALL FUNCTION 'Z_BC400_03_COMP_PERCENTAGE'
        EXPORTING
          iv_act = pa_int1
          iv_max = pa_int2
        IMPORTING
          EV_PERCENTAGE          = gv_result
        EXCEPTIONS
          DIVISION_BY_ZERO       = 1
          OTHERS = 2.

      IF sy-subrc <> 0.
        MESSAGE 'error!' TYPE 'E'.
      ENDIF.

    WHEN 'P'.
      CALL FUNCTION 'BC400_MOS_POWER'
        EXPORTING
          iv_base               = pa_int1
          iv_power              = pa_int2
        IMPORTING
          ev_result             = gv_result
        EXCEPTIONS
          power_value_too_high  = 1
          result_value_too_high = 2
          OTHERS                = 3.
      CASE sy-subrc.
        WHEN 0.
*         no action needed
        WHEN 1.
          WRITE 'Max value of power is 4'(mvp).
        WHEN 2.
          WRITE 'Result value too high'(rvh).
        WHEN 3.
          WRITE 'Unknown error'(uer).
      ENDCASE.
  ENDCASE.

  WRITE: 'Result:'(res), gv_result.

ELSEIF  pa_op = '/'  AND  pa_int2 = 0.
  WRITE: 'No division by zero!'(dbz).
ELSE.
  WRITE: 'Invalid operator!'(iop).
ENDIF.

FORM calc_percentage  USING    pv_act TYPE i
                               pv_max TYPE i
                      CHANGING cv_result TYPE tv_result.

*Simple Error Handling
  IF pv_max = 0.
    cv_result = 0.
    WRITE 'Error in percentage calculation'(epc).
  ELSE.
*Calculate result
    cv_result = pv_act / pv_max * 100.
  ENDIF.

ENDFORM.                    " calc_percentage
```
</br>
</br>

### 실습 3
- Structure 이용
  
**1) 글로벌 구조체 타입(SE11 Structure)을 이용해 Work Area 생성**
```abap
" Structure: 여러개의 컴포넌트로 구성된 Work Area (작업공간)
" Global data type을 사용하여 structure 변수 생성

DATA: gs_data   TYPE bc400_s_flight,
      gs_data2  LIKE gs_data,
      gs_flight TYPE zsflight_b03,
      gs_scarr  TYPE zscarr_b03.

gs_scarr-carrid = 'AA'.
gs_scarr-carrname = 'Hello'.
gs_scarr-currcode = 'KRW'.
gs_scarr-url = 'www.naver.com'.    " 하나의 structure에 데이터를 넣음

WRITE:/ gs_scarr-carrid,
      / gs_scarr-carrname.
```
</br>

**2) 프로그램 내에서만 사용하는 로컬 구조체 선언 + Work Area 생성**
```abap
* Local type structure
TYPES: BEGIN OF ts_flight,
          CARRID TYPE S_CARR_ID,
          CONNID TYPE S_CONN_ID,
          FLDATE TYPE S_DATE,
          CITYFROM TYPE S_FROM_CIT,
          CITYTO TYPE S_TO_CITY,
       END OF ts_flight.

DATA: gs_flight TYPE ts_flight.

gs_flight-carrid = 'AA'.
gs_flight-connid = '0017'.

WRITE:/ gs_flight-carrid,
      / gs_flight-connid.
```
</br>

**3) 글로벌 Structure를 가져와 로컬 필드를 추가한 구조체 만들기**
```abap
* DB Table을 가지고 변수 생성 시 Structure 타입의 변수가 됨.
* => 구조체를 가지고 만든 것이기 때문

**********************************************************************

* 기존 global structure 에다가 custom component 추가하여
* Local Structure 생성

DATA: BEGIN OF gs_flight.
  INCLUDE TYPE BC400_S_FLIGHT.
DATA: custom TYPE CHAR1,
      custom2 TYPE CHAR1,
      END OF gs_flight.

BREAK-POINT.

WRITE: 'okok'.
```
</br>

**4) 최종 실습**
```abap
* 1단계
DATA: gs_flight TYPE ZSFLIGHT_B03.
gs_flight-carrid = 'AA'.
gs_flight-connid = '0017'.
gs_flight-fldate = sy-datum.
gs_flight-cityfrom = 'Incheon'.
gs_flight-cityto = 'Seoul'.

WRITE:/ gs_flight-carrid,
      / gs_flight-connid,
      / gs_flight-fldate,
      / gs_flight-cityfrom,
      / gs_flight-cityto.

** 2단계
DATA: gs_b_flight TYPE BC400_S_FLIGHT.
MOVE-CORRESPONDING gs_flight TO gs_b_flight.

WRITE:/ gs_b_flight-carrid,
      / gs_b_flight-connid,
      / gs_b_flight-fldate.
```

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (11.21).md
</br>

## < Internal Table (화면 출력/데이터 처리용 메모리 테이블) >
- Internal 테이블은 프로그램 안에서 임시로 데이터를 저장·처리하는 메모리상의 테이블
- 일반 테이블은 DB에 실제로 저장되어 여러 사용자와 프로그램이 공유하는 영구 테이블
</br>

**1) Line Type**
- 내부 테이블 한 줄(Row)의 구조
- Structure 또는 Dictionary 테이블 구조를 기반으로 함
</br>

**2) Primary Key**
- key = 내부 테이블에서 검색/행 식별에 사용되는 기준 필드
  - `components` → 어떤 필드들이 키인지
  - `uniqueness` → 중복 허용 여부 (UNIQUE / NON-UNIQUE)
  - `sequence` → 정렬 여부 (Sorted 테이블에서만 의미 있음)
</br>

**3) Table Kind**
- 내부 테이블의 정렬 방식, 중복 가능 여부, 검색 성능을 결정
- 종류:
  - Standard Table (Index Table)
  - Sorted Table
  - Hashed Table
</br>
</br>

**< ABAP Internal Table 비교 >**

| 구분 | STANDARD TABLE | SORTED TABLE | HASHED TABLE |
|------|----------------|--------------|--------------|
| **Table Kind** | Standard Table | Sorted Table | Hashed Table |
| **Index Access** | ✔ 가능 | ✔ 가능 | ❌ 불가능 |
| **Key Access** | ✔ 가능 | ✔ 가능 | ✔ 가능 |
| **Key Uniqueness** | NON-UNIQUE (중복 허용) | UNIQUE / NON-UNIQUE (중복 허용/불가 둘 다 가능) | UNIQUE (중복 불가) |
| **Use In** | Mainly Index Access (주로 인덱스 접근) | Mainly Key Access (주로 키 기반 검색) | Only Key Access (키 기반 초고속 검색 전용) |

</br>
</br>

---
</br>

## < Internal Table 선언 3가지 방식 >
</br>

**1) Table Type 기반 (Global Type)**
- 이미 정의된 Table Type을 사용하여 Internal Table 선언
- Table Type에 Line Type, Table Kind, Key 등이 미리 정의되어 있어 코드가 간결
```abap
DATA <internal_table_name> TYPE <table_type>.
```
```abap
DATA gt_flights TYPE BC400_T_FLIGHTS.
DATA gt_flights TYPE tt_flights.
```
</br>
</br>
</br>

**2) Table Kind + Key 직접 정의 (Local Type)**
- Table Type 없이 Internal Table 종류(Standard/Sorted/Hashed)와 Key를 직접 지정
- Table Type 없이 바로 선언 가능, Key 조건도 자유롭게 지정
```abap
DATA <internal_table_name> TYPE <table_kind> TABLE OF <structure_type>
     WITH [UNIQUE | NON-UNIQUE] KEY <field1> <field2> ... .
```
```abap
DATA gt_iteb1 TYPE STANDARD TABLE OF BC400_S_FLIGHT WITH DEFAULT KEY.
DATA gt_item2 TYPE STANDARD TABLE OF BC400_S_FLIGHT WITH NON-UNIQUE KEY CARRID CONNID.
DATA gt_item4 TYPE SORTED TABLE OF BC400_S_FLIGHT WITH NON-UNIQUE KEY CARRID CONNID.
DATA get_item6 TYPE HASHED TABLE OF BC400_S_FLIGHT WITH UNIQUE KEY CARRID CONNID.
```
</br>
</br>
</br>

**3) 단순 Table of Structure**
- Key를 지정하지 않고 단순히 Table of Structure 선언
- 간단하게 선언 가능, Standard Table 기본
```abap
DATA <internal_table_name> TYPE TABLE OF <structure_type>.
```
```abap
DATA gt_flight2 TYPE TABLE OF BC400_S_FLIGHT.
DATA gt_flight3 TYPE TABLE OF SCARR.
DATA gt_item3 TYPE TABLE OF BC400_S_FLIGHT.
```
</br>
</br>
</br>

## < ABAP Internal Table 및 Structure 선언과 사용 예제 >
</br>

**1) Internal Table 선언 (Table Type / Structure 기반)**
- `gt_flight` : 이미 정의된 Table Type을 기반으로 Internal Table 생성.
- `gt_flight2` : Global Structure를 기반으로 Internal Table 생성.
- `gt_flight3` : DB Transparent Table 구조를 그대로 Internal Table로 선언.
- `gt_flight4` : 기존 Table gt_flight3의 구조와 동일하게 선언(LIKE 사용).
```abap
DATA: gt_flight TYPE BC400_T_FLIGHTS,   " Table type 사용
      gt_flight2 TYPE TABLE OF BC400_S_FLIGHT,   " Global structure 사용
      gt_flight3 TYPE TABLE OF SCARR, " DB Table (Transparent table) 사용
      gt_flight4 LIKE gt_flight3. " LIKE 사용해서 Internal Table 사용
```
</br>
</br>
</br>

**2) Standard Internal Table 선언**
- `gt_iteb1` : 기본 키를 가지는 표준 Internal Table.
- `gt_item2` : 지정한 필드(CARRID, CONNID)를 기준으로 비유니크 키를 가지는 표준 Internal Table.
- `gt_item3` : 키를 명시하지 않은 표준 Internal Table.
```abap
" Standard internal table
DATA: gt_iteb1 TYPE STANDARD TABLE OF BC400_S_FLIGHT
               WITH DEFAULT KEY,
      gt_item2 TYPE STANDARD TABLE OF BC400_S_FLIGHT
               WITH NON-UNIQUE KEY CARRID CONNID,
      gt_item3 TYPE TABLE OF BC400_S_FLIGHT.
```
</br>
</br>
</br>

**3) Sorted Internal Table 선언**
- `gt_item4` : 지정된 키 기준으로 항상 정렬되는 Internal Table, 중복 키 허용.
- `gt_itab5` : 지정된 키 기준으로 정렬, 중복 키 불가.
```abap
" Sorted internal table
DATA: gt_item4 TYPE SORTED TABLE OF BC400_S_FLIGHT
               WITH NON-UNIQUE KEY CARRID CONNID, " key는 띄어쓰기로 구분
      gt_itab5 TYPE SORTED TABLE OF BC400_S_FLIGHT
               WITH UNIQUE KEY CARRID CONNID.
```
</br>
</br>
</br>

**4) Hashed Internal Table 선언**
- `get_item6` : Key 기반 Hash 구조를 사용, 빠른 검색 가능, 반드시 UNIQUE KEY 필요.
```abap
* Hashed internal table
DATA: get_item6 TYPE HASHED TABLE OF BC400_S_FLIGHT
                WITH UNIQUE KEY CARRID CONNID.
```
</br>
</br>
</br>

**5) Structure 변수 선언**
```abap
" Glocal structure type
DATA gs_flight TYPE BC400_S_FLIGHT.

" transparent table 가지고도 스트럭처 변수 생성 가능
DATA gs_flight2 TYPE SCARR.

" Table type의 Line type 정보로 스트럭처 변수 생성 가능
DATA gs_flight3 TYPE LINE OF BC400_T_FLIGHTS.

" 위에서 선언한 Internal table에서 Line type만 복사하여 생성
DATA gs_flight4 LIKE LINE OF gt_iteb1.
```
</br>
</br>
</br>

**6) 기타 Table/Structure 선언**
- `aa` : Table Type 기반 Internal Table.
- `bb` : Table Type의 Table 선언.
- `cc` : Table Type의 한 행(Line Type) 구조 변수.
- `dd` : bb Table 라인과 동일한 구조 변수(LIKE LINE OF).
- `ee` : 단일 Structure 변수.
- `ff` : dd와 같은 구조의 Internal Table(LIKE TABLE OF).
```abap
DATA: aa TYPE BC400_T_CONNECTIONS,
      " Table Type 위에 또 TABLE OF를 붙일 수 없음
      bb TYPE TABLE OF BC400_T_CONNECTIONS,    " bb TYPE aa 로 바꾸기
      cc TYPE LINE OF BC400_T_CONNECTIONS,
      dd LIKE LINE OF bb,
      ee TYPE S_CARR_ID,
      ff LIKE TABLE OF dd.
```
</br>
</br>
</br>

---
</br>

## < ABAP 인터널 테이블 CRUD 명령어 >
- INDEX 사용 시 대부분 Table 이름 뒤에 TABLE 키워드 생략 가능
- INSERT만 예외적으로 `INTO TABLE` 또는 `INTO itab` 둘 다 가능

**단건 CRUD**
| 기능 | 키워드 |
|------|---------|
| 조회 (READ) | `READ TABLE itab INTO wa WITH KEY ...` |
| 추가 (CREATE) | `APPEND wa TO itab` / `INSERT wa INTO itab INDEX idx` |
| 변경 (UPDATE) | `MODIFY itab FROM wa` |
| 삭제 (DELETE) | `DELETE itab INDEX idx` / `DELETE itab WHERE ...` |

**다건 CRUD**
| 기능 | 키워드 |
|------|---------|
| 조회 (READ) | `LOOP AT itab INTO wa WHERE ...` / `LOOP AT itab FROM idx1 TO idx2` |
| 추가 (CREATE) | `APPEND LINES OF itab_src TO itab_tgt` / `INSERT LINES OF itab_src INTO itab_tgt INDEX idx` |
| 변경 (UPDATE) | `LOOP AT itab INTO wa ...` → `MODIFY itab FROM wa` |
| 삭제 (DELETE) | `DELETE itab WHERE ...` / `DELETE itab FROM idx1 TO idx2` |
</br>
</br>
</br>

**1-1) APPEND – 인터널 테이블 끝에 값 추가**
- 인터널 테이블의 맨 끝에 데이터를 추가
- Standard Table 기준 → 삽입 순서 그대로 유지
```abap
APPEND <추가할_행> TO <인터널_테이블>.
```
```abap
DATA: flight TYPE BC400_S_FLIGHT,
      flights_table TYPE STANDARD TABLE OF BC400_S_FLIGHT.

flight-carrid = 'AA'.
flight-connid = '001'.

APPEND flight TO flights_table.
```
</br>

**1-2) APPEND LINES OF – 다른 테이블의 여러 행 끝에 추가**
- `<소스_테이블>`의 여러 행을 `<대상_테이블>` 끝에 추가
```abap
APPEND LINES OF <source_table> 
       [FROM <start> [TO <end>]]    " 범위 지정 (Standard Table 전용)
       [WHERE <field1> = <value1> 
              <field2> = <value2> …]  " 조건 지정
       TO <target_table>.           " 추가할 테이블
```
```abap
APPEND LINES OF flights_table1 WHERE carrid = 'AA' TO flights_table2.
```
</br>
</br>
</br>

**2-1) INSERT – 특정 위치 또는 조건에 값 삽입**
- 조건 생략 → 맨 끝에 추가 (APPEND와 동일)
- 조건/인덱스 지정 가능 → 원하는 위치에 삽입
- INSERT 구문에는 WHERE 절은 지원되지 않음
```abap
INSERT <작업_영역> INTO <내부_테이블> [INDEX <번호>].
```
```abap
INSERT flight INTO TABLE flights_table INDEX 2.
INSERT flight INTO TABLE flights_table.  " 맨 끝
```
</br>

**2-2) INSERT LINES OF – 다른 테이블의 여러 행 삽입**
- `<소스_테이블>`의 여러 행을 `<대상_테이블>`에 삽입
```abap
INSERT LINES OF <source_table> 
       [FROM <start> [TO <end>]]        " 범위 지정 (Standard Table 전용)
       [WHERE <field1> = <value1> 
              <field2> = <value2> …]  " 조건 필터링
       INTO TABLE <target_table>       " 데이터를 삽입할 테이블
       [INDEX <n>].                    " 삽입 위치 지정
```
```abap
INSERT LINES OF flights_table1 WHERE carrid = 'AA' INTO TABLE flights_table2.
```
</br>
</br>
</br>

**3) READ – 특정 조건/위치의 값 조회**
- 조건에 맞는 첫 번째 행을 가져옴
- 성공 → `sy-subrc` = 0, 실패 → `sy-subrc` <> 0
```abap
READ TABLE <인터널_테이블> INTO <행> 
     [WITH KEY <필드1> = <값1> <필드2> = <값2> …] 
     [INDEX <위치>].
```
```abap
READ TABLE flights_table INTO flight WITH TABLE KEY carrid = 'AA' connid = '001'.
IF sy-subrc = 0.
  WRITE: / 'Flight found:', flight-carrid.
ENDIF.
```
</br>
</br>
</br>

**4) MODIFY – 기존 값 수정**
- 조건에 맞는 행을 덮어씀
- Standard Table 기준 → 조건에 맞는 여러 행이 있어도, 그 중에서 가장 먼저 나오는 한 행만 수정
- INDEX 지정 시 → 해당 위치 행만 변경
- TRANSPORTING <필드> → 지정한 필드만 수정
```abap
MODIFY <인터널_테이블> 
       FROM <행_데이터> 
       [INDEX <위치>] 
       [TRANSPORTING <필드1> <필드2> ...] 
       [WHERE <조건>].
```
```abap
flight-cityfrom = 'Seoul'.
MODIFY TABLE flights_table FROM flight.

flight-price = 20000.
MODIFY flights_table FROM flight TRANSPORTING price WHERE carrid = 'AA'.

flight-price = 15000.
MODIFY flights_table FROM flight INDEX 2.
```
</br>
</br>
</br>

**5) DELETE – 행 삭제**
- `INDEX` → 특정 위치 삭제
- `WHERE` → 조건에 맞는 행 삭제
- `FROM` → 구조체와 동일한 행 삭제
```abap
DELETE <internal_table> 
       [INDEX <n>]                 " 단일 행 삭제 (Standard Table만)
       [FROM <start> [TO <end>]]   " 범위 지정 삭제 (Standard Table 전용)
       [WHERE <field1> = <value1> <field2> = <value2> ...] 
       [FROM <work_area>] 
       [TABLE <internal_table> WHERE <condition>].
```
```abap
DELETE flights_table WHERE carrid = 'AA'.
DELETE flights_table INDEX 1.
```
</br>
</br>
</br>

**6) LOOP AT – 테이블 반복 처리**
- 인터널 테이블의 모든 행 또는 조건에 맞는 행을 반복 처리
- `WHERE` 조건 생략 시 → 테이블 전체를 반복
```abap
LOOP AT <인터널_테이블> INTO <행> [WHERE <조건>].
  " 반복하면서 처리할 코드
ENDLOOP.
```
```abap
DATA: flight TYPE BC400_S_FLIGHT,
      flights_table TYPE STANDARD TABLE OF BC400_S_FLIGHT.

* 데이터 예시
* flight_table = [
*   {carrid='AA', connid='001'},
*   {carrid='BB', connid='002'},
*   {carrid='AA', connid='003'}
* ]

LOOP AT flights_table INTO flight WHERE carrid = 'AA'.
  WRITE: / flight-carrid, flight-connid.
ENDLOOP.
```

</br>
</br>
</br>

---

</br>

## < 실습 코드 >
### 실습 1
- global structure 생성하기
<img width="1520" height="660" alt="image" src="https://github.com/user-attachments/assets/d533af41-58cf-459f-a95e-12c8662a9c39" />
</br>

<img width="1556" height="668" alt="image" src="https://github.com/user-attachments/assets/44bebdb1-9117-4787-b7bd-0146e8df7f5d" />
</br>

```abap
DATA: gs_flight TYPE ZSCLB03_DEMO.

BREAK-POINT.
gs_flight-carrid = 'AA'.

WRITE:/ gs_flight-carrid.
```
</br>
</br>

### 실습 2
**1) Standard Table에 APPEND, READ, LOOP 사용**
```abap
TYPES: BEGIN OF ty_line,
        carrid TYPE sflight-carrid,
        connid TYPE sflight-connid,
        carrname TYPE scarr-carrname,
       END OF ty_line.

**********************************************************************

* Standard table 선언
DATA: lt_tab1 TYPE STANDARD TABLE OF ty_line
              WITH DEFAULT KEY,
      lt_tab2 TYPE STANDARD TABLE OF ty_line
              WITH NON-UNIQUE KEY CARRID CONNID.

DATA: ls_line TYPE ty_line. " work-area (wa)
ls_line-carrid = 'AA'.
ls_line-connid = '0017'.
ls_line-carrname = 'Add Data'.
APPEND ls_line TO lt_tab2.

ls_line-carrid = 'BB'.
ls_line-connid = '0064'.
ls_line-carrname = 'Add Data 2'.
APPEND ls_line TO lt_tab2.

ls_line-carrid = 'AA'.
ls_line-connid = '0017'.
ls_line-carrname = 'Add Data 3'.
APPEND ls_line TO lt_tab2.  " 키 중복

LOOP AT lt_tab2 INTO ls_line.
  WRITE:/ ls_line-carrid,
          ls_line-connid,
          ls_line-carrname.
ENDLOOP.

CLEAR ls_line.  "위에서 한번 사용했으니 초기화
READ TABLE lt_tab2 INTO ls_line
     WITH KEY CARRID = 'AA' CONNID = '0017'.
WRITE:/ 'Standard table: ',
      / ls_line-carrid, ls_line-carrname.
```
</br>
</br>
</br>

**2) Sorted Table에 INSERT, READ, LOOP 사용**
```abap
TYPES: BEGIN OF ty_line,
        carrid TYPE sflight-carrid,
        connid TYPE sflight-connid,
        carrname TYPE scarr-carrname,
       END OF ty_line.

**********************************************************************

* Sorted table 선언
DATA: lt_sort TYPE SORTED TABLE OF ty_line
              WITH NON-UNIQUE KEY CARRID CONNID.

" 데이터 추가
DATA: ls_line TYPE ty_line.
ls_line-carrid ='ZZ'.
ls_line-connid = '0017'.
ls_line-carrname = 'First Data'.
INSERT ls_line INTO TABLE lt_sort.

ls_line-carrid ='AA'.
ls_line-connid = '0017'.
ls_line-carrname = 'Second Data'.
* APPEND ls_line to lt_sort. "덤프 발생
INSERT ls_line INTO TABLE lt_sort.

READ TABLE lt_sort INTO ls_line INDEX 1.

IF sy-subrc = 0.
  WRITE:/ 'Sorted 결과: ',
          ls_line-carrid, ls_line-connid.
ENDIF.

LOOP AT lt_sort INTO ls_line.
  WRITE:/ ls_line-carrid,
          ls_line-connid,
          ls_line-carrname.
ENDLOOP.
```
</br>
</br>
</br>

**3) Hashed Table에 INSERT와 READ TABLE(키 기준) 사용**
```abap
TYPES: BEGIN OF ty_line,
        carrid TYPE sflight-carrid,
        connid TYPE sflight-connid,
        carrname TYPE scarr-carrname,
       END OF ty_line.

**********************************************************************

" Hashed Internal Table
DATA: lt_hash TYPE HASHED TABLE OF ty_line
              WITH UNIQUE KEY CARRID CONNID.
DATA: ls_line TYPE ty_line.
ls_line-carrid = 'AA'.
ls_line-connid = '0017'.
ls_line-carrname = 'Add Data'.
INSERT ls_line INTO TABLE lt_hash.

CLEAR ls_line.
*READ TABLE lt_hash INTO ls_line INDEX 1. " 에러 (해쉬테이블에는 인덱스 x)
READ TABLE lt_hash INTO ls_line
     WITH KEY CARRID = 'AA' CONNID = '0017'.
IF sy-subrc = 0.
  WRITE:/ 'Hashed 결과: ',
          ls_line-carrid, ls_line-connid.
ENDIF.
```
</br>
</br>
</br>

**4) DB 테이블 데이터를 Internal Table에 SELECT, LOOP 사용**
```abap
DATA: gt_flight TYPE TABLE OF SFLIGHT,
      gs_flight TYPE SFLIGHT.

SELECT *
  INTO TABLE gt_flight
  FROM sflight
  WHERE carrid = 'AA'
    AND CONNID = '0017'.

LOOP AT gt_flight INTO gs_flight.
  WRITE:/ gs_flight-carrid,
          gs_flight-connid,
          gs_flight-fldate.
ENDLOOP.
```
</br>
</br>
</br>

**5) Internal Table에 APPEND, INSERT, LOOP 사용**
```abap
DATA: gs_flight TYPE SFLIGHT,
      gt_flight LIKE TABLE OF gs_flight.

gs_flight-carrid = 'AA'.
gs_flight-connid = '0017'.
gs_flight-fldate = '20250501'.
gs_flight-price = '10000'.
gs_flight-currency = 'USD'.
gs_flight-seatsmax = 400.
gs_flight-seatsocc = 200.
APPEND gs_flight TO gt_flight.

gs_flight-carrid = 'BB'.
gs_flight-connid = '0027'.
gs_flight-fldate = '20260501'.
gs_flight-price = '1000'.
gs_flight-currency = 'EUR'.
gs_flight-seatsmax = 550.
gs_flight-seatsocc = 20.
APPEND gs_flight TO gt_flight.

gs_flight-carrid = 'AB'.
gs_flight-connid = '0064'.
gs_flight-fldate = '20270501'.
gs_flight-price = '2500'.
gs_flight-currency = 'EUR'.
gs_flight-seatsmax = 300.
gs_flight-seatsocc = 250.
INSERT gs_flight INTO TABLE gt_flight.

gs_flight-carrid = 'AC'.
gs_flight-connid = '0224'.
gs_flight-fldate = '20280501'.
gs_flight-price = '3000'.
gs_flight-currency = 'EUR'.
gs_flight-seatsmax = 60.
gs_flight-seatsocc = 5.
INSERT gs_flight INTO gt_flight INDEX 1.

LOOP AT gt_flight INTO gs_flight.
  WRITE:/ gs_flight-carrid,
          gs_flight-connid,
          gs_flight-fldate,
          gs_flight-price,
          gs_flight-currency,
          gs_flight-seatsmax,
          gs_flight-seatsocc.
ENDLOOP.
```
</br>
</br>
</br>

**6) Standard Table에 APPEND, INSERT, LOOP 사용**
```abap
DATA: gs_tab TYPE TABLE OF ZSCLB03_DEMO,    " 그냥 TABLE OF 하면 standard
      gs_line TYPE ZSCLB03_DEMO.

gs_line-CARRID = 'AA'.
gs_line-CARRNAME = '김예원'.
gs_line-CONNID = '0017'.
gs_line-CITYFROM = '인천'.
gs_line-CITYTO = '서울'.
APPEND gs_line TO gs_tab.

gs_line-CARRID = 'BB'.
gs_line-CARRNAME = '김예원'.
gs_line-CONNID = '0016'.
gs_line-CITYFROM = '광주'.
gs_line-CITYTO = '철원'.
INSERT gs_line INTO TABLE gs_tab.

gs_line-CARRID = 'CC'.
gs_line-CARRNAME = '김예원'.
gs_line-CONNID = '0015'.
gs_line-CITYFROM = '부산'.
gs_line-CITYTO = '인천'.
INSERT gs_line INTO gs_tab INDEX 1.

CLEAR gs_line.
LOOP AT gs_tab INTO gs_line.
  WRITE:/ gs_line-CARRID,
          gs_line-CARRNAME,
          gs_line-CONNID,
          gs_line-CITYFROM,
          gs_line-CITYTO.
ENDLOOP.
```
</br>

**7) Standard Table에서 READ, MODIFY, DELETE, LOOP 사용**
```abap
DATA: gs_flight TYPE SFLIGHT,
      gt_flight LIKE STANDARD TABLE OF gs_flight
      WITH NON-UNIQUE KEY CARRID CONNID FLDATE.

gs_flight-carrid = 'AA'.
gs_flight-connid = '0017'.
gs_flight-fldate = '20250501'.
gs_flight-price = '10000'.
gs_flight-currency = 'USD'.
gs_flight-seatsmax = 400.
gs_flight-seatsocc = 200.
APPEND gs_flight TO gt_flight.

gs_flight-carrid = 'BB'.
gs_flight-connid = '0027'.
gs_flight-fldate = '20260501'.
gs_flight-price = '1000'.
gs_flight-currency = 'EUR'.
gs_flight-seatsmax = 550.
gs_flight-seatsocc = 20.
APPEND gs_flight TO gt_flight.

gs_flight-carrid = 'AB'.
gs_flight-connid = '0027'.
gs_flight-fldate = '20260501'.
gs_flight-price = '1000'.
gs_flight-currency = 'EUR'.
gs_flight-seatsmax = 550.
gs_flight-seatsocc = 20.
APPEND gs_flight TO gt_flight.

gs_flight-carrid = 'BZ'.
gs_flight-connid = '0027'.
gs_flight-fldate = '20260501'.
gs_flight-price = '1000'.
gs_flight-currency = 'EUR'.
gs_flight-seatsmax = 550.
gs_flight-seatsocc = 20.
APPEND gs_flight TO gt_flight.

READ TABLE gt_flight INTO gs_flight
     WITH TABLE KEY CARRID = 'AA' CONNID = '0017' FLDATE = '20250501'.

*READ TABLE gt_flight INTO gs_flight
*     INDEX 1.

" 스트럭처의 값 변경
gs_flight-price = '9500'.
gs_flight-seatsmax = 555.

" 변경된 스트럭처를 Internal table의 첫번째 레코드에 적용(변경)
*MODIFY gt_flight FROM gs_flight INDEX 1.
MODIFY TABLE gt_flight FROM gs_flight.
*MODIFY gt_flight FROM gs_flight TRANSPORTING PRICE
*  WHERE CARRID = 'AA'.
MODIFY gt_flight FROM gs_flight INDEX 1 TRANSPORTING PRICE.

CLEAR gs_flight.
" READ TABLE 구분으로 Itab의 1번째 레코드 읽어서 gs_flight에 담는다
READ TABLE gt_flight INTO gs_flight INDEX 1.

  " 읽어온 1번째 레코드 gs_flight를 출력
*  WRITE:/ gs_flight-carrid,
*          gs_flight-connid,
*          gs_flight-fldate,
*          gs_flight-price,
*          gs_flight-seatsmax.

* Internal table에서 데이터 삭제
* => DALETE <itab> <condition>
*DELETE gt_flight INDEX 1.
*DELETE gt_flight FROM 3. " 3 이후부터 전부 삭제
*DELETE gt_flight TO 2.
*DELETE gt_flight FROM 2 TO 4. " 범위 지정하여 삭제
DELETE gt_flight WHERE carrid = 'AA'
                       AND connid = '0017'
                       AND fldate = '20250501'.

LOOP AT gt_flight INTO gs_flight.
  WRITE:/ gs_flight-carrid,
          gs_flight-connid,
          gs_flight-fldate,
          gs_flight-price,
          gs_flight-currency,
          gs_flight-seatsmax,
          gs_flight-seatsocc.
ENDLOOP.
```
</br>

**8) Standard Table에서 APPEND/INSERT LINES, MODIFY, DELETE, LOOP 사용**
```abap
TYPES: BEGIN OF ty_person,
         fname TYPE s_fname,
         lname TYPE s_lname,
       END OF ty_person.

DATA: gs_data  TYPE ty_person,
      gt_itab1  TYPE TABLE OF ty_person,
      gt_itab2 LIKE gt_itab1.

gs_data-fname = 'Hong'.
gs_data-lname = 'Gildong'.
APPEND gs_data TO gt_itab1.

gs_data-fname = 'Kim'.
gs_data-lname = 'donggu'.
APPEND gs_data TO gt_itab1.

" itab1의 전체 레코드를 itab2에 추가
APPEND LINES OF gt_itab1 TO gt_itab2.
INSERT LINES OF gt_itab1 INTO TABLE gt_itab2.

" 범위값 지정하여 여러 건의 레코드를 테이블에 추가
APPEND LINES OF gt_itab1 FROM 1 TO 2 TO gt_itab2.
INSERT LINES OF gt_itab1 FROM 2 INTO TABLE gt_itab2.
INSERT LINES OF gt_itab1 TO 2 INTO TABLE gt_itab2.

" Loop문으로 돌면서 modify
LOOP AT gt_itab2 INTO gs_data.
  gs_data-fname = '변경'.
  MODIFY gt_itab2 FROM gs_data.
ENDLOOP.

" Modify 적용 후, 적용된 Internal table을 Loop 사용하여 출력해보기
LOOP AT gt_itab2 INTO gs_data.
  WRITE:/ sy-tabix,
          gs_data-fname,
          gs_data-lname.
ENDLOOP.

ULINE.

" 범위값 지정하여 삭제
DELETE gt_itab2 WHERE lname = 'Gildong'.

" LOOP AT gt_itab2 INTO gs_data WHERE lname = 'Yewon'.
LOOP AT gt_itab2 INTO gs_data.
  WRITE:/ sy-tabix,
          gs_data-fname,
          gs_data-lname.
ENDLOOP.
```

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (11.24).md
</br>

# Internal Table 정리
</br>

**1) MOVE-CORRESPONDING**
- 동일한 이름을 가진 필드끼리 자동으로 값 복사
- 워크에어리어나 내부 테이블 행 단위로 사용 가능
```abap
MOVE-CORRESPONDING <source> TO <target>.
```
</br>
</br>

**2) SORT**
- 내부 테이블의 데이터를 지정 필드 기준으로 정렬
- Standard Table 기준, Sorted/Hashed Table에서는 일부 옵션 불가
```abap
SORT <itab>.                                " Table의 키 필드 기준 오름차순
SORT <itab> BY <field>.                     " 특정 필드 기준 오름차순(생략 시 기본)
SORT <itab> BY <field1> DESCENDING
               <field2> ASCENDING.            " field1 내림차순, field2 오름차순(생략 시 기본)
SORT <itab> BY <field1> <field2> DESCENDING. `" field1 오름차순(생략 시 기본), field2 내림차순
```
```abap
DATA: gt_flight TYPE TABLE OF flight.

" 기본 키 기준 정렬
SORT gt_flight.

" 단일 필드 기준 정렬
SORT gt_flight BY carrid.

" 다중 필드 정렬
SORT gt_flight BY carrid DESCENDING connid ASCENDING.
SORT gt_flight BY carrid connid DESCENDING.
```
</br>
</br>

**3) WITH HEADER LINE**
- 내부 테이블 안에 자동으로 한 줄(row)을 나타내는 구조를 생성
- 테이블 이름과 동일한 구조가 만들어져 별도 워크에어리어 없이 한 줄 데이터를 바로 사용 가능
  - `itab[]` → 테이블 전체
  - `itab` → 테이블의 헤더라인(한 줄)
```abap
DATA: <itab> TYPE TABLE OF <structure> WITH HEADER LINE.
```
```abap
DATA: gt_flight TYPE TABLE OF flight WITH HEADER LINE.

" 헤더라인 사용 예시
gt_flight-carrid = 'AA'.
APPEND gt_flight.
```
</br>
</br>

**4) REFRESH**
- 내부 테이블 내용 초기화
- 테이블이 존재하면 바디(데이터: `itab[]`)만 삭제, 구조와 타입은 유지
- 테이블이 없으면 생성 후 초기화
```abap
REFRESH <itab>.
```
```abap
DATA: gt_flight TYPE TABLE OF flight.

" 내부 테이블 내용 삭제
REFRESH gt_flight.
```
</br>
</br>

**5) CLEAR**
- 변수/워크에어리어를 초기화
- 숫자는 0, 문자형은 공백, 구조는 내부 필드별 초기화
- 단일 필드 또는 전체 구조 초기화 가능
```abap
CLEAR <variable>.
```
```abap
DATA: ls_flight TYPE flight.

CLEAR ls_flight.
" 모든 필드 0/공백으로 초기화
```
</br>
</br>

**6) FREE**
- 내부 테이블의 메모리까지 완전히 해제
- REFRESH와 달리 테이블 자체 메모리 공간도 반환
```abap
FREE <itab>.
```
```abap
DATA: gt_flight TYPE TABLE OF flight.

FREE gt_flight.
" 내부 테이블 삭제 + 메모리 해제
```
</br>
</br>
</br>

---
</br>

## < ABAP 추가 문법 >
</br>

**1) SELECT**
- `SELECT` = DB 조회, `LOOP` = 내부 테이블 순회
- ABAP 프로그램에서 데이터베이스 테이블의 데이터를 읽어오는 SQL 명령어
- `<field>`와 `<target>`의 구조가 동일해야 함
```abap
SELECT <field1> <field2> ...
  FROM <table>
  [INTO <target>]
  [WHERE <condition>]
  [ORDER BY <field>].
```
```abap
DATA: lt_flight TYPE TABLE OF sflight,
      ls_flight TYPE sflight.

" 모든 데이터 조회
SELECT * FROM sflight INTO TABLE lt_flight.

" 조건 조회
SELECT carrid connid
  FROM sflight
  INTO TABLE lt_flight
  WHERE carrid = 'AA'
  ORDER BY connid.
```
</br>
</br>

**2) Single (1건 조회)**
- 조건에 맞는 단일 레코드를 조회할 때 사용
- 부분 필드 조회 시 나머지 필드는 초기화됨
```abap
SELECT SINGLE <field1> <field2> ...
  FROM <table>
  INTO <target>
  WHERE <condition>.
```
```abap
DATA: ls_flight TYPE sflight.

" 단일 레코드 조회
SELECT SINGLE carrid connid
  FROM sflight
  INTO ls_flight
  WHERE carrid = 'AA' AND connid = '0017'.

WRITE: / ls_flight-carrid, ls_flight-connid.
```
</br>
</br>

**3) CORRESPONDING FIELDS OF**
- 이름이 같은 필드만 매핑
- 나머지 필드는 기존값 유지
```abap
<target_structure> = CORRESPONDING FIELDS OF <source_structure>.
```
- CORRESPONDING FIELDS OF 사용했을 때
```abap
DATA: ls_flight TYPE sflight.
ls_flight-cityfrom = 'Seoul'.  " 기존 값

SELECT SINGLE seatmax seatsocc
  FROM sflight
  INTO CORRESPONDING FIELDS OF ls_flight
  WHERE carrid = 'AA' AND connid = '0017'.

" 결과:
" ls_flight-seatmax = DB 값
" ls_flight-seatsocc = DB 값
" ls_flight-cityfrom = 'Seoul' (기존 값 그대로)
```
- CORRESPONDING FIELDS OF 사용하지 않았을 때
```abap
DATA: ls_flight TYPE sflight.
CLEAR ls_flight.

SELECT SINGLE seatmax seatsocc
  FROM sflight
  INTO ls_flight
  WHERE carrid = 'AA' AND connid = '0017'.

" 결과:
" ls_flight-seatmax = DB 값
" ls_flight-seatsocc = DB 값
" ls_flight-cityfrom = 초기화 (빈 값)
```
</br>
</br>

**4) SELECT … ENDSELECT (Row-by-Row)**
- 한 줄씩 DB에서 읽어오고, 읽을 때마다 바로 처리하는 방식 (다 건 SELECT 반복 조회)
- DB를 한 줄 가져올 때마다 계속 DB를 다시 호출하는 방식 → 느림
- 반면에, `LOOP AT`은 DB에서 한 번에 전체 데이터를 가져온 뒤 메모리에서 반복 → 빠름
- `sy-dbcnt` 사용 가능
```abap
SELECT <필드목록>                  " <필드목록> : 가져올 컬럼 이름 (예: carrid, connid)
  FROM <테이블명>                  " <테이블명> : DB 테이블 이름 (예: sflight)
  INTO <워크에어리어 변수>          " <워크에어리어 변수> : 데이터를 담을 ABAP 변수/구조
  [WHERE <조건문>]                 " WHERE : 선택 조건 (선택 사항)
  [ORDER BY <정렬필드>].            " ORDER BY : 정렬 조건 (선택 사항)
  
  " 처리 로직 작성 (레코드 하나씩 처리)
  
ENDSELECT.
```
```abap
DATA: ls_connect TYPE spfli.

SELECT *
  FROM spfli
  INTO ls_connect
  WHERE carrid = 'AA'.

  WRITE: / ls_connect-connid.
ENDSELECT.
```
</br>
</br>

**5) SELECT … INTO TABLE (Array Fetch)**
- 조건에 맞는 데이터 전체를 한 번에 인터널 테이블로 가져옴
- 한 번에 전체 레코드 Fetch → 빠름
```abap
SELECT <필드목록>
  FROM <테이블명>
  INTO [CORRESPONDING FIELDS OF] TABLE <인터널테이블>
  [WHERE <조건>].
```
```abap
DATA: lt_connect TYPE TABLE OF spfli.

SELECT *
  FROM spfli
  INTO TABLE lt_connect
  WHERE carrid = 'AA'.

LOOP AT lt_connect INTO DATA(ls_connect).
  WRITE: / ls_connect-connid.
ENDLOOP.
```
</br>
</br>

**6) SELECT-OPTIONS**
- 사용자가 입력한 범위나 조건을 DB 조회용으로 저장하는 ABAP 키워드
- 내부적으로 테이블 구조로 만들어지며, 단일 값, 범위, 제외 조건까지 처리 가능
- FOR 뒤에는 `데이터 오브젝트(필드)`가 들어가야 함.
```abap
SELECT-OPTIONS: <옵션이름> FOR <필드> [DEFAULT <값>].
```
```abap
DATA: gt_connect TYPE TABLE OF spfli,
      gs_connect TYPE spfli.

PARAMETERS: pa_car TYPE s_carr_id DEFAULT 'AA'.

" 사용자 입력 범위 생성 (connid 17이 기본값)
SELECT-OPTIONS: so_con FOR gs_connect-connid DEFAULT '17'.

" 조회 시 SELECT-OPTIONS 범위 적용
SELECT *
  FROM spfli
  INTO CORRESPONDING FIELDS OF TABLE gt_connect
  WHERE carrid = pa_car
    AND connid IN so_con.

LOOP AT gt_connect INTO gs_connect.
  WRITE:/ gs_connect-carrid,
        gs_connect-connid,
        gs_connect-cityfrom.
ENDLOOP.
```
</br>
</br>
</br>

---
</br>

## < ABAP 데이터 모델과 데이터베이스 관계 이해 >
**1) ABAP Dictionary (SE11)**
- 데이터 구조를 논리적으로 정의하는 곳
- 테이블, 뷰, 구조, 데이터 요소 등을 설계하지만, 실제 데이터는 저장하지 않음
- 프로그램에서 사용할 데이터의 설계도 역할을 합니다.
- Transparent Table로 정의하면 DB에 1:1 매핑됩니다.
</br>
</br>

**2) Relational Database (DB)**
- 실제 데이터를 물리적으로 저장하는 공간
- Dictionary에서 정의한 테이블 구조를 기반으로 DB에 생성
- 데이터가 존재하며, 프로그램에서 읽고 쓸 수 있음
</br>
</br>

**3) Transparent Table**
- Dictionary에서 정의하면 DB에 1:1 매핑되는 테이블
- 구조를 알 수 있기 때문에 프로그램에서는 DATA <structure>로 선언하여 바로 사용 가능합니다.
- MANDT(Client) 필드는 항상 포함되어야 하는 필수 필드
  - 다중 클라이언트 환경에서 데이터 구분용
  - SAP 시스템에서 클라이언트를 식별하는 역할
  - 예: `MANDT = client`

 </br>
 
  <img width="559" height="378" alt="image" src="https://github.com/user-attachments/assets/a577c609-6dbb-4d44-8da5-3c0d9f6978bd" />

</br>
</br>
</br>

## < ABAP 3티어 구조와 Open SQL 처리 흐름 >
</br>

### ABAP 3티어 구조
1) Application Layer (애플리케이션 서버)
   - ABAP 프로그램이 실행되는 곳
   - 비즈니스 로직 처리
2) Database Layer (DB 서버)
   - 실제 데이터를 저장하는 곳
   - RDBMS (Oracle, HANA 등)
3) Presentation Layer (UI)
   - 사용자와 시스템이 상호작용하는 인터페이스
</br>


### SQL 사용 방식
**1) Native SQL**
- 특정 DB에 맞는 SQL 문을 직접 작성
- DB 고유 기능 활용 가능
- 다른 DB로 변경하면 SQL 문도 수정해야 함

**2) Open SQL**
- ABAP에서 표준 SQL 문법 사용
- Database Interface를 거쳐 DB에 맞게 변환
- DB 종류가 바뀌어도 프로그램 수정 없이 그대로 사용 가능
</br>


### Database Interface 역할
1. Open SQL 문법 체크
2. Open SQL → Native SQL 변환
3. 결과를 버퍼에 저장
   
<img width="498" height="341" alt="image" src="https://github.com/user-attachments/assets/c440c952-b86d-4e29-a5c5-9b86499b082a" />
</br>

<img width="478" height="310" alt="image" src="https://github.com/user-attachments/assets/1e2b9d76-178b-4210-9fca-a5d5d0f38ca8" />

</br>
</br>

---

</br>

## < 실습 코드 >

### 실습 1
- LOOP AT 반복문과 MODIFY, Header Line, Sort를 이용하여 결과 출력
```abap
DATA: gs_data TYPE bc400_s_flight,
      gt_data TYPE TABLE OF bc400_s_flight.

" Header Line이 포함된 인터널 테이블 변수 선언
" => 아래에서 사용한 gs_data/gt_data를 gt_hline으로 바꿔보는걸로..
DATA: gt_data2 TYPE TABLE OF bc400_s_flight WITH HEADER LINE.

SELECT carrid connid fldate seatsmax seatsocc
  FROM sflight
  INTO TABLE gt_data
  WHERE carrid = 'AA'.

" 1) 만약 sy-subrc가 0 이라면
" gt_data를 LOOP 돌면서 Percentage 계산하여 MODIFY를 이용해 반영한다.
" 계산식 : percentage = seatsocc * 100 / seatmax

IF ( sy-subrc = 0 ).
  LOOP AT gt_data INTO gs_data.
    gs_data-percentage = gs_data-seatsocc * 100 / gs_data-seatsmax.
    MODIFY gt_data FROM gs_data.
  ENDLOOP.
ENDIF.

SORT gt_data BY connid ASCENDING
                percentage DESCENDING.

" 2) percentage 반영된 itab을 LOOP 돌면서,
"    percentage 가 80을 초과하는 레코드만 출력한다. (출력필드는 전체필드 기준)

CLEAR gs_data.
LOOP AT gt_data INTO gs_data WHERE percentage > 80.
  WRITE:/ gs_data-carrid,
          gs_data-connid,
          gs_data-fldate,
          gs_data-seatsmax,
          gs_data-seatsocc,
          gs_data-percentage.
ENDLOOP.
```
</br>
</br>
</br>

### 실습 2
- function module로 carrid, connid를 받으면 spfli에서 1건 조회하여 반환하는 로직 구현
  
**1) Import 표 채우기**

<img width="599" height="127" alt="image" src="https://github.com/user-attachments/assets/356d3c61-3fff-442c-a3d2-f36c32fd3eb8" />

</br>

**2) Export 표 채우기**

<img width="599" height="108" alt="image" src="https://github.com/user-attachments/assets/e7aaadb5-08f8-42f9-b6a3-24d1c4c268ba" />

</br>

**3) Exceptions 표 채우기**

<img width="599" height="130" alt="image" src="https://github.com/user-attachments/assets/1e247174-54a7-465d-b975-cc45e696f5c0" />

</br>
</br>

**4) Function Module 코드**
```abap
FUNCTION z_bc400_03_connection_get.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(IV_CARRID) TYPE  S_CARR_ID
*"     REFERENCE(IV_CONNID) TYPE  S_CONN_ID
*"  EXPORTING
*"     REFERENCE(ES_CONNECTION) TYPE  BC400_S_CONNECTION
*"  EXCEPTIONS
*"      NO_DATA
*"----------------------------------------------------------------------

  SELECT SINGLE carrid connid cityfrom airpfrom cityto airpto fltime deptime
    FROM spfli
    INTO es_connection
    WHERE carrid = iv_carrid AND connid = iv_connid.

  IF sy-subrc <> 0.
    RAISE no_data.
  ENDIF.

ENDFUNCTION.
```
</br>

**5) Program 코드**
```abap
PARAMETERS: p_carrid TYPE c LENGTH 3,
            p_connid TYPE n LENGTH 4.
DATA: gs_data TYPE bc400_s_connection.

CALL FUNCTION 'Z_BC400_03_CONNECTION_GET'
  EXPORTING
    iv_carrid     = p_carrid
    iv_connid     = p_connid
  IMPORTING
    es_connection = gs_data
  EXCEPTIONS
    no_data       = 1
    OTHERS        = 2.

IF sy-subrc <> 0.
  MESSAGE '데이터가 없습니다.' TYPE 'E'.
ELSE.
  WRITE:/ gs_data-carrid, gs_data-connid,
          gs_data-cityfrom, gs_data-airpfrom,
          gs_data-cityto, gs_data-airpto,
          gs_data-fltime, gs_data-deptime,
          gs_data-arrtime.
ENDIF.
```
</br>
</br>
</br>

### 실습 3
- select 세 가지 종류
  
**1) Single Select (단 건 조회)**
```abap
* SELECT LOOP
DATA: ls_connect  TYPE BC400_s_connection,
      lt_connects LIKE TABLE OF ls_connect.

PARAMETERS: pa_car TYPE s_carr_id.

SELECT *
  FROM spfli
  INTO CORRESPONDING FIELDS OF ls_connect
  WHERE carrid = pa_car.
  " 참고) 여기선 sy-dbcnt로 index를 얻을 수 있음
    APPEND ls_connect TO lt_connects.
  WRITE: ls_connect-arrtime.
ENDSELECT.

IF sy-subrc <> 0.
  MESSAGE 'Data is not exist' TYPE 'E'.
ELSE.
  cl_demo_output=>display( lt_connects ).
ENDIF.
```
</br>

**2) SELECT ~ ENDSELECT (다 건 반복 조회)**
```abap
FUNCTION z_bc400_03_flightlist_get.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(IV_CARRID) TYPE  S_CARR_ID
*"     REFERENCE(IV_CONNID) TYPE  S_CONN_ID
*"  EXPORTING
*"     REFERENCE(ET_FLIGHTS) TYPE  BC400_T_FLIGHTS
*"  EXCEPTIONS
*"      NO_DATA
*"----------------------------------------------------------------------
  DATA: ls_flight TYPE bc400_s_flight.

  SELECT carrid connid fldate seatsmax seatsocc
    FROM sflight
    INTO ls_flight
    WHERE carrid = iv_carrid AND connid = iv_connid.
      ls_flight-percentage = ( ls_flight-seatsmax / ls_flight-seatsocc ) * 100.
      APPEND ls_flight TO et_flights.
  ENDSELECT.

  IF sy-subrc <> 0.
    RAISE no_data.
  ELSE.
    SORT et_flights BY percentage DESCENDING.
  ENDIF.

ENDFUNCTION.
```
</br>

**3) SELECT ~ INTO TABLE (다 건 한번에 조회)**
```abap
FUNCTION Z_BC400_03_FLIGHTLIST_GET_OPT.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(IV_CARRID) TYPE  S_CARR_ID
*"     REFERENCE(IV_CONNID) TYPE  S_CONN_ID
*"  EXPORTING
*"     REFERENCE(ET_FLIGHTS) TYPE  BC400_T_FLIGHTS
*"  EXCEPTIONS
*"      NO_DATA
*"----------------------------------------------------------------------

DATA: ls_flight TYPE bc400_s_flight.

SELECT carrid connid fldate seatsmax seatsocc
  FROM sflight
  INTO TABLE et_flights
  WHERE carrid = iv_carrid AND connid = iv_connid.

IF sy-subrc <> 0.
    RAISE no_data.
  ELSE.
    LOOP AT et_flights INTO ls_flight.
      ls_flight-percentage = ( ls_flight-seatsmax / ls_flight-seatsocc ) * 100.
      MODIFY et_flights FROM ls_flight INDEX sy-tabix TRANSPORTING percentage.
    ENDLOOP.

    SORT et_flights BY percentage DESCENDING.
  ENDIF.

ENDFUNCTION.
```
</br>

**4) SELECT-OPTIONS**
```abap
DATA: gs_connect TYPE BC400_S_CONNECTION,
      gt_connect TYPE BC400_T_CONNECTIONS.
DATA: gv_dt TYPE S_DATE.

PARAMETERS: pa_car TYPE s_carr_id DEFAULT 'AA'.

SELECT-OPTIONS: so_con FOR gs_connect-connid DEFAULT '17',
                so_fdt FOR gv_dt.
*SELECT-OPTIONS: so_con2 FOR S_CONN_ID. " 오류!
* => FOR 뒤에는 TYPE이 들어오는게 아니라 DATA Object

SELECT *
  INTO CORRESPONDING FIELDS OF TABLE gt_connect
  FROM spfli
  WHERE carrid = pa_car
    AND connid IN so_con.

LOOP AT gt_connect INTO gs_connect.
  WRITE:/ gs_connect-carrid,
        gs_connect-connid,
        gs_connect-cityfrom.
ENDLOOP.
```

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (11.25).md
</br>

## < SELECT 관련 함수 >

### 1) SELECT 집계 함수
- 데이터베이스 테이블의 값을 요약/통계 내는 함수
- 단일 값 계산, 그룹별 계산 가능
- `COUNT`, `MIN`, `MAX`, `SUM`, `AVG`
```abap
SELECT COUNT(*) AS <별칭_총레코드수>,
       MIN(<필드>) AS <별칭_최소값>,
       MAX(<필드>) AS <별칭_최대값>,
       SUM(<필드>) AS <별칭_합계>,
       AVG(<필드>) AS <별칭_평균>
  FROM <테이블>
  INTO <워크에어리어 또는 내부테이블>
  WHERE <조건>            "선택적
  GROUP BY <필드>          "필요 시
  HAVING <조건>           "필요 시
```
```abap
DATA: lt_flightocc TYPE TABLE OF sflight_occ.

SELECT carrid,
       COUNT(*) AS total_flights,
       MIN(seatsocc) AS min_seats,
       MAX(seatsocc) AS max_seats,
       SUM(seatsocc) AS sum_seats,
       AVG(seatsocc) AS avg_seats
  FROM sflight
  INTO TABLE @lt_flightocc
  GROUP BY carrid
  HAVING COUNT(*) >= 5.

" 각 carrid별 항공편 수, 좌석 최소/최대/합계/평균 조회
" 항공편 5개 이상인 carrid만 포함
```
- `COUNT( DISTINCT 필드명 )` : 중복이 제거된 필드의 갯수
```abap
" 전체 유니크 항공사 수
SELECT COUNT(DISTINCT carrid) 
  FROM sflight 
  INTO @DATA(total).
```
</br>
</br>

### 2) SELECT - GROUP BY + HAVING
- `GROUP BY` → 특정 필드 기준으로 레코드를 그룹화
- `HAVING` → 그룹화된 결과에 조건 적용 (WHERE는 개별 행 조건, HAVING은 그룹 조건)
```abap
SELECT <그룹필드1> <그룹필드2> …,
       <집계함수1> AS <별칭1>,
       <집계함수2> AS <별칭2>
  FROM <DB 테이블>
  INTO <워크에어리어 또는 내부 테이블>
  WHERE <조건>           "선택적
  GROUP BY <그룹필드1> <그룹필드2> …
  HAVING <조건>.         "그룹 조건
```
```abap
SELECT carrid,
       COUNT(*) AS total_flights
  FROM sflight
  INTO TABLE @lt_flight
  GROUP BY carrid
  HAVING COUNT(*) >= 5.      " 항공편 수가 5개 이상인 carrid만 포함
```
</br>
</br>

### 3) SELECT - WHERE 조건
- 조건에 맞는 데이터만 조회할 때 사용
- `%` : 0개 이상 문자 대체, `_` : 정확히 1글자 대체
  
| 연산자 | 설명 |
|---|---|
| `=`, `<`, `>`, `<=`, `>=`, `<>` | 비교 연산자 (같다, 크다, 작다 등) |
| `IN (dobj1, dobj2, …)` | 값 목록에 포함 여부 |
| `BETWEEN dobj1 AND dobj2` | 범위 내 값 포함 |
| `LIKE dobj1` | 패턴 매칭 (`%`, `_` 사용) |
| `IN seltab` | 내부 테이블 값 포함 여부 |
| `IS [NOT] NULL` | NULL 여부 검사 |
| `AND`, `OR`, `NOT` | 논리 조건 결합 / 부정 |

</br>

```abap
DATA: lt_sflight TYPE TABLE OF sflight,
      lt_spfli   TYPE TABLE OF spfli.

SELECT * FROM sflight
  INTO TABLE @lt_sflight
  WHERE seats > 10.
" 결과 예시: seats가 11, 20, 50 등 10 초과인 항공편 조회

SELECT * FROM sflight
  INTO TABLE @lt_sflight
  WHERE carrid IN ('AA','LH').
" 결과 예시: carrid가 'AA' 또는 'LH'인 항공편 조회

SELECT * FROM spfli
  INTO TABLE @lt_spfli
  WHERE cityfrom LIKE 'S%O'.
" 결과 예시: cityfrom이 'S'로 시작하고 'O'로 끝나는 도시 조회
" 예: 'SEOUL', 'STOCKHOLM'

DATA: gt_carriers TYPE TABLE OF sflight-carrid.
" (gt_carriers 내부에 carrid 값이 들어있다고 가정)
SELECT * FROM sflight
  INTO TABLE @lt_sflight
  WHERE carrid IN @gt_carriers.
" 결과 예시: 내부 테이블 gt_carriers에 포함된 carrid의 항공편 조회

SELECT * FROM sflight
  INTO TABLE @lt_sflight
  WHERE seats IS NOT NULL.
" 결과 예시: seats 컬럼 값이 NULL이 아닌 모든 항공편 조회

SELECT * FROM sflight
  INTO TABLE @lt_sflight
  WHERE carrid = 'AA' AND seats > 10.
" 결과 예시: carrid가 'AA'이고 seats가 10 초과인 항공편 조회
```
</br>
</br>

### 4) SELECT … ORDER BY
- 조회 결과를 특정 필드 기준으로 정렬
```abap
SELECT <필드1> <필드2> … 
  FROM <테이블>
  INTO TABLE @<내부테이블>
  WHERE <조건>
  ORDER BY <필드> [ASCENDING|DESCENDING].
```
```abap
DATA: lt_sflight TYPE TABLE OF sflight.

" 프라이머리 키(CARRID + CONNID) 순서대로 조회
SELECT carrid connid seats
  FROM sflight
  INTO TABLE @lt_sflight
  ORDER BY PRIMARY KEY.
" 결과: carrid 오름차순, 동일 carrid 내에서는 connid 오름차순 조회
```
</br>
</br>

### 5) SELECT DISTINCT
- 중복을 제거하고 유일한 값만 조회
- `DISTINCT`는 DB 조회 시 중복 레코드 제거, `DELETE ADJACENT DUPLICATES`는 정렬된 내부 테이블에서 인접 중복만 제거
```abap
SELECT DISTINCT <필드1> <필드2> …
  FROM <테이블>
  INTO TABLE @<내부테이블>
  WHERE <조건>.
```
```abap
DATA: gt_flight TYPE TABLE OF sflight.

SELECT DISTINCT carrid connid
  FROM sflight
  INTO TABLE @gt_flight
  WHERE seatsocc > 200.
" 결과: seatsocc > 200인 항공편 중 carrid+connid 조합이 중복 없이 조회
```
</br>
</br>

---

</br>

## < ABAP 추가 문법 >
### 1) FOR ALL ENTRIES IN
- 내부 테이블의 값들을 기준으로 DB에서 데이터를 조회
- 다중 조건 가능
- 내부 테이블이 비어있으면 전체 조회되므로 체크 필요
- `FOR ALL ENTRIES IN <내부 테이블>` → 어떤 내부 테이블의 값들을 조건으로 쓸지 지정
- `WHERE <DB필드> = <내부테이블-필드>` → 실제 비교 조건 작성
```abap
SELECT <필드>
  FROM <DB 테이블>
  INTO <내부 테이블 또는 변수>
  FOR ALL ENTRIES IN <내부 테이블>
  WHERE <조건 = 내부테이블-필드>.
```
```abap
IF gt_data IS NOT INITIAL.
  SELECT *
    FROM sflight
    INTO TABLE @gt_result
    FOR ALL ENTRIES IN @gt_data
    WHERE carrid = @gt_data-carrid.
ENDIF.
```
</br>
</br>

### 2) DELETE ADJACENT DUPLICATES
- 정렬된 내부 테이블에서 연속된 중복 레코드를 삭제
- 중복 기준 필드를 지정 가능
- `<내부테이블>` → 중복을 제거할 내부 테이블
- `COMPARING` → 특정 필드 기준으로 중복 제거 (생략하면 전체 구조 기준)
```abap
DELETE ADJACENT DUPLICATES FROM <내부테이블>
  [COMPARING <필드1> <필드2> ...].
```
```abap
DATA: it_numbers TYPE TABLE OF i,
      wa_number  TYPE i.

APPEND 10 TO it_numbers.
APPEND 10 TO it_numbers.
APPEND 20 TO it_numbers.
APPEND 20 TO it_numbers.
APPEND 30 TO it_numbers.

DELETE ADJACENT DUPLICATES FROM it_numbers.
```
</br>
</br>

### 3) WITH HEADER LINE
- 내부 테이블 안에 자동으로 한 줄(row)을 나타내는 구조를 생성
- 테이블 이름과 동일한 구조가 만들어져 별도 워크에어리어 없이 한 줄 데이터를 바로 사용 가능
  - `itab[]` → 테이블 전체
  - `itab` → 테이블의 헤더라인(한 줄)
```abap
DATA: <itab> TYPE TABLE OF <structure> WITH HEADER LINE.
```
- INTO 절 생략 가능
```abap
LOOP AT gt_hline.
  WRITE: gt_hline-carrid.  "헤더 라인 사용 덕분에 INTO 생략 가능
ENDLOOP.
```
- MODIFY 시 자동 참조
```abap
gt_hline-percentage = gt_hline-seatsocc * 100 / gt_hline-seatsmax.
MODIFY gt_hline.  "워크 에어리어(gt_hline)를 테이블에 적용
```
- 실습
```abap
" Header Line이 있는 Internal table 선언
" gt_hline은 Structure, gt_hline[] 은 Itab 이 된다.
DATA: gt_hline TYPE TABLE OF bc400_s_flight WITH HEADER LINE.

SELECT carrid connid fldate seatsmax seatsocc
  FROM sflight
  INTO TABLE gt_hline[]
  WHERE carrid = 'AA'.

IF ( sy-subrc = 0 ).
  LOOP AT gt_hline.       " INTO 절 생략 가능
    gt_hline-percentage = gt_hline-seatsocc * 100 / gt_hline-seatsmax.
    MODIFY gt_hline.
  ENDLOOP.
ENDIF.

SORT gt_hline[] BY connid ASCENDING
                   percentage DESCENDING.

CLEAR gt_hline.
LOOP AT gt_hline WHERE percentage > 80.
  WRITE:/ gt_hline-carrid,
          gt_hline-connid,
          gt_hline-fldate,
          gt_hline-seatsmax,
          gt_hline-seatsocc,
          gt_hline-percentage.
ENDLOOP.
```
</br>
</br>

### 4) cl_demo_output=>display
- 내부 테이블 또는 구조를 간단히 화면에 출력
```abap
cl_demo_output=>display( <itab> ).
```
```abap
IF sy-subrc = 0.
  cl_demo_output=>display( gt_result ).
ENDIF.
```

</br>
</br>

---

</br>

## < ABAP 개념 정리 >
</br>

### Selection Screen 주요 특징
- 실행 버튼 누르면 DB 테이블에서 조건에 맞는 데이터 추출
- 다국어 처리 지원
- 입력 값 타입 자동 체크 (예: 숫자, 날짜, 문자열)
- 입력 값 저장 및 재사용 가능
- 복잡한 조건(범위, 다중 선택 등) 처리 가능
- 입력 값 범위 및 형식 제한 기능 (F4 도움말 등)
</br>

### 파라미터 선언 예시 및 특징
- `TYPE` 뒤에 올 수 있는 타입은 표준 타입 혹은 데이터 딕셔너리 필드 타입
- 파라미터는 단일 입력값 받음
- 입력 필드의 데이터 타입이 자동 적용됨 (숫자, 문자열 등)
```abap
PARAMETERS: pa_car TYPE s_carr_id.
PARAMETERS: pa_car TYPE spfli-carrid.
```
</br>

### Select-Options 관련 주요 사항
- 선언 시 `TYPE`이 아니라 `FOR` 키워드 사용
```abap
SELECT-OPTIONS: so_car FOR spfli-carrid.
```
- FOR 뒤에는 이미 선언된 데이터 오브젝트나 DDIC 필드명을 사용
- Select-options는 내부적으로 테이블(ITAB) 구조를 가짐
- Select-options 로 입력된 범위값을 사용할 때는 IN 키워드 사용
- 만약 so_car가 빈 값이면 조건 없이 전체 조회됨
```abap
SELECT * FROM spfli WHERE carrid IN so_car.
```
</br>

### SELECT-OPTIONS 필드 정의

| 필드명 | 의미 |
|--------|------|
| SIGN   | 포함(I, Include) 또는 제외(E, Exclude) |
| OPTION | 연산자 (EQ = 같음, BT = 범위, GE = 이상 등) |
| LOW    | 범위 시작값 (From) |
| HIGH   | 범위 끝값 (To, BT 연산자에서 사용) |

- 예시

| 조건 설명                          | SIGN | OPTION | LOW  | HIGH |
|-----------------------------------|------|--------|------|------|
| LH 값만 포함                        | I    | EQ     | LH   |      |
| AA부터 DL까지 포함                  | I    | BT     | AA   | DL   |
| BA 값 제외                          | E    | EQ     | BA   |      |

</br>
</br>

---

</br>

## < 실습 코드 >
</br>

### 실습 1
- SELECT-OPTIONS와 SELECT 이용해서 LOOP로 출력하기
```abap
DATA: gs_data TYPE SBOOK,
      gt_data LIKE TABLE OF gs_data.

PARAMETERS: pa_car TYPE S_CARR_ID DEFAULT 'AZ',
            pa_con TYPE S_CONN_ID DEFAULT '0555'.

SELECT-OPTIONS: so_dat FOR gs_data-FLDATE.


SELECT * FROM SBOOK
  INTO CORRESPONDING FIELDS OF TABLE gt_data
  WHERE CARRID = pa_car
    AND CONNID = pa_con
    AND FLDATE IN so_dat.

LOOP AT gt_data INTO gs_data.
  WRITE:/ gs_data-CARRID, gs_data-CONNID, gs_data-FLDATE,
          gs_data-BOOKID, gs_data-CUSTOMID, gs_data-CUSTTYPE.
ENDLOOP.
```
</br>
</br>

### 실습 2
- FOR ALL ENTRIES IN 사용해서 출력
```abap
DATA: gt_data TYPE TABLE OF sflight,
      gt_result TYPE TABLE OF sflight.

SELECT carrid
  FROM sflight
  INTO CORRESPONDING FIELDS OF TABLE gt_data
  WHERE carrid IN ('AA', 'AZ', 'LH').
  " carrid가 'AA', 'AZ', 'LH'에 포함되는 레코드만 조회

IF gt_data IS INITIAL.
  SORT gt_data BY carrid.   " carrid 오름차순 정렬
  " gt_data에 carrid가 중복된 레코드는 삭제
  " => 중복 레코드가 존재하면, 자동 제거되지 않고 DB 요청이 들어감
  " => 그만큼 속도가 늦어지는 것이기 때문에 SELECT 전애
  " => 정렬 및 중복제거를 해주는 것이 좋다.
  DELETE ADJACENT DUPLICATES FROM gt_data COMPARING carrid.

  SELECT * FROM sflight
    INTO CORRESPONDING FIELDS OF TABLE gt_result
    FOR ALL ENTRIES IN gt_data
    WHERE carrid = gt_data-carrid.
      " AND connid = gt_data-connid. 여러 필드 가능

    " 주의! FOR ALL ~ 로 사용하는 gt_data가 비어있으면
    " 테이블 전체를 조회하므로. 대량 데이터의 Table일 경우
    " 시스템이 다운될 수 있음. 따라서 gt_data가 있는 경우를
    " 체크해주는 것이 안전하다.

  IF sy-subrc = 0.
    cl_demo_output=>display( gt_result ).
  ENDIF.
ENDIF.
```
</br>
</br>

### 실습 3
- FOR ALL ENTRIES IN 사용해서 조회된 항공사 목록을 이용해 항공편 목록 출력
```abap
DATA: gs_data   TYPE scarr,
      gt_data   LIKE TABLE OF gs_data,
      gt_result TYPE TABLE OF sflight.

SELECT-OPTIONS: so_car FOR gs_data-carrid.

SELECT * FROM scarr
  INTO CORRESPONDING FIELDS OF TABLE gt_data
  WHERE carrid IN so_car.

SELECT * FROM sflight
  INTO CORRESPONDING FIELDS OF TABLE gt_result
  FOR ALL ENTRIES IN gt_data
  WHERE carrid = gt_data-carrid.

cl_demo_output=>display( gt_result ).
```
</br>
</br>

### 실습 4
- order by 실습
```abap
DATA: gs_sflight TYPE sflight,
      gt_sflight TYPE TABLE OF sflight.

* Key 값으로 정렬
SELECT *
  INTO CORRESPONDING FIELDS OF TABLE gt_sflight
  FROM SFLIGHT
  ORDER BY SEATSMAX DESCENDING.
* ORDER BY PRIMARY KEY.
* ORDER BY carrid DESCENDING, connid ASCENDING

IF sy-subrc = 0.
  cl_demo_output=>display( gt_sflight ).
*  LOOP AT gt_sflight INTO gs_sflight.
*    WRITE:/ gs_sflight-carrid,
*            gs_sflight-connid,
*            gs_sflight-fldate.
*  ENDLOOP.
ENDIF.
```
</br>
</br>

### 실습 5
- SELECT DISTINCT 실습습
```abap
DATA: gs_sflight TYPE sflight,
      gt_sflight TYPE TABLE OF sflight.

* Key 값으로 정렬
SELECT DISTINCT CARRID CONNID
  INTO CORRESPONDING FIELDS OF TABLE gt_sflight
  FROM SFLIGHT
  ORDER BY CARRID CONNID.

IF sy-subrc = 0.
  LOOP AT gt_sflight INTO gs_sflight.
    WRITE:/ gs_sflight-carrid,
            gs_sflight-connid.
  ENDLOOP.
ENDIF.
```
</br>
</br>

### 실습 6
- SELECT 집계함수 실습
```abap
* MIN, MAX, SUM, AVG, COUNT에 대한 내용
* 만약 COUNT( DISTINCT 필드명 ) 입력 시
* 중복이 제거된 필드의 갯수를 얻을 수 있음
DATA: BEGIN OF gs_data,
        MIN TYPE sflight-seatsocc,
        MAX TYPE sflight-seatsocc,
        SUM TYPE sflight-seatsocc,
        AVG TYPE F,
        CNT TYPE I,
      END OF gs_data.
DATA: gv_cnt TYPE I.

SELECT MIN( SEATSOCC ) MAX( SEATSOCC )
       SUM( SEATSOCC ) AVG( SEATSOCC )
       COUNT( * )
  FROM SFLIGHT
  INTO gs_data
  WHERE carrid = 'LH'
    AND connid = '0400'.

SELECT COUNT( DISTINCT connid )
  FROM SFLIGHT
  INTO gv_cnt
  WHERE carrid = 'AA'.

WRITE: 'gv_cnt', gv_cnt.

IF sy-subrc = 0.
  WRITE:/ 'MIN', 10 gs_data-MIN,
        / 'MAX', 10 gs_data-MAX,
        / 'SUM', 10 gs_data-SUM,
        / 'AVG', 10 gs_data-AVG,
        / 'CNT', 10 gs_data-CNT.
ENDIF.
```
</br>
</br>

### 실습 7
- GROUP BY + HAVING 절 실습
```abap
DATA: BEGIN OF gs_data,
        connid TYPE sflight-connid,
        minvar TYPE sflight-seatsocc,
        maxvar TYPE sflight-seatsocc,
        sumvar TYPE sflight-seatsocc,
        avgvar TYPE P LENGTH 3 DECIMALS 2,
      END OF gs_data.
DATA: gt_data LIKE TABLE OF gs_data.

SELECT CONNID MIN( seatsocc ) MAX( seatsocc )
       SUM( seatsocc ) AVG( seatsocc )
  FROM SFLIGHT
  INTO TABLE gt_data
  WHERE carrid = 'LH'   " carrid가 LH인 것만 조회해라
  GROUP BY connid       " 그 중, connid로 그룹화해라
  HAVING SUM( seatsocc ) >= 300.
  " 그룹화된 결과 데이터 중에, SUM( seatsocc )필드가 300 이상인 데이터만 조회해라

IF sy-subrc = 0.
  cl_demo_output=>display( gt_data ).
ENDIF.
```

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (11.26).md
</br>

## < Table Join 방법 >
### 1) Database View 이용
- DB 레벨에서 여러 테이블을 미리 조인하여 가상 테이블(View) 생성
- 재사용 가능, SQL 최적화, 코드 간결
- 조건 변경에는 유연하지 않음
```abap
SELECT <필드1> <필드2> ...
  FROM <DatabaseView>
  WHERE <조건>.
```
```
SELECT carrid connid carrname      
  FROM zabc        " zabc는 이미 여러 테이블을 조인해 만든 Database View
  WHERE carrid = 'LH'.
```
</br>

### 2) 프로그램에서 직접 조인
- ABAP 프로그램 안에서 SELECT문에서 직접 JOIN 수행
- 조건을 동적으로 처리 가능, 유연성 높음
- 코드 길어지고, DB 최적화는 View보다 어려움
</br>

- `INNER JOIN` : 두 테이블 모두에 있는 데이터만 반환 (교집합)
- `LEFT OUTER JOIN` : 왼쪽 테이블 기준, 오른쪽 테이블 없으면 NULL 포함
- `RIGHT OUTER JOIN` : 오른쪽 테이블 기준, 왼쪽 테이블 없으면 NULL 포함
</br>

- `-` : 필드 접근용 (JOIN 에서만 안씀)
- `~` : JOIN 사용 시에만 사용
```abap
SELECT <테이블1~필드>, <테이블2~필드>
  INTO TABLE <내테이블>
  FROM <테이블1>
  INNER JOIN <테이블2>
  ON <테이블1~키> = <테이블2~키>
  WHERE <조건>.
```
```abap
SELECT SCARR~CARRID
       SPFLI~CONNID
       SCARR~CARRNAME
       SPFLI~CITYFROM
  INTO TABLE lt_flight
  FROM SCARR as A INNER JOIN SPFLI as B
    ON SCARR~CARRID = SPFLI~CARRID      " spfli와 scarr 모두 존재하는 carrid만 결과에 포함
  WHERE SCARR~CARRID = 'AA'.

  IF sy-subrc = 0.
    cl_demo_output=>display( lt_flight ).
  ENDIF.
```
```abap
TYPES: BEGIN OF ts_data,
        CARRID TYPE SCARR-CARRID,
        CONNID TYPE SFLIGHT-CONNID,
        FLDATE TYPE SFLIGHT-FLDATE,
       END OF ts_data.

DATA: gs_data TYPE ts_data,
      gt_data TYPE TABLE OF ts_data.

SELECT C~CARRID F~CONNID F~FLDATE
  INTO TABLE gt_data
  FROM SCARR AS C INNER JOIN SFLIGHT AS F
    ON C~CARRID = F~CARRID
  WHERE C~CARRID = 'AA'.

  IF sy-subrc = 0.
    cl_demo_output=>display( gt_data ).
  ENDIF.
```
</br>
</br>

---

</br>

## < ABAP EVENT >
- 프로그램 실행 시점에 자동 호출되는 코드 블록
- 주요 이벤트
  - **INITIALIZATION**
    - 프로그램 시작 시 실행
    - 화면이나 변수의 초기값 설정
  - **AT SELECTION-SCREEN**
    - 사용자가 셀렉션 스크린에 입력한 값 처리
    - 입력값 검증이나 추가 처리 수행
  - **START-OF-SELECTION**
    - SAP에서 사전 정의된 이벤트
    - 프로그램 실행 시 자동 호출
    - 메인 처리 로직 수행 (데이터 조회, 주요 작업)
- 주의 및 특징
  - 동일 이벤트 중복 선언 불가
  - 모든 이벤트 작성 필요 없음 (필요한 것만 사용)
  - 이벤트 순서와 상관없이 호출 시점에 따라 실행됨
```abap
REPORT z_event_example.

" 초기값 설정
INITIALIZATION.
  gv_title = '항공편 조회 프로그램'.

" 셀렉션 스크린 입력값 검증
PARAMETERS: p_carrid TYPE spfli-carrid.

AT SELECTION-SCREEN.
  IF p_carrid IS INITIAL.
    MESSAGE '항공사를 입력하세요.' TYPE 'E'.
  ENDIF.

" 메인 처리 로직
START-OF-SELECTION.
  SELECT * FROM spfli
    WHERE carrid = p_carrid
    INTO TABLE @DATA(lt_spfli).

  LOOP AT lt_spfli INTO DATA(ls_spfli).
    WRITE: / ls_spfli-carrid, ls_spfli-connid, ls_spfli-cityfrom, ls_spfli-cityto.
  ENDLOOP.
```
</br>
</br>

---

</br>

## < Class 클래스 (SE24) >
- 객체를 만들기 위한 틀. 속성과 기능을 정의.
- 객체(인스턴스): 클래스에서 만들어진 실제 존재하는 개별 데이터 단위
- 클래스 구성
  - 속성(Attributes): 객체 상태 정보
  - 메서드(Methods): 객체가 수행하는 기능
- 접근 제한자
  - `public` : 외부에서 접근 가능
  - `private` : 외부에서 접근 불가
- 객체 특징
  - 각 객체는 독립적인 메모리 보유 → 속성/메서드 상태가 객체마다 다름 (`instance component`)
  - 모든 객체가 공통으로 접근하는 속성/메서드 → `static component`
- **Method 코드 형식**
```abap
METHOD <method_name>.
  " 로컬 변수 선언
  DATA <var_name> TYPE <type>.

  " 파라미터 체크 / 조건 처리
  IF <조건>.
    <출력 변수> = <값>.
    RAISE EXCEPTION TYPE <exception_type>.
  ELSE.
    " 계산 / 반복 / TRY-CATCH 가능
    TRY.
        <연산 로직>
      CATCH <exception_type>.
        <출력 변수> = <값>.
        RAISE EXCEPTION TYPE <exception_type>.
    ENDTRY.
  ENDIF.

ENDMETHOD.
```
- Program에서 Method 호출 형식
```abap
DATA gv_result TYPE <type>.

TRY.
    CALL METHOD <class_name>=><method_name>
      EXPORTING
        iv_param1 = <값>
        iv_param2 = <값>
      IMPORTING
        ev_result = gv_result
      .
  CATCH <exception_type>.
    " 예외 처리
ENDTRY.

WRITE: / gv_result.
```
</br>
</br>

---

</br>

## < ABAP 추가 문법 >
</br>

**1) APPENDING**
- SELECT 결과를 기존 내부 테이블 뒤에 이어서 추가
- 기존 데이터는 그대로 유지
- 필드명이 같은 컬럼끼리 자동 매칭
- 구문 비교:
  - `INTO TABLE itab` → 내부테이블 기존 내용 삭제 후 새 데이터
  - `APPENDING CORRESPONDING FIELDS OF TABLE itab` → 기존 데이터 유지 후 추가
```abap
SELECT <필드1> <필드2> ...
  FROM <테이블>
  APPENDING CORRESPONDING FIELDS OF TABLE <itab>  " `INTO` 대신 `APPENDING` 넣기
  WHERE <조건>.
```
</br>
</br>

**2) CLIENT SPECIFIED**
- SAP ABAP에서 일반적으로 SELECT는 현재 클라이언트(sy-mandt) 기준으로만 데이터 조회.
- CLIENT SPECIFIED를 사용하면 MANDT 값을 직접 지정하여 다른 클라이언트 데이터도 조회 가능.
- 주의: 잘못 사용하면 보안/데이터 일관성 문제 발생 가능.
```abap
SELECT fields
  INTO <TABLE|STRUCTURE>
  FROM dbtable
  CLIENT SPECIFIED
  WHERE mandt = '값'.
```
```abap
DATA: lt_scarr TYPE TABLE OF SCARR.

SELECT *
  INTO CORRESPONDING FIELDS OF TABLE lt_scarr
  FROM SCARR
  CLIENT SPECIFIED
  WHERE mandt BETWEEN '000' AND '800'.

IF sy-subrc = 0.
  cl_demo_output=>display( lt_scarr ).
ENDIF.
```
</br>
</br>

**3) AUTHORITY-CHECK (SU21)**
- 사용자가 특정 권한을 가지고 있는지 확인하는 ABAP 구문
- Role 부여: 특정 사용자에게 역할(Role)을 부여하면 해당 권한 획득
- 권한 객체(Object) + 필드(ID) + 액티비티(ACTVT) 기반으로 체크
- ACTVT(Activity): 수행 가능한 작업 지정
  - `01` = Create
  - `02` = Change
  - `03` = Display
- AUTHORITY-CHECK: ABAP에서 사용자 권한을 확인하는 구문
  - 성공 여부는 sy-subrc로 판단 (0 = 권한 있음, <>0 = 권한 없음)
```abap
AUTHORITY-CHECK OBJECT '<권한객체>'
  ID '<필드1>' FIELD <값1>
  ID '<필드2>' FIELD <값2>
  ...
IF sy-subrc = 0.
  " 권한 있음 처리
ELSE.
  " 권한 없음 처리
ENDIF.
```
```abap
AUTHORITY-CHECK OBJECT 'S_CARRID'
  ID 'CARRID' FIELD iv_carrid
  ID 'ACTVT' FIELD '03'.  " Display 권한 체크

IF sy-subrc = 0.
  " 권한 있음 → 데이터 조회
  SELECT * FROM spfli WHERE carrid = iv_carrid.
ELSE.
  " 권한 없음 → 메시지 처리
  MESSAGE '권한이 없습니다.' TYPE 'E'.
ENDIF.
```
</br>
</br>

**4) SELECT-OPTIONS + APPEND/CLEAR**
- SELECT-OPTIONS: 화면에서 범위 조건 입력용, 내부적으로 `SIGN / OPTION / LOW / HIGH` 구조
- `SELECT-OPTIONS`는 데이터베이스 테이블 필드를 직접 참조할 수 없고, 해당 필드가 포함된 이미 선언된 변수(Work Area 또는 Structure)의 필드를 통해 참조해야 함
- Select-options는 Header Line 있는 itab 이므로 APPEND 시 TO 절 생략 가능
- `APPEND` : 조건을 내부 테이블에 추가
- `CLEAR` : 헤더라인 초기화 → 다음 조건 입력 준비


| ABAP OPTION 값 | 의미 (Meaning) | LOW/HIGH 사용 | SQL 연산자 개념 |
| :---: | :--- | :---: | :---: |
| **`EQ`** | Equal (같음) | `LOW` 값만 사용 | `fieldName = LOW` |
| **`BT`** | Between (사이) | `LOW`와 `HIGH` 값 모두 사용 | `fieldName BETWEEN LOW AND HIGH` |
| **`GE`** | Greater or Equal (크거나 같음) | `LOW` 값만 사용 | `fieldName >= LOW` |
| **`LE`** | Less or Equal (작거나 같음) | `LOW` 값만 사용 | `fieldName <= LOW` |
| **`GT`** | Greater Than (초과) | `LOW` 값만 사용 | `fieldName > LOW` |
| **`LT`** | Less Than (미만) | `LOW` 값만 사용 | `fieldName < LOW` |
| **`CP`** | Contains Pattern (패턴 포함) | `LOW` 값만 사용 (`*`, `?` 등 사용) | `fieldName LIKE LOW` |
| **`NE`** | Not Equal (같지 않음) | `LOW` 값만 사용 | `fieldName != LOW` (또는 `NOT =`) |
| **`NP`** | Not Contains Pattern (패턴 불일치) | `LOW` 값만 사용 | `NOT (fieldName LIKE LOW)` |


```abap
" 1. SELECT-OPTIONS 선언
SELECT-OPTIONS: <so_name> FOR <field>.

" 2. 헤더라인 변수에 값 설정 후 APPEND
<so_name>-SIGN   = '<Include / Exclude>';   " 예: 'I' 또는 'E'
<so_name>-OPTION = '<연산자>';            " 예: 'EQ', 'BT', 'GE' 등
<so_name>-LOW    = '<시작값>';            " 범위 시작값
<so_name>-HIGH   = '<끝값>';              " 범위 끝값 (BT일 경우)
APPEND <so_name>.                           " 내부 테이블에 적용
CLEAR <so_name>.                            " 헤더라인 초기화 후 다음 조건 설정
```
```abap
DATA: gt_flight TYPE TABLE OF sflight,
      gs_flight TYPE sflight.

" SELECT-OPTIONS 선언 (구조 필드 기준)
SELECT-OPTIONS: so_conn FOR gs_flight-connid.

INITIALIZATION.
  " 포함 조건: 0400
  so_conn-SIGN   = 'I'.
  so_conn-OPTION = 'EQ'.
  so_conn-LOW    = '0400'.
  APPEND so_conn.
  CLEAR so_conn.

  " 제외 조건: 0401
  so_conn-SIGN   = 'E'.
  so_conn-OPTION = 'EQ'.
  so_conn-LOW    = '0401'.
  APPEND so_conn.
  CLEAR so_conn.

START-OF-SELECTION.
  " 조건 적용 SELECT
  SELECT *
    FROM sflight
    INTO TABLE gt_flight
    WHERE connid IN so_conn.

  cl_demo_output=>display( gt_flight ).      " 결과 : CONNID = 0400 만
```
</br>
</br>

---

</br>

## < ABAP 추가적인 개념 >
</br>

### Secondary Index
- 기본 키(primary key) 외에 추가로 만드는 검색용 인덱스
- 특정 필드 조합으로 데이터를 더 빠르게 찾기 위해 사용
- WHERE 조건에 인덱스 필드가 포함되면 → DB 검색 속도 향상
</br>

### Table Buffer (테이블 버퍼링)
- 자주 사용하는 테이블 데이터를 DB에서 읽지 않고 메모리(Buffer) 에 저장해두고 읽는 방식
- 버퍼에 있으면 DB 접근 없이 바로 조회 → 조회 속도 매우 빠름
- 읽기 중심 테이블에 적합, 변경이 잦은 테이블에는 비권장
- 테이블마다 `버퍼링 허용 여부`를 SAP Dictionary(SE11)에서 설정
</br>

### DB & 내부 테이블 연산 정리
- **INSERT** : 값 없을 때 새로 추가
- **UPDATE** : 값 있을 때 갱신
- **DELETE** : 값 삭제
- **MODIFY (DB)** : 값 있으면 UPDATE, 없으면 INSERT
- **MODIFY (ITAB)** : 조건에 맞는 행만 갱신, 값 없으면 추가되지 않음

</br>
</br>

---

</br>

## < 실습 코드 >
</br>

### 실습 1
- Event 함수 실습
```abap
DATA: gt_flight TYPE TABLE OF SFLIGHT,
      gs_flight LIKE LINE OF gt_flight.

SELECT-OPTIONS: so_con FOR gs_flight-connid.
PARAMETERS: pa_car TYPE sflight-carrid,
            pa_chk TYPE CHAR01 AS CHECKBOX DEFAULT 'X'.

INITIALIZATION.
  pa_car = 'LH'.
  so_con-SIGN = 'I'.
  so_con-OPTION = 'EQ'.
  so_con-LOW = '0400'.
  so_con-HIGH = '0402'.
  APPEND so_con. " 원래 APPEND SO_CON TO SO_SON 처럼
                 " TO~부분이 있어야 하지만, Select-options는
                 " Header Line 있는 itab 이므로 생략
  CLEAR so_con.  " Header(Structure)만 클리어

  so_con-SIGN = 'E'.
  so_con-OPTION = 'EQ'.
  so_con-LOW = '0400'.      " 0400 제외하고 조회
  APPEND so_con.
  CLEAR so_con.

AT SELECTION-SCREEN.
  IF pa_chk = 'X' AND pa_car IS INITIAL.
    MESSAGE 'carrid를 입력하세요~~~~' TYPE 'E'.
  ENDIF.

START-OF-SELECTION.
  SELECT *
    FROM SFLIGHT
    INTO CORRESPONDING FIELDS OF TABLE gt_flight
    WHERE CARRID = PA_CAR
      AND CONNID IN SO_CON.

  IF sy-subrc = 0.
    cl_demo_output=>display( gt_flight ).
  ENDIF.
```
</br>
</br>

### 실습 2
- Event 함수, Function Module 실습
```abap
PARAMETERS: pa_car TYPE S_CARR_ID.
DATA: gt_data TYPE BC400_T_CONNECTIONS.
" TABLE OF로 가져오고 싶으면 KEY 설정 맞추기
" DATA: gt_data TYPE STANDARD TABLE OF BC400_S_CONNECTION WITH NON-UNIQUE KEY CARRID CONNID. 

AT SELECTION-SCREEN.
  IF pa_car IS INITIAL.
    MESSAGE 'pa_car가 입력되지 않았습니다.' TYPE 'E'.
  ENDIF.

START-OF-SELECTION.
  CALL FUNCTION 'ZGET_CONNECT03'
    EXPORTING
      iv_carrid = pa_car
    IMPORTING
      ET_CONNECT = gt_data
    EXCEPTIONS
      NO_DATA   = 1
      OTHERS    = 2.

  IF sy-subrc <> 0.
    MESSAGE 'No Data error!' TYPE 'E'.
  ELSE.
    cl_demo_output=>display( gt_data ).
  ENDIF.
```
</br>
</br>

### 실습 3
- class/method 코드
```abap
METHOD get_power.
  DATA lv_power TYPE bc400_compute_power.

*Simple error handling
  IF iv_power >= 5 OR iv_power <= 0.
    ev_result = 0.
    RAISE EXCEPTION TYPE cx_bc400_power_too_high.
*Calculate result
  ELSEIF iv_power = 1.
    ev_result = iv_base.
  ELSE.
    TRY.
        ev_result = iv_base * iv_base.
        lv_power = iv_power - 1.

        WHILE sy-index < lv_power .
          ev_result =  ev_result * iv_base.
        ENDWHILE.
      CATCH cx_sy_arithmetic_overflow.
        ev_result = 0.
        RAISE EXCEPTION TYPE cx_bc400_result_too_high.
    ENDTRY.
  ENDIF.
ENDMETHOD.
```
- program 코드
```abap
TYPES tv_result TYPE P LENGTH 16 DECIMALS 2.

PARAMETERS: pa_int1 TYPE I,
            pa_int2 TYPE I.

DATA: gv_result TYPE tv_result.

TRY.
CALL METHOD cl_bc400_compute=>get_power
  EXPORTING
    iv_base  = pa_int1
    iv_power = pa_int2
  IMPORTING
   ev_result = gv_result
  .
  CATCH cx_bc400_power_too_high.
    MESSAGE 'Power too high!!' TYPE 'E'.
  CATCH cx_bc400_result_too_high.
    MESSAGE 'Result too high!!' TYPE 'E.'.
ENDTRY.

WRITE:/ gv_result.
```
</br>
</br>

### 실습 4
- class(method 가져오기) 실습
```abap
PARAMETERS: CARRID TYPE S_CARR_ID,
            CONNID TYPE S_CONN_ID.
DATA: gt_data TYPE BC400_T_FLIGHTS.

INITIALIZATION.
  CARRID = 'AA'.
  CONNID = '0017'.

AT SELECTION-SCREEN.
  IF ( CARRID IS INITIAL OR CONNID IS INITIAL ).
    MESSAGE 'CARRID 나 CONNID 가 빈 값입니다.' TYPE 'E'.
  ENDIF.

START-OF-SELECTION.
  TRY.
  CALL METHOD cl_bc400_flightmodel=>get_flights
    EXPORTING
      iv_carrid = CARRID
      iv_connid = CONNID
    IMPORTING
     et_flights = gt_data.

    CATCH cx_bc400_no_data.
      MESSAGE 'ERROR ! : No Data for Selection' TYPE 'E'.
    CATCH cx_bc400_no_auth.
      MESSAGE 'EEROR ! : No Authorization for Airline' TYPE 'E'.
  ENDTRY.

  cl_demo_output=>display( gt_data ).
```

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (11.27).md
</br>

## < Data Dictionary: Domain & Data Element >
- Domain과 Data Element는 `1 : N` 관계
- 1개의 Domain → 여러 Data Element에서 사용 가능
</br>

<img width="327" height="152" alt="image" src="https://github.com/user-attachments/assets/3bbba7ad-47a1-4fdf-8719-c13fc4627dbd" />

</br>
</br>
</br>

### Domain (도메인)
- 데이터의 타입과 속성을 정의하는 단위
  - 데이터 형식, 길이, 소수점, 문자/숫자 구분 등 속성을 정의
- 숫자 음수 사용 여부 지정 가능 → `Sign` 속성 체크 시 음수 입력 허용
- 소문자 사용 여부 지정 가능 → `Case` 속성 체크 시 소문자 입력 가능
  
<img width="492" height="328" alt="image" src="https://github.com/user-attachments/assets/dfebe42f-4966-4074-84fd-366c8a833528" />

</br>
</br>
</br>

### Data Element (데이터 요소)
- 실제 테이블 필드나 구조 필드에 사용되는 논리적 이름
- Domain 기반 생성 → Domain에서 정의된 형식을 그대로 사용
- Domain 선택은 선택 사항
  - Domain 사용 시: 타입, 길이, 음수 허용 여부, 소문자 허용 여부 등 속성을 한번에 관리 가능
    - Domain 속성을 수정하면 해당 Domain을 참조하는 모든 Data Element가 자동으로 변경
  - Domain 미사용 시: Built-in Type으로 직접 타입 지정 가능
- 도메인 1개를 여러 Data Element에서 재사용 가능

<img width="495" height="269" alt="image" src="https://github.com/user-attachments/assets/abb423ba-3983-4a1d-ad33-ab0b7cb7a437" />
</br>
</br>
</br>
</br>

- **`text Element -> Selelction Texts -> DDIC Reference` 하면 short description 뜸**
<img width="491" height="166" alt="image" src="https://github.com/user-attachments/assets/543260b8-6384-469e-a105-b218af963d6e" />

</br>
</br>

---

</br>

## < Structure Types (스트럭처 타입) >
### 1) Simple Structure (단순 구조)
- 일반적으로 사용하는 기본 스트럭처
- 필드 안에 또 다른 구조나 테이블이 없는 구조
```abap
TYPES: BEGIN OF ty_simple,
         name TYPE string,
         age  TYPE i,
       END OF ty_simple.
```
</br>
</br>


### 2) Nested Structure (중첩 구조)
- 어떤 필드 안에 또 다른 스트럭처가 포함된 구조
- 구조 안에 구조를 넣어 계층적으로 데이터 표현 가능
```abap
TYPES: BEGIN OF ty_address,
         city    TYPE string,
         zipcode TYPE string,
       END OF ty_address.

TYPES: BEGIN OF ty_person,
         name    TYPE string,
         age     TYPE i,
         address TYPE ty_address, "스트럭처 안 스트럭처
       END OF ty_person.
```
</br>
</br>


### 3) Deep Structure (딥 구조)
- 어떤 필드 안에 인터널 테이블 형태의 테이블 타입이 들어간 구조
- 구조 안에 테이블을 넣어 1:N 관계 데이터를 표현 가능
```abap
TYPES: BEGIN OF ty_order_item,
         item_id TYPE i,
         qty     TYPE i,
       END OF ty_order_item.

TYPES: ty_order_items TYPE STANDARD TABLE OF ty_order_item WITH DEFAULT KEY.

TYPES: BEGIN OF ty_order,
         order_id TYPE i,
         items    TYPE ty_order_items, "스트럭처 안 테이블
       END OF ty_order.
```
</br>
</br>
</br>
</br>

## < Structure와 INCLUDE 접근 방식 >

<img width="508" height="198" alt="image" src="https://github.com/user-attachments/assets/4686de91-e543-43d7-9c2f-78271a78a0a7" />

### 1) `.INCLUDE` 사용
- 스트럭처 안에 INCLUDE로 다른 구조체를 포함했을 때
- INCLUDE 안의 필드는 최상위 구조체 필드처럼 바로 접근 가능
```abap
TYPES: BEGIN OF ty_addr,
         street TYPE string,
         city   TYPE string,
       END OF ty_addr.

TYPES: BEGIN OF ty_person,
         name TYPE string,
         INCLUDE TYPE ty_addr, "포함
       END OF ty_person.

DATA person TYPE ty_person.

"접근
person-street = 'Main Street'.
person-city   = 'Seoul'.
```
</br>
</br>

### 2) 구조체 필드 이름으로 직접 포함(예: addr)
- 구조체 안에 필드명으로 다른 구조체를 선언했을 때
- 접근할 때는 상위 구조체 → 필드 → 하위 필드 형태로 접근
```abap
TYPES: BEGIN OF ty_person,
         name TYPE string,
         addr TYPE ty_addr,  "필드명으로 포함
       END OF ty_person.

DATA person TYPE ty_person.

"접근
person-addr-street = 'Main Street'.
person-addr-city   = 'Seoul'.
```
</br>
</br>
</br>
</br>

## < Line Type으로 설정 가능한 타입 (ABAP Table Type) >

| Line Type 종류                | 설명 |
|-------------------------------|------|
| **Data Element**              | 단일 필드(스칼라 타입)를 행 구조로 사용 |
| **Structure (Structure Type)**| 여러 필드로 이루어진 스트럭처를 행 타입으로 사용 |
| **Transparent Table**         | 투명 테이블의 한 Row 전체 구조를 행 타입으로 사용 |
| **Database View**             | 데이터베이스 뷰의 Row 구조를 행 타입으로 사용 |
| **Projection View**           | Projection View에서 노출된 필드 구조를 행 타입으로 사용 |

</br>
</br>

---

</br>

## < Type Group(타입 그룹) >
- 여러 TYPES, CONSTANTS, MACRO(DEFINE) 등을 한 묶음으로 모아놓은 그룹
- 프로그램에서 사용 시 `TYPE-POOL <이름>` 으로 로드
- 이름은 최대 5자리
**1) 타입 그룹 정의 형식(DIC에서 작성)**
- 타입 그룹 안의 객체 이름 형식: `<타입그룹명>_<오브젝트명>`
```abap
TYPE-POOL <타입그룹이름>.       "타입 그룹 선언

TYPES: <타입이름> TYPE <자료형>,     "타입 정의
       ...  

CONSTANTS: <상수이름> TYPE <자료형> VALUE <값>,   "상수 정의
           ...  
```
</br>

**2) Program 에서 사용 형식** 
```abap
TYPE-POOL <타입그룹이름>.          "타입 그룹 불러오기

DATA <변수명> TYPE <타입그룹이름>_<타입이름>.   "타입 그룹의 타입 사용
```
</br>
</br>

---

</br>

## < 실습 코드 >
### 실습 1
- 특정 필드에 대해 중복제거 및 정렬하여 조회하기
```abap
DATA: gs_data TYPE SFLIGHT,
      gt_data LIKE TABLE OF gs_data.

SELECT DISTINCT CARRID, CONNID, CURRENCY FROM SFLIGHT
  INTO CORRESPONDING FIELDS OF TABLE @gt_data
  ORDER BY CARRID DESCENDING, CONNID ASCENDING.

LOOP AT gt_data INTO gs_data.
  WRITE: / gs_data-CARRID, gs_data-CONNID, gs_data-CURRENCY.
ENDLOOP.
```
</br>
</br>

### 실습 2
- domain과 data element 실습
  
**1) domain 정의**

<img width="328" height="272" alt="image" src="https://github.com/user-attachments/assets/4a1d0680-2f2d-4c0f-92ce-4a0b3cfe5b44" />
</br>
</br>

**2) data element 정의**

<img width="457" height="270" alt="image" src="https://github.com/user-attachments/assets/6f183cf8-29d2-4be0-a69f-a1beaaecbce3" />
</br>
</br>

**3) program 코드**
```abap
PARAMETERS: pa_fname TYPE ZFIRSTNAME03,
            pa_lname TYPE ZLASTNAME03,
            pa_activ TYPE ZASSETS03,
            pa_liabs TYPE ZLIABILITIES03.
DATA: gv_result TYPE P LENGTH 10 DECIMALS 2.


gv_result = pa_activ - pa_liabs.
WRITE:/ 'FIrst Name: ', pa_fname,
      / 'Last Name: ', pa_lname,
      / 'Assets: ', pa_activ,
      / 'Liabilities: ', pa_liabs,
      / 'Assets - Liabilities : ', gv_result.
```
</br>
</br>

### 실습 2
- Nested Structure 실습 ( 스트럭처 ZSSCARR_B03을 스트럭처 ZSSPFLI_B03 안에 포함시키기 )

**1) ZSSCARR_B03 정의**

<img width="556" height="168" alt="image" src="https://github.com/user-attachments/assets/b699b62b-2738-4312-9793-d542f97f5bbd" />

</br>
</br>

**2)  ZSSPFLI_B03 정의**

<img width="553" height="226" alt="image" src="https://github.com/user-attachments/assets/ed083fa4-379b-49aa-9de4-9e1b36601205" />

</br>
</br>
</br>

### 실습 3
- Structure와 INCLUDE 접근 방식 실습
```abap
DATA: gs_person TYPE ZPERSON_B03.

gs_person-phone = '010-8952-0763'.
gs_person-name-fname = 'Kim'.   " 필드 안에 스트럭처
gs_person-name-lname = 'yewon'.
gs_person-street = 'Gangnam'.   " .Include 스트럭처
gs_person-city = 'Seoul'.

WRITE:/ gs_person-phone,
      / gs_person-name-fname,
      / gs_person-name-lname,
      / gs_person-street,
      / gs_person-city.
```
</br>
</br>

### 실습 4
- Deep Structure 실습 ( Structure 안에 Table 구조 )
```abap
DATA: ls_person TYPE ZPERSON_B03,
      ls_phone TYPE LINE OF ZPERSON_B03-PHONE.    " table 타입에서 line of 로 생성했으므로 structure 변수
" DATA: ls_phone TYPE STR_PHONE과 같음
" DATA: ls_phone LIKE LINE OF ls_phone-PHONE과 같음

ls_person-fname = 'Hong'.
ls_person-lname = 'Gildong'.
ls_person-street = 'Gangnam'.
ls_person-city = 'Seoul'.

ls_phone-p_type = 'TEL'.
ls_phone-p_number = '010-1234-5678'.
APPEND ls_phone TO ls_person-phone. " itab에 1건추가

ls_phone-p_type = 'FAX'.
ls_phone-p_number = '02-214-3456'.
APPEND ls_phone TO ls_person-phone.

ls_phone-p_type = 'MOB'.
ls_phone-p_number = '010-9876-5432'.
APPEND ls_phone TO ls_person-phone.

WRITE: 'OKOK'.
```
</br>
</br>

### 실습 5
- Deep Structure 실습 ( 다하고 디버깅으로 확인 )
```abap
PARAMETERS: pa_carr TYPE S_CARR_ID.

DATA: gs_scar TYPE SCARR,
      gt_spfli TYPE ZSSCARR_B03-SPFLIINFO.

SELECT SINGLE * FROM SCARR
  INTO gs_scar
  WHERE carrid = pa_carr.
  
BREAK-POINT.
  
SELECT * FROM SPFLI
  INTO CORRESPONDING FIELDS OF TABLE gt_spfli
  WHERE carrid = pa_carr.
  
BREAK-POINT.
```
</br>
</br>

### 실습 6
**1) 타입 그룹 정의 형식(DIC에서 작성)**
```abap
TYPE-POOL ZTB03 .

TYPES ztb03_percentage(3) TYPE P DECIMALS 2.
CONSTANTS ztb03_pi TYPE F VALUE '3.14'.
```
</br>

**2) Program 에서 사용 형식** 
- icon 그림 표 보고 싶을 때는 SE38 -> SHOWICON 쳐서 실행
- 색상 표 보고싶을 때는 SE38 -> DEMO_LIST_FORMAT_COLOR_1 쳐서 실행
```abap
TYPE-POOLS: ZTB03, COL, ICON.

DATA: gv_percent TYPE ztb03_percentage.

WRITE:/ 'BACKGROUND' COLOR COL_BACKGROUND,
      / 'HEADING' COLOR COL_HEADING,
      / 'NORMAL' COLOR COL_NORMAL,
      / 'TOTAL' COLOR COL_TOTAL,
      / 'KEY' COLOR COL_KEY,
      / 'POSITIVE' COLOR COL_POSITIVE,
      / 'NEGATIVE' COLOR COL_NEGATIVE,
      / 'GROUP' COLOR COL_GROUP.

WRITE:/ '5B' AS ICON,
        '5C' AS ICON,
        '5D' AS ICON.
```

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (11.28).md
</br>

## < ABAP 개념 >
### < 데이터 조회 & 인덱스 >
**1) Binary Search**
- 기본키 기준 SELECT 시 자동 적용
- 데이터를 반씩 나누며 빠르게 찾는 알고리즘

**2) Secondary Index**
- 기본키 외 다른 필드 조회 시 사용
- 빠른 조회 가능
- DB 옵티마이저가 최적 인덱스 자동 선택
  
<img width="466" height="168" alt="image" src="https://github.com/user-attachments/assets/c6878a8f-dcb5-4f9c-9c16-373a9e95bd3d" />

</br>
</br>
</br>
</br>

### < Transparent Table >
- Activate 해야 실제 DB에 동일한 테이블 생성됨 (1:1 매핑).
- SAP 시스템에서 고유하게 존재(중복 없음).
- 키 필드 외 나머지 = Non-key(Function) 필드.
- 테이블의 한 줄 = Record(레코드).
- 참조 필드
  - 통화: `CURR` → `CUKY`
  - 수량: `QUAN` → `UNIT`
</br>
</br>

### < Structure vs Transparent Table >

- **Key 필드 일 때** : Initial Value 허용 반드시 체크 (값 없는 키 필드 생성 시 오류 방지)
- 테이블 정의 시 INCLUDE는 Structure만 추가 가능

| 항목             | Structure                | Transparent Table                     |
|------------------|---------------------------|----------------------------------------|
| 데이터 저장      | ❌ 불가                   | ✔ 가능                                 |
| 키 필드          | ❌ 없음                   | ✔ 있음                                 |
| ABAP 변수 선언   | Structure로 사용 (공통점) | Structure로 사용 (공통점)                      |
| INCLUDE          | ✔ 가능                   | ✔ 가능 (단, Structure만 가능)           |

<img width="378" height="368" alt="image" src="https://github.com/user-attachments/assets/aea9a30e-e39f-442d-84c9-9696d18a06ad" />

</br>
</br>

</br>
</br>

### < 테이블 유형과 관계 >
**1) Transparent Table**
- DB 테이블과 1:1 매핑
- 일반 업무 데이터 저장
- SAP에서 가장 많이 사용됨

**2) Cluster Table & Pool Table**
- 여러 논리 테이블을 하나의 물리 테이블에 묶음 (N:1 관계)
- 데이터 압축, 저장 공간 절약 목적
- 단점과 제약 많아 요즘은 거의 사용하지 않음 (특히 HANA 환경에서)
</br>
</br>

---

</br>

## < 테이블 정의 시 Technical Settings >
**1) 필수 항목**
- Data Class
  - 데이터 저장 공간(테이블스페이스)을 분류하는 기준
  - 데이터 성격에 따라 관리 영역이 다름
    - Master Data : 자주 바뀌지 않는 기본 데이터
    - Organizational Data : 시스템 초기 설정 데이터
    - Transaction Data : 자주 변경되는 트랜잭션 데이터
    - System Data : SAP 내부용 데이터
- Size Category
  - 테이블 예상 크기를 분류하는 옵션
  - 초기 저장 공간(initial extent) 설정 시 활용


<img width="403" height="276" alt="image" src="https://github.com/user-attachments/assets/4fa75fab-363a-4e39-8db5-a62ff419eaa2" />

</br>
</br>
</br>
</br>
    
**2) 옵션 항목**
- 로깅(Logging)
  - SE11에서 설정 가능
  - BC 팀 권한 필요
  - 실제 데이터가 변경되어야 로그 기록됨
- 버퍼링(Buffering)
  - 메모리에 데이터를 저장해 조회 속도 개선
  - 테이블 변경 발생 시, 버퍼 내용과 DB를 동기화
  - 변경 이력 기록 후 자동 갱신
 

<img width="416" height="281" alt="image" src="https://github.com/user-attachments/assets/3adf843b-470a-49e6-98e1-b046b8e23562" />

</br>
</br>

### 버퍼링 종류

<img width="477" height="184" alt="image" src="https://github.com/user-attachments/assets/180075f1-94ad-4d98-8b30-c7a5364b4f7b" />

**1) Full Buffering**
- 테이블 전체 데이터를 메모리에 저장
- 소규모 테이블에 적합
- 대용량 테이블엔 비효율적
  
**2) Generic Buffering**
- Generic Key 단위로 그룹별 데이터 저장
- 조건에 맞는 데이터 세트 캐싱
- 최대 Generic Key 개수 = 기본키 수 - 1
  
**3) Single-record Buffering**
- 한 레코드씩 메모리에 저장
- 저장 공간 효율적
- 조회 대상이 적을 때 효과적

</br>
</br>

---

</br>

## < Input Check (Validation Check) >
- 사용자 입력값이 테이블이나 필드에 저장되기 전에 유효성을 검증하는 기능
- ABAP에서 흔히 Validation Check라고 함
</br>

### < 자동 Input Check 4가지 >

**1) 필수값 체크 (Required Field Check)**
- 입력이 반드시 필요한 필드에 값이 들어왔는지 확인
</br>

**2) 외래키 체크 (Foreign Key Check)**
- 참조 테이블에 존재하는 값인지 확인
- 데이터 무결성 확보
</br>

**3) Fixed Value 체크**
- 특정 필드에 정해진 값만 허용
- 예: `C`, `Y`, `F` 등
- 데이터 양이 적어 테이블로 관리하기 애매한 값 관리에 적합
</br>

**4) Type 체크 (Data Type Check)**
- 필드 타입과 맞는 값인지 확인
- 예: 숫자형, 날짜형, 문자형 등

</br>
</br>
</br>

## < Fixed Value 설정 방법 >
**1) Fixed Value 설정하기**
- Fixed Value(고정값)는 ABAP 딕셔너리에서 오직 도메인 객체에서만 설정

<img width="388" height="253" alt="image" src="https://github.com/user-attachments/assets/004af10c-b934-4d2a-969b-a73854784a82" />
</br>
</br>

**2) 테이블에서 필드 지정**

<img width="414" height="217" alt="image" src="https://github.com/user-attachments/assets/3c0e5cbe-0155-47c3-92a2-bdb8be8770f4" />
</br>
</br>

**3) Utilities -> table contents -> create entries**

<img width="439" height="210" alt="image" src="https://github.com/user-attachments/assets/09b126b8-5099-436c-8df7-519f6418657c" />
</br>
</br>

**4) 값 입력**

<img width="285" height="242" alt="image" src="https://github.com/user-attachments/assets/f7268ba1-0770-4723-86eb-37091ae87dc4" />

</br>
</br>
</br>
</br>

## < Fixed Value 파라미터로 불러오기 >
- 도메인에 정의된 Fixed Value만 입력 가능하도록 하는 파라미터 선언
```abap
PARAMETERS <파라미터명> TYPE <데이터요소> VALUE CHECK.
```
```abap
PARAMETERS: pa_c TYPE ZDECLASS_B03 VALUE CHECK,
            pa_g TYPE ZDEGENDER_B03 VALUE CHECK.

WRITE: pa_c, pa_g.
```
</br>
</br>

---

</br>

## < 실습 코드 >
### 실습 1
- transparent 테이블 안에 .include로 structure 넣기
  
**1) `ZEMPLOY03` transparent 테이블**

<img width="520" height="313" alt="image" src="https://github.com/user-attachments/assets/c2cb8eac-dc91-4753-bd59-a510802330fc" />

</br>
</br>

**2) `ZDEPMENT03` transparent 테이블**

<img width="520" height="261" alt="image" src="https://github.com/user-attachments/assets/4eb458e1-f5ee-4ca8-981d-d4efe4f57edf" />

</br>
</br>

**3) `ZCHANGE03` structure**

<img width="538" height="176" alt="image" src="https://github.com/user-attachments/assets/2a04564e-ef1f-4c50-8fa0-5f3767857e37" />

</br>
</br>
</br>
</br>

### 실습 2
- buffering 설정 실습

**1) `ZTPERSON_B03` transparent 테이블**

<img width="516" height="272" alt="image" src="https://github.com/user-attachments/assets/86bb6d05-bef8-474e-93a8-65eeb3749f67" />

</br>
</br>

**2) buffer 설정**

<img width="399" height="343" alt="image" src="https://github.com/user-attachments/assets/dbcf567f-4e86-4819-9462-d84a76fc926f" />
</br>
</br>

**3) allow 설정**

<img width="558" height="205" alt="image" src="https://github.com/user-attachments/assets/c848a315-fa78-4ed6-a885-8d9416be3d4f" />

</br>
</br>
</br>
</br>

### 실습 3
- Fixed value 실습

**1) `ZEMPLOY03` transparent 테이블**

<img width="560" height="295" alt="image" src="https://github.com/user-attachments/assets/d53c661f-a1e3-4b73-a0f5-c674d7a1e529" />

</br>
</br>

**2) Fixed Value 설정**

<img width="504" height="388" alt="image" src="https://github.com/user-attachments/assets/ccb103ea-53de-4aeb-b477-61e240fef77b" />

</br>
</br>

**3) 출력 확인**

<img width="433" height="376" alt="image" src="https://github.com/user-attachments/assets/5bf5c3d4-64d2-4db1-8c2e-7d5bdef3ac49" />

</br>
</br>
</br>
</br>

### 실습 4
- Fixed value 실습

**1) `ZTPERSON_B03` transparent 테이블**

<img width="565" height="307" alt="image" src="https://github.com/user-attachments/assets/33141aa7-4d2d-4d58-bf01-fb012cde2bc9" />

</br>
</br>

**2) Fixed Value 설정**

<img width="419" height="294" alt="image" src="https://github.com/user-attachments/assets/51aa0b8c-0257-4d54-b60f-482e5148250f" />

</br>
</br>

**3) 출력 확인**

<img width="419" height="369" alt="image" src="https://github.com/user-attachments/assets/a953934a-8836-46ce-a57b-14d407abfb18" />


</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (12.01).md
</br>

## < 점검 테이블과 값 제한 관리 >

- **외래키 설정 시** : 데이터 입력할 때 '선택 목록'으로 제공됨
- **상위/기준 엔티티** : 참조되는 테이블 (기본 키를 제공)
- **하위/종속 엔티티** : 참조하는 테이블 (외래 키를 가짐)
- 외래키는 하위 필드를 기준으로 결정
- 외래키(Foreign Key)를 설정할 때는, 참조하는 테이블(체크 테이블)의 기본키 필드 순서와 외래키 필드 순서가 반드시 동일해야 함.
- 외래키로 연결되는 체크테이블의 필드는 모두 기본키(Primary Key)여야 함.

</br>
  
### 1) 체크 테이블 (Check Table)
- 데이터 점검하는 기준 제공
- `check field` 를 기준으로 데이터 존재 여부를 확인
- `countnum` 에 해당하는 값만 생성 가능
- Check 테이블에 없는 값은 추가 불가 → 에러 발생
- Check 필드(F>K가 됨)와 countnum의 도메인은 반드시 일치해야 함
</br>

### 2) 값 테이블 (Value Table)
- 입력 가능한 값 제한
- 도메인 기반으로 허용값 정의
- Value 테이블에 없는 값은 제한 가능
- Check 테이블과 별개로, 도메인에 맞으면 값 추가 가능
</br>

### 3) 외래 키 테이블 (Foreign Key Table)
- 실제 데이터 입력
- 체크 테이블과 값 테이블 참조
- 입력 시, 체크 기준과 도메인 일치 여부 확인
- 대상 필드(data element)가 다르더라도 도메인이 같으면 가능
</br>
</br>

### < Cardinality(관계 대응 타입) >
- 테이블 간의 관계에서 한쪽 엔티티가 다른 엔티티와 맺을 수 있는 데이터 개수를 의미
  
**1) 1:1 (One to One)**
- 한 레코드가 다른 테이블의 정확히 하나의 레코드와만 연결

**2) 1:N (One to Many)**
- 한 레코드가 다른 테이블의 여러 레코드와 연결 가능 (1 이상)

**3) 1:C**
- 특정 도메인 기반으로 한 개의 값이 여러 개의 제한 값과 연결되는 상황 (0 or 1)

**4) 1:CN**
- 1:N과 유사하나, Check Table & Domain 조합을 통한 확장된 다중 매핑을 의미 (0 or 1 or 1 이상)

<img width="495" height="341" alt="image" src="https://github.com/user-attachments/assets/6f5af294-992a-4ae0-904a-e70644e0f31d" />

</br>
</br>
</br>
</br>

### < 외래 키 (Foreign Key) 설정 과정 >
**1) 도메인에 Value Table 설정**

<img width="431" height="390" alt="image" src="https://github.com/user-attachments/assets/37619d4e-d5f5-49a1-ac7e-0684bfbc6d8b" />
</br>
</br>

**2) 외래 키 생성 시도**

<img width="521" height="286" alt="image" src="https://github.com/user-attachments/assets/d21b9e8b-4b81-40c8-af64-83516b7153b1" />
</br>
</br>

**3) 외래 키 필드 매핑**
-	2번째 : 키필드가 아닌거
-	3번째 : 키필드인 경우
-	보통은 `1:CN`
  
<img width="561" height="411" alt="image" src="https://github.com/user-attachments/assets/b3ebdb70-da38-4a84-80c3-6246b771bd43" />

</br>
</br>

**4) 외래 키 필드 매핑**
- 체크 테이블에 데이터 저장
  
<img width="579" height="281" alt="image" src="https://github.com/user-attachments/assets/df0be43e-b927-48e0-83c0-2545cffdacd0" />
</br>
</br>

**5) 외래 키 테이블 확인**
- 유효한 값 목록이 자동으로 연결되어 표시

<img width="529" height="331" alt="image" src="https://github.com/user-attachments/assets/d5312dea-d595-40e1-99c4-2cf2a5b82397" />
</br>
</br>
</br>
</br>

---
</br>

## < Text Table >
- 텍스트 테이블(Text Table)은 기존 메인 테이블의 데이터를 언어별로 저장하기 위한 테이블
- 보통 테이블 이름 끝에 T를 붙임
  - 예: `ZTGYM_MEMBER_B03T`
</br>

**필드 구성 규칙**
- 전체 키 필드 = 메인 테이블의 모든 키 + 언어키(LANGU / SPRAS)
- 언어 필드는 SPRAS 또는 LANGU 타입 사용
- 언어 필드는 T002 테이블과 외래키(FK) 연결
- 메인 테이블과도 외래키(FK) 연결
- 모든 키 필드는 PK로 설정
- 텍스트 필드는 일반 필드

<img width="602" height="234" alt="image" src="https://github.com/user-attachments/assets/baa9e85c-5c6c-40c9-a65a-63b2ab9855bb" />
</br>
</br>

<img width="543" height="392" alt="image" src="https://github.com/user-attachments/assets/ae7dc2e2-960e-4f88-b356-2a3038a67ec0" />
</br>
</br>
</br>
</br>

### < text table 예제 코드 >

**1) `ZTDANGER_B03` 테이블 생성**

<img width="556" height="194" alt="image" src="https://github.com/user-attachments/assets/acadcdff-4522-4c78-ac8b-d648542a414c" />

</br>
</br>

**12) `ZTDANGER_B03T` 테이블 생성**

<img width="508" height="197" alt="image" src="https://github.com/user-attachments/assets/9e8e5d43-51b9-4f25-b830-2d657fba3847" />
</br>
</br>

**3) `DANGER_NO` 외래키 설정**

<img width="503" height="363" alt="image" src="https://github.com/user-attachments/assets/22c5cdb6-fbdb-40d3-9d66-a10732c977fd" />

</br>
</br>

**4) `LANGU` 외래키 설정**

<img width="501" height="360" alt="image" src="https://github.com/user-attachments/assets/4e1a10d1-c32f-488e-8017-183a9e7f4768" />

</br>
</br>

**5) 결과창**
- `ZTDANGER_B03T` 결과
  
<img width="385" height="198" alt="image" src="https://github.com/user-attachments/assets/b8ff79cf-3438-45fa-8667-9b6c5115c279" />

</br>
</br>

- `ZTDANGER_B03` 결과 (영어)

<img width="421" height="159" alt="image" src="https://github.com/user-attachments/assets/47f1f564-ccda-4e1c-8ea4-a877c5bebd71" />

</br>
</br>

- `ZTDANGER_B03` 결과 (한국어)
  
<img width="414" height="171" alt="image" src="https://github.com/user-attachments/assets/39a4706c-2b2f-41ca-83a1-3cef0093910f" />

</br>
</br>
</br>
</br>

---

</br>

## < 실습 코드 >
### 실습 1

**1) 체크 테이블 설정**

<img width="569" height="209" alt="image" src="https://github.com/user-attachments/assets/2a742044-d5db-4007-8b81-8cef0ada1289" />
</br>
</br>

**2) 체크 테이블에 데이터 저장**

<img width="569" height="244" alt="image" src="https://github.com/user-attachments/assets/ffb61c78-c8e4-43cb-87e0-d7fc6efef355" />
</br>
</br>

**3) 외래 키 테이블 설정**

<img width="573" height="217" alt="image" src="https://github.com/user-attachments/assets/5be3324a-b0fe-4239-b9cb-e19fa8598765" />
</br>
</br>

**4) CARRIER에 외래 키 생성**

<img width="496" height="364" alt="image" src="https://github.com/user-attachments/assets/aab1a24c-d685-4d8a-8f85-e2d99c97ceef" />
</br>
</br>

**5) 외래 키 테이블 결과 확인**

<img width="536" height="262" alt="image" src="https://github.com/user-attachments/assets/e9ddaba3-dc17-4dae-8e7b-ff4f6326c0de" />
</br>
</br>
</br>
</br>

### 실습 2

**< 문제 >**
- 클래스 (`CLASS_ID`) : 가장 상위 개념
- 체육관 (`GYM_ID`) : 클래스에 종속됨
- 회원 (`MEMBER_ID`) : 체육관에 종속됨

<img width="553" height="504" alt="image" src="https://github.com/user-attachments/assets/f03492b1-6706-40f4-9c08-5cb3103a4126" />
</br>
</br>

**1) 상위 `ZTGYMCLASS_B03` 테이블**

<img width="562" height="204" alt="image" src="https://github.com/user-attachments/assets/e6274522-5ad0-4c10-bd96-31c4c7201c18" />

</br>
</br>

**2) `CLASS_ID`의 data element**

<img width="529" height="327" alt="image" src="https://github.com/user-attachments/assets/73ff5f37-9716-42c6-acd6-f1fddc07f068" />

</br>
</br>

**3) domain의 value table 설정**

<img width="537" height="570" alt="image" src="https://github.com/user-attachments/assets/7bd274cf-5723-4356-b0ef-efb6824dc255" />
</br>
</br>

**4) 하위 `ZTGYM_B03` 테이블**

<img width="555" height="218" alt="image" src="https://github.com/user-attachments/assets/25c5a67f-c1ce-4d35-aaf5-728593e3bae8" />
</br>
</br>

**5) `ZTGYM_B03` 테이블 내 외래 키 설정 - `CLASS_ID`**

<img width="552" height="399" alt="image" src="https://github.com/user-attachments/assets/6eb2a140-ef07-4edb-9b53-f73378342cc5" />
</br>
</br>

**6) 하위 `ZTGYM_MEMBER_B03` 테이블**

<img width="544" height="208" alt="image" src="https://github.com/user-attachments/assets/a99a91fc-35d3-4e73-b3e4-106a4ce847a2" />

</br>
</br>

**7) `ZTGYM_MEMBER_B03` 테이블 내 외래 키 설정 - `CLASS_ID`**
- 복합 외래키 설정 (체크 테이블에서 키로 지정) 
<img width="527" height="378" alt="image" src="https://github.com/user-attachments/assets/768849e3-5267-475f-99cb-452bc8239826" />

</br>
</br>

**8) `ZTGYMCLASS_B03` 테이블 결과**

<img width="528" height="175" alt="image" src="https://github.com/user-attachments/assets/883e3326-6d8c-4bfe-95d8-7e05955e1946" />

</br>
</br>

**9) `ZTGYM_B03` 테이블 결과**

<img width="525" height="275" alt="image" src="https://github.com/user-attachments/assets/d0c35e9b-b29f-4e0f-962b-ae62e6a73003" />

</br>
</br>

**10) `ZTGYM_MEMBER_B03` 테이블 결과**

<img width="523" height="215" alt="image" src="https://github.com/user-attachments/assets/2d975de8-0075-4051-828b-b781f930814e" />

</br>
</br>
</br>
</br>

### 실습 3
- text table 실습

**1) `ZTGYM_B03` 테이블**

<img width="555" height="218" alt="image" src="https://github.com/user-attachments/assets/d7e0c6fa-ad4b-4d90-839e-748ab3dfc3c7" />
</br>
</br>

**2) `ZTGYM_B03T` 테이블**

<img width="551" height="193" alt="image" src="https://github.com/user-attachments/assets/90d0bd17-f1b0-42b8-be2f-a2cd88c4026f" />

</br>
</br>

**3) 외래키 설정**
- `GYM_ID` 설정

<img width="518" height="370" alt="image" src="https://github.com/user-attachments/assets/3bb051fd-7231-4ad3-95a5-40eeb4955bed" />
</br>
</br>

- `CLASS_ID` 설정
  
<img width="520" height="372" alt="image" src="https://github.com/user-attachments/assets/cbf8e2bd-b3f3-4e0f-8ce7-14cd28608c86" />
</br>
</br>

- `LANGU` 설정
  
<img width="504" height="360" alt="image" src="https://github.com/user-attachments/assets/751b75b5-1e2f-481b-b4c5-c69bc7df6b67" />
</br>
</br>

**4) 결과창**
- text table 결과
  
<img width="447" height="246" alt="image" src="https://github.com/user-attachments/assets/f59cf592-ee05-4967-a43a-5134005031dd" />
</br>
</br>

- 다국어 설정 결과

<img width="450" height="176" alt="image" src="https://github.com/user-attachments/assets/033caef2-0588-4b3f-b5a0-ab3b897dace1" />
</br>
</br>

<img width="444" height="178" alt="image" src="https://github.com/user-attachments/assets/968aa163-0964-4625-8083-a417909e49ee" />

</br>
</br>
</br>
</br>

### 실습 4
- text table 실습

**1) `ZTGYM_MEMBER_B03` 테이블**

<img width="534" height="198" alt="image" src="https://github.com/user-attachments/assets/874f4f69-34a0-428f-b6bb-6f2d8084092b" />

</br>
</br>

**2) `ZTGYM_MEMBERB03T` 테이블**

<img width="535" height="201" alt="image" src="https://github.com/user-attachments/assets/86f3bf82-0aaf-4552-a34a-27364b5c2dfc" />

</br>
</br>

**3) 외래키 설정**
- `MEMBER_ID` 설정

<img width="503" height="362" alt="image" src="https://github.com/user-attachments/assets/6d31ebef-556c-4b8c-9c2c-4b52bcb53252" />

</br>
</br>

- `LANGU` 설정
  
<img width="478" height="340" alt="image" src="https://github.com/user-attachments/assets/cafda627-d348-4ed2-917e-d67cdbb3a3af" />

</br>
</br>

**4) 결과창**
- text table 결과
  
<img width="421" height="220" alt="image" src="https://github.com/user-attachments/assets/dae65fe3-e259-43b1-afe5-9e0a92596677" />

</br>
</br>

- 다국어 설정 결과

<img width="448" height="133" alt="image" src="https://github.com/user-attachments/assets/3e42c1a5-404e-4b0f-b50f-6c89402b44e6" />

</br>
</br>

<img width="461" height="146" alt="image" src="https://github.com/user-attachments/assets/7f204199-dae1-4acd-9114-1c3387e10844" />

</br>
</br>

</br>
</br>
</br>
</br>

# 프로그래핑 문법과 로직 (12.02).md
</br>

## 테이블 필드 데이터형을 수정하고 싶을 때 
</br>

**1) Url을 char 1로 바꾸기**

<img width="654" height="240" alt="image" src="https://github.com/user-attachments/assets/12913734-892b-47f5-bd30-663cb1987814" />
</br>
</br>

**2) `Utilities -> Database object -> Database Utility` 선택**

<img width="584" height="360" alt="image" src="https://github.com/user-attachments/assets/80b5e021-23b0-43b6-8b87-f13f9c2641c8" />

</br>
</br>

**3) `Activate and adjust database` 선택**

<img width="553" height="425" alt="image" src="https://github.com/user-attachments/assets/4e738638-1168-4bf1-aa2d-e843c44cb12f" />
</br>
</br>
</br>

---
</br>

## Append Structure
- 테이블에 새 필드를 추가할 때 쓰는 ‘확장 전용 구조’
- 1개의 Append Structure → 1개의 테이블에만 적용 가능
- 1개의 테이블 → 여러 개 Append Structure 가능
</br>

- `APPEND` = 테이블 확장용(필드 추가), 한 테이블 전용.
- `INCLUDE` = 구조 재사용용(구조 끼워넣기), 여러 테이블에서 사용.
- 프로그램에서는 둘 다 그냥 필드처럼 동일하게 접근 가능.
</br>

**1) `Extras -> Enhancement Category` 클릭**

<img width="497" height="364" alt="image" src="https://github.com/user-attachments/assets/ba6750d8-ae3d-40d2-b733-fc8ac37f79cb" />
</br>
</br>

**2) 해당 버튼 클릭**

<img width="674" height="224" alt="image" src="https://github.com/user-attachments/assets/fdb08d5d-5e4e-458a-bb00-c52177610248" />
</br>
</br>

**3) `Append Structure` 생성**

<img width="602" height="276" alt="image" src="https://github.com/user-attachments/assets/167e5254-6c8a-4d91-9cc5-0d34abfb3b0e" />

</br>
</br>

**4) Append Structure 필드 정의**
- 충돌 방지로 필드 이름은 `ZZ YY` 로 시작
<img width="602" height="250" alt="image" src="https://github.com/user-attachments/assets/57701f4f-8450-411a-891f-6aedfa9d0d20" />

</br>
</br>

**5) `.append` 필드 추가**

<img width="673" height="270" alt="image" src="https://github.com/user-attachments/assets/42f98f40-1ea1-4b96-9bfd-0b02a6a1fc3b" />

</br>
</br>
</br>
</br>
</br>

---

</br>

# < Table Join 방법 >
- JOIN은 DB 직접 접근(버퍼 X), DB View는 버퍼 사용(버퍼 O)
</br>

## 1) DDIC(Database) View를 활용
- DB 레벨에서 여러 테이블을 미리 조인하여 가상 테이블(View) 생성
- 재사용 가능, SQL 최적화, 코드 간결
- 조건 변경에는 유연하지 않음

```abap
SELECT <필드1> <필드2> ...
  FROM <DatabaseView>
  WHERE <조건>.
```
```
SELECT carrid connid carrname      
  FROM zabc        " zabc는 이미 여러 테이블을 조인해 만든 Database View
  WHERE carrid = 'LH'.
```
</br>
</br>
</br>

### 1-1) Database View
- 여러 테이블 조인 가능
- WHERE 절 설정 가능 (Selection Condition)
- JOIN 종류: 무조건 `INNER JOIN`
- ABAP 프로그램에서 TYPE과 SELECT 모두 사용 가능
</br>
</br>

**예제 1**
- `Table/Join Conditions` 에서 IN 조건에 넣을 필드와 테이블 선택

<img width="495" height="234" alt="image" src="https://github.com/user-attachments/assets/5db6f42c-bdab-4ec5-bb9b-10ea1c18cdc6" />

</br>
</br>

- `View Fields` 에서 `Table fields` 눌러서 출력할 필드 선택

<img width="494" height="238" alt="image" src="https://github.com/user-attachments/assets/74c7d487-5ea1-4f47-801a-1b8e3f3b9fa0" />

</br>
</br>

- `Selection Conditions` 에서 where 조건 달기
- operator(EQ, NQ) 와 AND/OR 조건 달기

<img width="494" height="146" alt="image" src="https://github.com/user-attachments/assets/174e9455-6f28-4f5a-8ed5-fed56f11bd6f" />


</br>
</br>
</br>
</br>
</br>

**예제 2**
- `Table/Join Conditions` 에서 `Relationships` 눌러서 출력할 테이블 선택

<img width="498" height="292" alt="image" src="https://github.com/user-attachments/assets/2322d3fe-31f2-4096-b1de-fe1ea0382ae2" />

</br>
</br>

<img width="485" height="358" alt="image" src="https://github.com/user-attachments/assets/32ead43f-85cb-4bc0-b492-0664b9c5b5fe" />

</br>
</br>

- `View Fields` 에서 `Table fields` 눌러서 출력할 필드 선택

<img width="489" height="296" alt="image" src="https://github.com/user-attachments/assets/d2e884ab-e5b1-4342-ab4f-e345dfacc6b9" />

</br>
</br>

<img width="547" height="194" alt="image" src="https://github.com/user-attachments/assets/2846f5ba-bd2f-40fb-bbc0-30a860f7e13b" />

</br>
</br>

- `Selection Conditions` 에서 where 조건 달기
- operator(EQ, NQ) 와 AND/OR 조건 달기

<img width="488" height="173" alt="image" src="https://github.com/user-attachments/assets/449f2abb-705c-427b-a2b6-6d7e5f291384" />

</br>
</br>
</br>
</br>
</br>
</br>

**예제 3**
- `Table/Join Conditions` 에서 `Relationships` 눌러서 출력할 테이블 선택

<img width="509" height="183" alt="image" src="https://github.com/user-attachments/assets/12d9f3e0-6209-4e93-b3b5-39ac47dd2b39" />

</br>
</br>

- `View Fields` 에서 `Table fields` 눌러서 출력할 필드 선택
- `*` : 테이블의 모든 필드 자동 포함
- `- 필드명` : 특정 필드만 제외

<img width="579" height="224" alt="image" src="https://github.com/user-attachments/assets/c313c351-59dc-416b-849a-0a885c1c1a0c" />

</br>
</br>

- `Selection Conditions` 에서 where 조건 달기
- operator(EQ, NQ) 와 AND/OR 조건 달기

<img width="488" height="173" alt="image" src="https://github.com/user-attachments/assets/449f2abb-705c-427b-a2b6-6d7e5f291384" />

</br>
</br>
</br>
</br>
</br>
</br>


### 1-2) Projection View
- 하나의 테이블에서 특정 필드만 추출 → Projection
- JOIN 없음
- ABAP 프로그램에서 TYPE/SELECT 모두 사용 가능
</br>
</br>

**예제**
- `SE11`에서 view 선택 후 생성
  
<img width="423" height="283" alt="image" src="https://github.com/user-attachments/assets/eaed92d0-3775-457e-bd89-ed2df2e600b6" />
</br>
</br>

<img width="311" height="240" alt="image" src="https://github.com/user-attachments/assets/b93f7a4d-85e3-4bd0-ae65-67242bc1c841" />
</br>
</br>

- 출력할 필드 선택
<img width="491" height="229" alt="image" src="https://github.com/user-attachments/assets/db775d5b-607c-4cf4-8629-d75f18a5e721" />

</br>
</br>
</br>
</br>

 ### 1-3) Maintenance View (SE54, SE30)
- 여러 테이블을 묶어서 한 화면에서 CRUD 가능
- JOIN 방식: 무조건 `LEFT OUTER JOIN`
- ABAP 프로그램에서 SELECT 불가 (테이블 유지 용도)

</br>
</br>

**예제 1**
- `Maint.Status` 에서 Access 조건 선택
  
<img width="629" height="388" alt="image" src="https://github.com/user-attachments/assets/ca869525-3a12-4602-8685-0999e7ba9df8" />

</br>
</br>

- `Table/Join Conditions` 에서 출력할 테이블 선택

<img width="622" height="478" alt="image" src="https://github.com/user-attachments/assets/3b6efd3c-96b9-4d42-a626-84130e0a2341" />

</br>
</br>

- `View Fields` 에서 `Table fields` 눌러서 출력할 필드 선택

<img width="627" height="303" alt="image" src="https://github.com/user-attachments/assets/14a29c38-fcf1-4dd7-ac9f-719f3517b048" />

</br>
</br>

- `utilities -> table maintenance generator` 선택
  
<img width="623" height="383" alt="image" src="https://github.com/user-attachments/assets/d2289232-5df1-44ff-9e29-cfe8d621d0a9" />

</br>
</br>

- dialog 작성
 
<img width="646" height="438" alt="image" src="https://github.com/user-attachments/assets/9c6fdc38-a1b6-4f9d-8ac0-3bb45e9c2f11" />
</br>
</br>

- function group 생성 후 active까지 하기 (그룹 마우스 우클릭)
<img width="306" height="305" alt="image" src="https://github.com/user-attachments/assets/09948041-9902-4a30-80b3-0f38ef9c3f02" />
</br>
</br>

- 결과 확인 (조회, 수정, 삭제 CRUD 기능 가능)
<img width="643" height="403" alt="image" src="https://github.com/user-attachments/assets/f279ac8f-5eaa-42ba-8319-ef322e111fa0" />
</br>
</br>

- `two step` 일 경우 더블클릭 시 수정 가능
  
<img width="619" height="254" alt="image" src="https://github.com/user-attachments/assets/f783e467-1560-4c1f-94da-1d26c3a9af83" />

</br>
</br>

<img width="413" height="303" alt="image" src="https://github.com/user-attachments/assets/34bc5a63-0c97-4020-b73d-0f598210cc2d" />

</br>
</br>
</br>
</br>
</br>

**예제 2**
- `Table/Join Conditions` 에서 출력할 테이블 선택

<img width="598" height="382" alt="image" src="https://github.com/user-attachments/assets/0cd634b1-f761-47b3-ae51-3aae0193e05e" />

</br>
</br>

- `View Fields` 에서 `Table fields` 눌러서 출력할 필드 선택

<img width="650" height="256" alt="image" src="https://github.com/user-attachments/assets/0b209476-4a8f-497f-a497-22aff6022cd0" />

</br>
</br>

- `utilities -> table maintenance generator` 선택 (dialog 작성)
  
<img width="650" height="472" alt="image" src="https://github.com/user-attachments/assets/db6ee4f1-d457-45c1-a442-f77213e8097c" />
</br>
</br>

- function group 생성 후 active까지 하기 (그룹 마우스 우클릭)
  
<img width="374" height="355" alt="image" src="https://github.com/user-attachments/assets/fc9e1ec2-e0ce-4bf8-b017-33a00ad4702c" />
</br>
</br>

- `one step` 일 경우 더블클릭해도 수정 불가능

<img width="517" height="260" alt="image" src="https://github.com/user-attachments/assets/2cf9e82f-965d-4c0c-adae-b424efc9d456" />
</br>
</br>

- `SM30`으로 이동 후 수정, 조회, 삭제 등 가능
  
<img width="507" height="336" alt="image" src="https://github.com/user-attachments/assets/164eb900-f1bd-4fcd-ab90-d43c83dabd2e" />

</br>
</br>
</br>
</br>
</br>
</br>

### 1-4) Help View
- Search Help(F4 도움창)에서만 사용
- JOIN 방식: 무조건 LEFT OUTER JOIN
- 프로그램에서 SELECT로 사용 불가
</br>
</br>
</br>
</br>
</br>

## 2) 프로그램에서 직접 조인
- ABAP 프로그램 안에서 SELECT문에서 직접 JOIN 수행
- 조건을 동적으로 처리 가능, 유연성 높음
- 코드 길어지고, DB 최적화는 View보다 어려움
</br>

- `INNER JOIN` : 두 테이블 모두에 있는 데이터만 반환 (교집합)
- `LEFT OUTER JOIN` : 왼쪽 테이블 기준, 오른쪽 테이블 없으면 NULL 포함
</br>

- `-` : 필드 접근용 (JOIN 에서만 안씀)
- `~` : JOIN 사용 시에만 사용
```abap
SELECT <테이블1~필드>, <테이블2~필드>
  INTO TABLE <내테이블>
  FROM <테이블1>
  INNER JOIN <테이블2>
  ON <테이블1~키> = <테이블2~키>
  WHERE <조건>.
```
- `INNER JOIN` 예제
```abap
SELECT SCARR~CARRID
       SPFLI~CONNID
       SCARR~CARRNAME
       SPFLI~CITYFROM
  INTO TABLE lt_flight
  FROM SCARR as A INNER JOIN SPFLI as B
    ON SCARR~CARRID = SPFLI~CARRID      " spfli와 scarr 모두 존재하는 carrid만 결과에 포함
  WHERE SCARR~CARRID = 'AA'.

  IF sy-subrc = 0.
    cl_demo_output=>display( lt_flight ).
  ENDIF.
```
- `LEFT OUTER JOIN` 예제
```abap
DATA: BEGIN OF ls_flight,
        carrid   TYPE s_carr_id,
        connid   TYPE s_conn_id,
        carrname TYPE s_carrname,
        cityfrom TYPE s_from_cit,
      END OF ls_flight.
DATA: lt_flight LIKE TABLE OF ls_flight.

SELECT A~carrid B~connid A~carrname B~cityfrom
  INTO TABLE lt_flight
  FROM scarr AS A LEFT OUTER JOIN spfli AS B
    ON A~carrid = B~carrid
  WHERE A~carrid BETWEEN 'NG' AND 'UA'.

SORT lt_flight BY carrid.

IF sy-subrc = 0.
  LOOP AT lt_flight INTO ls_flight.
    WRITE:/ ls_flight-carrid,
            ls_flight-connid,
            ls_flight-carrname,
            ls_flight-cityfrom.
  ENDLOOP.
ENDIF.
```
</br>
</br>
</br>

---

</br>

## < 실습 코드 >
### 실습 1
- `Table/Join Conditions` 에서 `Relationships` 눌러서 출력할 테이블 선택

<img width="616" height="372" alt="image" src="https://github.com/user-attachments/assets/276f20de-44f0-4b98-bee8-37d380c11332" />

</br>
</br>

- `View Fields` 에서 `Table fields` 눌러서 출력할 필드 선택

<img width="617" height="327" alt="image" src="https://github.com/user-attachments/assets/f771c3a7-a19b-4f8b-835c-d7c4dce0414f" />

</br>
</br>

- `Maint.Status` 에서 Access 조건 선택
  
<img width="625" height="402" alt="image" src="https://github.com/user-attachments/assets/77cb2dee-b1ab-4d08-b890-6fbeb04b4e1c" />
</br>
</br>

- dialog 작성
 
<img width="606" height="479" alt="image" src="https://github.com/user-attachments/assets/c20175d4-0783-4589-a442-07fee6f2f0ac" />
</br>
</br>

- function group 생성 후 active까지 하기 (그룹 마우스 우클릭)
<img width="304" height="292" alt="image" src="https://github.com/user-attachments/assets/6aa54123-32c2-49d9-8a6c-01a1a2670f15" />

</br>
</br>
</br>
</br>
</br>

</br>
</br>
</br>
</br>

---

</br>

### 1) 실습 1 - SELECT 활용해서 출력
- SELECT 쓰고 LOOP문 쓰기
```abap
*&---------------------------------------------------------------------*
*& Report ZBC400_B03_ITAB01
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
REPORT zbc400_b03_itab01.

PARAMETERS: pa_car TYPE s_carr_id.

DATA: BEGIN OF gs_data.
        INCLUDE TYPE ZSCLB03_DEMO.
DATA: SEATREMAIN TYPE INT4,
      SEATREMAIN_B TYPE INT4,
      SEATREMAIN_F TYPE INT4,
      END OF gs_data.
DATA: gt_data LIKE TABLE OF gs_data,
      gs_scarr TYPE SCARR,
      gt_scarr LIKE TABLE OF gs_scarr,
      gs_spfli TYPE SPFLI,
      gt_spfli LIKE TABLE OF gs_spfli.

SELECT-OPTIONS: so_con FOR gs_data-CONNID,
                so_dat FOR gs_data-FLDATE.

IF sy-subrc <> 0.
  MESSAGE 'Data is not found' TYPE 'E'.
ENDIF.

*****    2. SFLIGHT Table에서 기본적으로 제공될 Flight List Info를 취득해서 데이터를 보여준다.

SELECT * FROM sflight
  INTO CORRESPONDING FIELDS OF TABLE gt_data
  WHERE carrid = pa_car AND connid IN so_con.

*****    3. SCARR Table에서 CARRNAME를 취득해서 데이터를 보여준다.

SELECT carrid, carrname FROM scarr
  INTO CORRESPONDING FIELDS OF TABLE @gt_scarr.

LOOP AT gt_data INTO gs_data.
  READ TABLE gt_scarr INTO gs_scarr WITH KEY carrid = gs_data-carrid.
  gs_data-carrname = gs_scarr-carrname.
  MODIFY gt_data FROM gs_data TRANSPORTING carrname.
ENDLOOP.

*LOOP AT scarr INTO gs_data.
*
*ENDLOOP.

*****    4. SPFLI Table에서 CITYFROM, CITYTO를 취득해서 데이터를 보여준다.

SELECT carrid, connid, cityfrom, cityto FROM spfli
  INTO CORRESPONDING FIELDS OF TABLE @gt_spfli.

LOOP AT gt_data INTO gs_data.
  READ TABLE gt_spfli INTO gs_spfli WITH KEY carrid = gs_data-carrid
                                             connid = gs_data-connid.
  gs_data-cityfrom = gs_spfli-cityfrom.
  gs_data-cityto = gs_spfli-cityto.
  MODIFY gt_data FROM gs_data TRANSPORTING cityfrom cityto.
ENDLOOP.

*****    5. economy class, business class, first class의 각 남은 좌석을 구한다.

LOOP AT gt_data INTO gs_data.
  gs_data-SEATREMAIN = gs_data-SEATSMAX - gs_data-SEATSOCC.
  gs_data-SEATREMAIN_B = gs_data-SEATSMAX_B - gs_data-SEATSOCC_B.
  gs_data-SEATREMAIN_F = gs_data-SEATSMAX_F - gs_data-SEATSOCC_F.
  MODIFY gt_data FROM gs_data.
ENDLOOP.

IF sy-subrc <> 0.
  MESSAGE 'Data is not found' TYPE 'E'.
ELSE.
  cl_demo_output=>display_data( gt_data ).
ENDIF.
```
</br>
</br>

### 2) 실습 1 - SELECT 활용해서 출력
- LOOP문 안에 SELECT 쓰기  ( 안됨 !! LOOP 안에는 READ 쓰기 )
```abap
*&---------------------------------------------------------------------*
*& Report ZBC400_B03_ITAB01
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
REPORT zbc400_b03_itab01.

PARAMETERS: pa_car TYPE s_carr_id.

DATA: BEGIN OF gs_data.
        INCLUDE TYPE ZSCLB03_DEMO.
DATA: SEATREMAIN TYPE INT4,
      SEATREMAIN_B TYPE INT4,
      SEATREMAIN_F TYPE INT4,
      END OF gs_data.
DATA: gt_data LIKE TABLE OF gs_data,
      gv_carrname TYPE S_CARRNAME.

SELECT-OPTIONS: so_con FOR gs_data-CONNID,
                so_dat FOR gs_data-FLDATE.

IF sy-subrc <> 0.
  MESSAGE 'Data is not found' TYPE 'E'.
ENDIF.

*****    2. SFLIGHT Table에서 기본적으로 제공될 Flight List Info를 취득해서 데이터를 보여준다.

SELECT * FROM sflight
  INTO CORRESPONDING FIELDS OF TABLE gt_data
  WHERE carrid = pa_car AND connid IN so_con.

*****    3. SCARR Table에서 CARRNAME를 취득해서 데이터를 보여준다.

*LOOP AT gt_data INTO gs_data.
*  SELECT SINGLE carrname FROM scarr
*    INTO gv_carrname
*    WHERE carrid = pa_car.
*  gs_data-carrname = gv_carrname.
*  MODIFY gt_data FROM gs_data.
*ENDLOOP.
* <-- 이렇게 써도 가능

LOOP AT gt_data INTO gs_data.
  SELECT SINGLE carrname FROM scarr
    INTO gs_data-carrname
    WHERE carrid = pa_car.
  MODIFY gt_data FROM gs_data.
ENDLOOP.

*****    4. SPFLI Table에서 CITYFROM, CITYTO를 취득해서 데이터를 보여준다.

LOOP AT gt_data INTO gs_data.
  SELECT SINGLE cityfrom cityto FROM spfli
    INTO (gs_data-cityfrom, gs_data-cityto)
    WHERE carrid = pa_car.
  MODIFY gt_data FROM gs_data.
ENDLOOP.

******    5. economy class, business class, first class의 각 남은 좌석을 구한다.

LOOP AT gt_data INTO gs_data.
  gs_data-SEATREMAIN = gs_data-SEATSMAX - gs_data-SEATSOCC.
  gs_data-SEATREMAIN_B = gs_data-SEATSMAX_B - gs_data-SEATSOCC_B.
  gs_data-SEATREMAIN_F = gs_data-SEATSMAX_F - gs_data-SEATSOCC_F.
  MODIFY gt_data FROM gs_data.
ENDLOOP.

IF sy-subrc <> 0.
  MESSAGE 'Data is not found' TYPE 'E'.
ELSE.
  cl_demo_output=>display_data( gt_data ).
ENDIF.
```
</br>
</br>

### 3) 실습 1 - SELECT 활용해서 출력
- LOOP문 안에 SELECT 쓰기 수정한 버전
```abap
*&---------------------------------------------------------------------*
*& Report ZBC400_B03_ITAB01
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
REPORT zbc400_b03_itab01.

PARAMETERS: pa_car TYPE s_carr_id.

DATA: BEGIN OF gs_data.
        INCLUDE TYPE ZSCLB03_DEMO.
DATA: SEATREMAIN TYPE INT4,
      SEATREMAIN_B TYPE INT4,
      SEATREMAIN_F TYPE INT4,
      END OF gs_data.
DATA: gt_data LIKE TABLE OF gs_data,
      gv_carrname TYPE S_CARRNAME,
      gv_cityfrom TYPE S_FROM_CIT,
      gv_cityto TYPE S_TO_CITY.

SELECT-OPTIONS: so_con FOR gs_data-CONNID,
                so_dat FOR gs_data-FLDATE.

IF sy-subrc <> 0.
  MESSAGE 'Data is not found' TYPE 'E'.
ENDIF.

*****    2. SFLIGHT Table에서 기본적으로 제공될 Flight List Info를 취득해서 데이터를 보여준다.

SELECT * FROM sflight
  INTO CORRESPONDING FIELDS OF TABLE gt_data
  WHERE carrid = pa_car AND connid IN so_con.

*****    3. SCARR Table에서 CARRNAME를 취득해서 데이터를 보여준다.

SELECT SINGLE carrname FROM scarr
  INTO gv_carrname
  WHERE carrid = pa_car.

LOOP AT gt_data INTO gs_data.
  gs_data-carrname = gv_carrname.
  MODIFY gt_data FROM gs_data.
ENDLOOP.

*****    4. SPFLI Table에서 CITYFROM, CITYTO를 취득해서 데이터를 보여준다.

SELECT SINGLE cityfrom cityto FROM spfli
  INTO (gv_cityfrom, gv_cityto)
  WHERE carrid = pa_car.

LOOP AT gt_data INTO gs_data.
  gs_data-cityfrom = gv_cityfrom.
  gs_data-cityto = gv_cityto.
  MODIFY gt_data FROM gs_data.
ENDLOOP.

*******    5. economy class, business class, first class의 각 남은 좌석을 구한다.

LOOP AT gt_data INTO gs_data.
  gs_data-SEATREMAIN = gs_data-SEATSMAX - gs_data-SEATSOCC.
  gs_data-SEATREMAIN_B = gs_data-SEATSMAX_B - gs_data-SEATSOCC_B.
  gs_data-SEATREMAIN_F = gs_data-SEATSMAX_F - gs_data-SEATSOCC_F.
  MODIFY gt_data FROM gs_data.
ENDLOOP.

IF sy-subrc <> 0.
  MESSAGE 'Data is not found' TYPE 'E'.
ELSE.
  cl_demo_output=>display_data( gt_data ).
ENDIF.
```
</br>
</br>
</br>

---
</br>

---

</br>
</br>

# ABAP 심화
</br>

# 12/11
</br>
</br>

## <  핵심 개념 >
</br>

- **1) `module pool program` 생성 방법 ( 일반 프로그램 생성 방법에서 include 파일 포함 )**
- **2) 모듈풀 프로그램은 무조건 `TCODE` 생성해야 함**
</br>

- **값 있으면 조건 걸고 / 이니셜이면 조건 무시**
```abap
SELECT *
  FROM sflight
  INTO TABLE gt_data
  WHERE ( carrid = p_carr OR p_carr IS INITIAL )
    AND ( connid = p_conn OR p_conn IS INITIAL ).
```
</br>

---

</br>

## < ABAP 개념 >
</br>

### < 프로그램 타입 >
- 둘 다 DB CRUD 작업 가능
- Report / Module Pool 모두 INCLUDE 사용 가능
</br>

**1) Type 1 – Executable Program (Report Program)**
- 바로 실행 가능한 일반 프로그램
- SE38/SE80에서 바로 Run 가능

**2) Type M – Module Pool Program**
- 스크린 기반 프로그램
- 단독 실행 불가 → 반드시 `T-code` 필요
- 프로그램명: `SAPMZ` , `SAPMY` 로 시작
- 생성 방식은 일반 프로그램과 비슷
- 단, `Top Include` 체크 후 생성

</br>
</br>

### < 스크린 동작 흐름 >
**1) PBO (Process Before Output)**
- 스크린 출력 전에 실행되는 로직
- 100번 스크린이 뜨기 전에 필요한 초기 세팅을 여기서 처리

**2) PAI (Process After Input)**
- 스크린 표시 후, 사용자가 입력 → 이벤트 발생 후 실행
- 버튼 클릭, 엔터 입력 후 로직 처리

<img width="464" height="319" alt="image" src="https://github.com/user-attachments/assets/7652d97a-c07c-4772-a476-bd09e6538d14" />
</br>
</br>
</br>
</br>

### < 스크린 속성(Screen Attributes) >
- `Normal(View)` : 일반 화면
- `Subscreen` : 화면 내 포함되는 하위 화면 (fragment 느낌)
- `Modal Dialog Box` : 팝업 형태
- `Selection Screen` : 선택 화면

</br>
</br>

### < OK-CODE란? >
- 스크린과 프로그램 간에 사용자 명령(Function Code)을 주고받는 필드
- 시스템 변수 `sy-ucomm`
  
  - OK-CODE 값이 실제 저장되는 시스템 필드
    
    - 사용자가 버튼/엔터 입력 → OK-CODE 생성
    - 이 값이 `sy-ucomm` 에 들어옴
    - PAI에서 `CASE sy-ucomm` 으로 분기 처리
- 시스템 변수 'sy-dynnr' : 현재 실행 중인 스크린 번호를 알려줌

</br>
</br>

---

</br>

## < module pool program 생성 >
- 모듈풀(Type M)은 T-code를 만들어야만 실행 가능 (Report와 달리 직접 실행 불가)
- Module Pool Include 구조
  
  - `I01` : Input 관련 로직
  - `O01` : Output 관련 로직
  - `F01` : Function·기능 로직
- `Next Screen` : 다음에 어떤 화면을 띄울지 결정
  
  - `next dynpro = 0` 은 빈값과 같음
  - 현재 화면 처리 후 자동으로 ‘뒤로가기(back)’
  - `next dynpro = Default` → 현재 화면 유지
- 9000번 이상은 사용 금지 (CBO 영역이므로 충돌 위험)

</br>
</br>

### < Module Pool 기본 생성 및 T-Code 실행 >
</br>

**1) 프로그램 생성 후 프로그램에 스크린 생성**

<img width="421" height="320" alt="image" src="https://github.com/user-attachments/assets/c82fc429-0d39-45b3-8a72-3b8d9cd00985" />
</br>
</br>

**2) 스크린 dynpro 지정**

<img width="565" height="369" alt="image" src="https://github.com/user-attachments/assets/580bf983-2d39-4cb6-ac75-542825de91de" />
</br>
</br>

- 엔터 치면 뒤로가기 설정하고 싶으면 `next dynpro = 0`
<img width="564" height="433" alt="image" src="https://github.com/user-attachments/assets/4896f30e-0df5-49f3-887d-ee1c110f13c6" />

</br>
</br>

**3) 스크린에서 Layout 클릭**

<img width="579" height="384" alt="image" src="https://github.com/user-attachments/assets/46bde9cf-13e3-4905-8626-b105ad58e8df" />
</br>
</br>

**4) 스크린창에서 text 생성**

<img width="676" height="344" alt="image" src="https://github.com/user-attachments/assets/2df2ff1b-d20f-486e-b9c9-3f61f9c85563" />
</br>
</br>

**5) TCODE 생성 - program에 생성**

<img width="528" height="359" alt="image" src="https://github.com/user-attachments/assets/8328e9ba-17f2-4a73-a936-ff6ac3fff6f1" />
</br>
</br>

**6) TCODE 생성 - program and dynpro 체크**

<img width="586" height="372" alt="image" src="https://github.com/user-attachments/assets/0e69a724-19d3-4d59-8a57-abf9efe4bb7f" />
</br>
</br>

**7) TCODE 생성 - screen number 고려해서 생성**

<img width="597" height="429" alt="image" src="https://github.com/user-attachments/assets/47fbb42f-02bb-426e-96ce-794f115f1c76" />

</br>
</br>

**8) TCODE 생성 -  TCODE 입력시 창 열림**
- `/OZTCODESCREENB03` 입력시 이 창이 띄워짐
-	위 버튼 비활성화 -> 스크린마다 다르게 버튼 설정 가능
<img width="350" height="231" alt="image" src="https://github.com/user-attachments/assets/b71ee012-d91c-4c6a-8aec-cc81d15065f2" />

</br>
</br>
</br>
</br>
</br>
</br>

---

</br>

## < 스크린 파일 내 PBO, PAI 모듈 생성 >
- 스크린 필드명과 ABAP 프로그램의 필드명을 동일하게 해야 연결됨.
</br>

**1) 스크린 파일 열기** 

<img width="435" height="204" alt="image" src="https://github.com/user-attachments/assets/3dcc5695-3756-4fce-8e9c-777fa1901393" />
</br>
</br>

**2) 모듈 `STATUS_0100` 와 `USER_COMMAND_0100` 생성** 

<img width="596" height="262" alt="image" src="https://github.com/user-attachments/assets/ecbde80e-6778-4eac-8640-8e83d30bf762" />

</br>
</br>

**3) `STATUS_0100` 안에 있는 `PF_STATUS` 랑 `TITLEBAR` 생성** 

<img width="581" height="174" alt="image" src="https://github.com/user-attachments/assets/158e8a48-0af7-4715-8e9a-9f2df9504033" />
</br>
</br>

<img width="533" height="340" alt="image" src="https://github.com/user-attachments/assets/40317b12-abbb-4701-b894-4cd8a61fa110" />
</br>
</br>

<img width="540" height="164" alt="image" src="https://github.com/user-attachments/assets/2f8c92d9-f224-44fa-9e5f-69506a12caf0" />
</br>
</br>

<img width="573" height="142" alt="image" src="https://github.com/user-attachments/assets/610331b4-9625-4f1f-b72a-5f5ce51714b7" />
</br>
</br>

**4) 타이틀이 바뀐 것을 확인** 

<img width="412" height="258" alt="image" src="https://github.com/user-attachments/assets/5c6d40c9-47a5-495a-905f-21c4648690c4" />
</br>
</br>
</br>
</br>
</br>
</br>

### < 스크린 Layout 기능 >
</br>

**1) 스크린의 Layout에서 다양하게 구성 가능**

<img width="518" height="416" alt="image" src="https://github.com/user-attachments/assets/baa5878e-248a-444e-9cb1-ca9ec07970b9" />
</br>
</br>

**2) TCODE 검색으로 결과 확인 가능**

<img width="523" height="389" alt="image" src="https://github.com/user-attachments/assets/7c53ec59-3f18-4c93-bf25-29b9079eb865" />
</br>
</br>
</br>
</br>

---

</br>

## < ABAP ↔ 스크린 코드 모음 >
- **가장 중요한 점 : TCODE 생성**
</br>

### 1) ABAP 프로그램에서 구조 선언

- 무조건 구조체로만 생성
- OK_CODE 추가 필수. 타입은 반드시 `SY-UCOMM`
```abap
TABLES: sdyn_conn, scarr.
DATA OK_CODE TYPE sy-ucomm.
```
</br>
</br>

### 2) 스크린에서도 같은 이름을 사용 / OK_CODE 추가 필수

- 이름이 동일하면 자동으로 ABAP 변수와 값이 동기화됨
- PBO/PAI에서 MOVE 구문 필요 없음
```abap
SDYN_CONN-CARRID
SDYN_CONN-CONNID
OK_CODE
```
</br>
</br>

### 3) sy-dynnr (현재 스크린 번호)
- 현재 실행 중인 스크린 번호를 알려줌
```abap
sy-dynnr
```
</br>
</br>

### 4) 뒤로가기 (Back) 처리
- next screen 을 0으로 주면 뒤로가기(back) 기능 수행
- PAI에서 엔터/버튼 후 해당 구문 실행 시 이전 화면으로 돌아감
```abap
LEAVE TO SCREEN 0.
```
</br>
</br>

### 5) 필드 초기화 (CLEAN)
- 입력, 출력 필드 초기화 가능
```abap
MODULE clear_fields OUTPUT.
  CLEAR INPUT01.
  CLEAR OK_CODE.
ENDMODULE.
```
</br>
</br>

### 6) TCODE 생성 (TCODE를 생성해야 실행이 됨)

</br>
</br>
</br>

---
</br>

## < ABAP ↔ 스크린 코드 예제 >
</br>

**1) 상단 두번째 그림 클릭 시 DB 테이블 목록을 선택 가능**

<img width="474" height="206" alt="image" src="https://github.com/user-attachments/assets/39ef0a75-d2c5-42e6-8830-659d879ec19a" />

</br>
</br>

**2) 테이블명 입력 후 get from dictionary 클릭**

<img width="559" height="113" alt="image" src="https://github.com/user-attachments/assets/0ee1f644-3b66-4474-955a-73b4fcfc21ec" />

</br>
</br>

**3) 화면에 출력하고 싶은 필드 선택**

<img width="480" height="336" alt="image" src="https://github.com/user-attachments/assets/19e72e7f-7991-44d5-8bb6-f99584fb55de" />

</br>
</br>

**4) 입력/출력 창 지정**
- 버튼들 더블클릭 후에 속성 설정 가능
    
<img width="480" height="275" alt="image" src="https://github.com/user-attachments/assets/dbdf677f-5ac3-4850-9cfd-2421f88c17f6" />
</br>
</br>

- input 값에 required 선택 시 필수값 지정
  
<img width="375" height="252" alt="image" src="https://github.com/user-attachments/assets/ff465ba0-48ca-4e44-ad5e-501a273f02b1" />

- input 선택 해제 시 output 용으로 변경

<img width="424" height="252" alt="image" src="https://github.com/user-attachments/assets/c20a3b8f-6c12-4dc6-8cec-d986c5ea9be8" />

</br>
</br>

**5) 스크린 파일 `element list`에 `OK_CODE` 필드 추가**

<img width="652" height="313" alt="image" src="https://github.com/user-attachments/assets/f7d67885-0da2-40ee-9554-f42c5d4c2292" />

</br>
</br>

**6) `TOP` 파일에 변수 선언**
- tables 선언, OK_CODE 데이터로 선언 필수 
```abap
PROGRAM SAPMZMDPB03_001.

TABLES: SDYN_CONN. " 스크린 안에 생성한
                   " Table/Structure

DATA: INPUT01 TYPE C, " 입출력 필드
      OK_CODE TYPE SY-UCOMM. " OK_CODE
```
</br>

**4) 스크린 파일 코드에 PBO, PAI 모듈 추가**
```abap
PROCESS BEFORE OUTPUT.
 MODULE STATUS_0100.
 MODULE CLEAR_FIELDS.

PROCESS AFTER INPUT.
 MODULE USER_COMMAND_0100.
```
</br>

**5) PAI 코드 추가**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZMDPB03_001
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.
  CASE INPUT01.
    WHEN 'X'.
      SELECT SINGLE CARRID CONNID CITYFROM CITYTO
        INTO CORRESPONDING FIELDS OF SDYN_CONN
        FROM SPFLI
        WHERE CARRID = SDYN_CONN-CARRID
          AND CONNID = SDYN_CONN-CONNID.
    WHEN 'E'.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```
</br>

**6) PBO 코드 추가**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZMDPB03_001
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.
 SET PF-STATUS 'S100'. " Application 버튼들 등 설정
 SET TITLEBAR 'T100'.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE clear_fields OUTPUT.
  CLEAR INPUT01.
  CLEAR OK_CODE.
ENDMODULE.
```
</br>

**7) TCODE 생성**

<img width="559" height="392" alt="image" src="https://github.com/user-attachments/assets/a366e09f-45b7-4db3-9a08-b3904f732747" />
</br>
</br>

**8) 결과 확인**

<img width="652" height="331" alt="image" src="https://github.com/user-attachments/assets/a922ceab-571f-46c6-83c8-e620163e85c9" />

</br>
</br>

---

</br>

## < 실습 코드 >
### 실습 1

**1) 스크린 `Layout` 디자인**

<img width="620" height="386" alt="image" src="https://github.com/user-attachments/assets/a3a604f3-eba2-4c67-bfb1-cd29d0f82c66" />
</br>
</br>

**2) 스크린 파일 `element list`에서 `OK_CODE` 추가**

<img width="623" height="349" alt="image" src="https://github.com/user-attachments/assets/95ea6ac0-944a-4048-9c8c-fc5e80964fa2" />
</br>
</br>

**3) `TOP` 파일에 변수 선언**
- tables 선언, OK_CODE 데이터로 선언 필수 
```abap
PROGRAM SAPMZBC410_SOLUTION_03.

TABLES: SDYN_CONN.

DATA: exit_button TYPE C,
      OK_CODE TYPE SY-UCOMM,
      gs_data TYPE SDYN_CONN,
      gv_subrc TYPE sy-subrc.
```
</br>

**4) 스크린 파일 코드에 PBO, PAI 모듈 추가**
```abap
PROCESS BEFORE OUTPUT.
 MODULE STATUS_0100.
*
PROCESS AFTER INPUT.
  MODULE CHECK_SFLIGHT.
  MODULE USER_COMMAND_0100.
```
</br>

**5) PAI 코드 추가**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZBC410_SOLUTION_03
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.

  IF exit_button = 'X'.
    LEAVE TO SCREEN 0.
  ENDIF.

ENDMODULE.

*&---------------------------------------------------------------------*

MODULE check_sflight INPUT.

  SELECT SINGLE * FROM sflight
    INTO CORRESPONDING FIELDS OF gs_data
    WHERE carrid = SDYN_CONN-carrid
      AND connid = SDYN_CONN-connid
      AND fldate = SDYN_CONN-fldate.

  IF sy-subrc <> 0.
    gv_subrc = 4.
    message text-007 TYPE 'I'.
  ENDIF.

ENDMODULE.
```
</br>

**6) PBO 코드 추가**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZBC410_SOLUTION_03
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.
  IF gv_subrc <> 0.
    CLEAR SDYN_CONN.
    gv_subrc = 0.
  ELSE.
    MOVE-CORRESPONDING gs_data TO SDYN_CONN.
  ENDIF.
ENDMODULE.
```
</br>

**7) TCODE 생성**

<img width="542" height="382" alt="image" src="https://github.com/user-attachments/assets/c5ade457-68f6-4730-b72c-b83ea00b645b" />
</br>
</br>

**8) 결과 확인**
- 입력 값 입력 후에 엔터 치면 결과 출력, `X` 입력 후 엔터 치면 뒤로가기
  
<img width="492" height="339" alt="image" src="https://github.com/user-attachments/assets/5e884687-7bb1-47af-a3b9-15f8b588d209" />
</br>
</br>
</br>
</br>

### 실습 2
</br>

- 문제
<img width="471" height="249" alt="image" src="https://github.com/user-attachments/assets/8a73e537-7367-468b-82b7-01306c4bbba5" />
</br>
</br>
</br>

**1) 스크린 `Layout` 디자인**

<img width="525" height="376" alt="image" src="https://github.com/user-attachments/assets/97c0df65-cb89-4410-8d35-55cd1f5c71ad" />

</br>
</br>

**2) 스크린 파일 `element list`에서 `OK_CODE` 추가**

<img width="606" height="249" alt="image" src="https://github.com/user-attachments/assets/1613c966-2636-4245-9b84-02dc8ce29cf6" />

</br>
</br>

**3) `TOP` 파일에 변수 선언**
- tables 선언, OK_CODE 데이터로 선언 필수 
```abap
PROGRAM SAPMZPRACTICE01B03.

TABLES: smeal.

DATA: OK_CODE TYPE sy-ucomm,
      gt_data TYPE TABLE OF smeal.
```
</br>

**4) 스크린 파일 코드에 PBO, PAI 모듈 추가**
```abap
PROCESS BEFORE OUTPUT.
* MODULE STATUS_0100.
*
PROCESS AFTER INPUT.
 MODULE USER_COMMAND_0100.
```
</br>

**5) PAI 코드 추가**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZPRACTICE01B03
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.

  SELECT * FROM smeal
    INTO CORRESPONDING FIELDS OF TABLE gt_data
    WHERE carrid = SMEAL-CARRID.

  cl_demo_output=>display( gt_data ).

  LEAVE TO SCREEN 0.

ENDMODULE.
```
</br>

**6) TCODE 생성**

<img width="604" height="426" alt="image" src="https://github.com/user-attachments/assets/ffe9d3ad-2924-42dc-88d0-b1c2984205ca" />

</br>
</br>

**7) 결과 확인**
- 입력 값 입력 후에 엔터 치면 테이블 출력
  
<img width="307" height="195" alt="image" src="https://github.com/user-attachments/assets/04c34b4c-cc6d-4cbc-bb71-fea1538821d4" />
</br>
</br>

<img width="403" height="388" alt="image" src="https://github.com/user-attachments/assets/1a9e35ea-328f-4eb2-aeda-649ff7ae24e5" />

</br>
</br>
</br>
</br>

</br>
</br>

# 12/12

</br>
</br>

## <  핵심 개념 >
</br>

- **1) SCREEN 필드 속성 제어 ( `SCREEN-INVISIBLE` , `SCREEN-INPUT` )**
- **2) 그룹(Group1, Group2 등) 속성 활용 → `IF screen-group1 = 'GRP1'.`**
- **3) `LOOP AT screen.` ( `MODIFY SCREEN` 필수 )**
- **4) Dynpro 스크린 제어 ( `SET SCREEN` , `CALL SCREEN` , `LEAVE SCREEN` , `LEAVE TO SCREEN` )**
- **5) 버튼 생성 후 속성 창에서 `FctCode` 필드 입력 ( 펑션코드 )**

</br>

---

</br>

## < ABAP 개념 및 문법 >
</br>

**< Module pool 구조 >**
- 모듈풀 프로그램 하나 → 트랜잭션코드 하나와 연결
  
**1) TOP(Include)**
- 전역 변수(Global Variables) 선언
- 화면(Screen)에서 사용할 변수들도 여기에서 선언함

**2) F01 (Include)**
- 로컬 변수(Local Variables)
- FORM 루틴(Function Routines)들 선언

</br>
</br>
</br>

## < SCREEN 필드 속성 제어 >
- PAI에서 버튼 클릭 이벤트 발생 → PBO에서 SCREEN 테이블을 수정하여 스크린의 속성 변경 가능
  
  - 입력 가능(Input) → 입력 불가(Output only)
  - Visible → Invisible
  - Active → Inactive 등
    
- SCREEN 테이블은 헤더라인 있는 INTERNAL TABLE
  - ABAP 모듈풀에서 스크린 필드 속성을 변경할 때 사용하는 시스템 내부 테이블

- **스크린 속성 변경은 PBO 한 번 지나가면 다시 초기화**
</br>
</br>

**1) SCREEN은 헤더라인을 포함한 구조 => `into`절 생략 가능**

- 일반 인터널 테이블
```abap
LOOP AT screen INTO screen.
```
- screen (헤더라인이므로 into절 생략 가능)
```abap
LOOP AT screen.
  " screen-name
  " screen-input
ENDLOOP.
```
</br>
</br>

**2) SCREEN 속성 변경은 `MODIFY SCREEN` 필수**
- SCREEN 내부 테이블에서 특정 필드를 수정하면 반드시 다음 구문을 넣어야 실제 스크린에 반영됨
- 각 필드의 속성에 접근해서 변경할 수 있음
- SCREEN 속성 값은 `1 = TRUE` , `0 = FALSE`

<img width="548" height="365" alt="image" src="https://github.com/user-attachments/assets/e438b436-a6ad-4dae-96d9-a4aaf6bab111" />
</br>
</br>

```abap
MODULE modify_screen OUTPUT.

  LOOP AT SCREEN. 
    IF screen-group1 = 'SEL'.
      screen-input = 1.
    ENDIF.

    IF screen-name = 'FIELD1'.
      screen-active = 0.          " 여기까지는 헤더 부분만 변경. 
    ENDIF.                        " 스크린 변경하고 싶으면 아래 MODIFY를 해줘야 함.
    MODIFY SCREEN.
  ENDLOOP.

ENDMODULE.
```

</br>
</br>

**3) 그룹(Group1, Group2 등) 속성 활용 → 일괄 제어 가능**
- 스크린 필드별로 그룹 코드 지정 가능
- 특정 그룹 필드 전체를 한 번에 제어할 수 있어 편리함
```abap
LOOP AT SCREEN.
  IF screen-group1 = 'GRP1'.
    screen-input = '0'. " GRP1 그룹 전체 입력 불가 처리
  ENDIF.
  MODIFY SCREEN.
ENDLOOP.
```

</br>
</br>

**4) 구현 위치는 무조건 PBO**
- 스크린 속성 변경은 PBO에서 수행해야 반영됨
- 필드 속성 변경 후 반드시 `MODIFY SCREEN` 사용
```abap
MODIFY SCREEN.
```
</br>
</br>
</br>

## < SCREEN 관련 함수 >

**1) SCREEN-INVISIBLE**
- 화면에서 아예 안 보이게 함
- 필드/라벨/입력칸/화면 공간 사라짐 (빈칸처럼 보임)
```abap
SCREEN-invisible = 1.
```
```abap
IF screen-group2 = 'FLT'.    " GROUP2가 FLT인 필드들은 화면에서 완전 제거
  screen-invisible = 1.
ENDIF.
```
</br>
</br>

**2) SCREEN-INPUT**
- 보이긴 하지만 수정 불가(비활성화)
- 조회 결과는 보여주되 수정은 막고 싶을 때 사용
```abap
SCREEN-input = 0.
```

</br>
</br>

---

</br>

## < Dynpro 스크린 제어 (다음 스크린 설정) >
**< SET SCREEN vs CALL SCREEN >**
- `SET SCREEN` : 다음 화면 예약 → 화면 교체
- `CALL SCREEN` : 지금 화면 호출 → 화면 쌓기(스택)

</br>

### 1) SET SCREEN
- 다음에 실행할 화면을 미리 지정 (화면 전환 X)
- 이전 화면은 스택에서 제거됨
- `LEAVE SCREEN` 과 함께 사용해야 효과 있음
```abap
SET SCREEN 300.
```
- **예시 1 : SET SCREEN + LEAVE SCREEN**
- 현재 화면을 종료하고 300번 화면으로 이동
```abap
SET SCREEN 300.
LEAVE SCREEN.
```
- **예시 2 : SET SCREEN + LEAVE TO SCREEN 0**
- 상황 1 : 상위 Dynpro 흐름의 Next Screen = 200 (Initial Screen이 아님 + 상위 Dynpro 존재)
```abap
SET SCREEN 300.
LEAVE TO SCREEN 0.  " 200으로 이동
```
- 상황 2 : 상위 Dynpro 흐름의 Next Screen = 0 (Initial Screen)
```abap
SET SCREEN 300.
LEAVE TO SCREEN 0.  " 프로그램 종료
```
</br>
</br>

### 2) CALL SCREEN
- `CALL SCREEN` 으로 온 화면에서 `LEAVE SCREEN` 은 자신의 `Next Dynpro`로, `LEAVE TO SCREEN 0` 은 호출 흐름의 `Next Screen` 으로 이동
- 현재 화면 일시 중단 후 화면 실행. (화면 전환 O)
- 현재 화면은 스택에 유지됨 (복귀 가능)
- 호출한 쪽에서 LEAVE SCREEN을 쓰지 않음
```abap
CALL SCREEN 300.
```
- **예시 1 : CALL SCREEN + LEAVE SCREEN**
- Screen 300의 Next Dynpro = 400 이면 400으로 이동
- Screen 300의 Next Dynpro = 0 이면 100으로 이동
```abap
" Screen 100
CALL SCREEN 300.
```
```abap
" Screen 300
LEAVE SCREEN.
```
- **예시 2 : CALL SCREEN + LEAVE TO SCREEN 0**
- `SCREEN 0` → 상위 Dynpro 흐름의 Next Screen
- CALL SCREEN 구문 바로 아래 구문으로 이동 (CALL 코드 아래 코드가 있으면 거기부터 실행)
- 200으로 이동
```abap
" Screen 100 (Next Screen = 200)
CALL SCREEN 300.
```
```abap
" Screen 300
LEAVE TO SCREEN 0.
```
</br>
</br>

### 3) LEAVE SCREEN
- 현재 화면을 종료
- 어디로 갈지는 주변 흐름에 따라 결정
```abap
LEAVE SCREEN.
```
- **예시 1 : CALL SCREEN 안에서**
- Screen 300의 Next Dynpro = 0 => 100으로 이동
- Screen 300의 Next Dynpro = 400 => 400으로 이동
- 100으로 이동
```abap
" Screen 100
CALL SCREEN 300.

" Screen 300
LEAVE SCREEN.
```
- **예시 2 : SET SCREEN과 함께**
- 현재 화면을 닫고 예약된 300번 화면이 실행
```abap
SET SCREEN 300.
LEAVE SCREEN.
```
</br>
</br>

### 4) LEAVE TO SCREEN
- `SET SCREEN 300.` + `LEAVE SCREEN.` 의 축약형
- 현재 화면 종료 후 300번 화면으로 전환
- 이전 화면으로 돌아올 수 없음
```abap
LEAVE TO SCREEN 300.
```
- CALL SCREEN으로 열린 화면 → 호출한 화면 흐름의 Next Screen으로 이동
- 없으면 → 가장 최근 CALL SCREEN 호출자 흐름으로 복귀
```abap
LEAVE TO SCREEN 0.
```
</br>
</br>

### 5) LEAVE PROGRAM
- 프로그램 전체 종료
```abap
LEAVE PROGRAM.
```
</br>
</br>

---

</br>

## < 버튼 이벤트 처리 >
</br>

**1) 버튼 생성 후 속성 창에서 FctCode 필드 입력 (펑션코드)**

<img width="433" height="386" alt="image" src="https://github.com/user-attachments/assets/3771a73a-832f-4fb0-a529-83a9880fa9cf" />
</br>
</br>

**2) 입력필드 6개 묶어서 `GROUP1` 지정**

<img width="468" height="376" alt="image" src="https://github.com/user-attachments/assets/0a41e9b3-9292-4a5f-b2f3-7e185c4486b5" />
</br>
</br>

**3) 스크린 필드에 `OK_CODE` 추가**

<img width="556" height="336" alt="image" src="https://github.com/user-attachments/assets/1c44dc39-2c62-46b9-a57e-aa36e7081a8b" />
</br>
</br>

**4) 스크린 창에서 모듈 `PBO` , `PAI` 생성**

```abap
PROCESS BEFORE OUTPUT.
 MODULE STATUS_0100.
   MODULE MODIFY_SCREEN.
*
PROCESS AFTER INPUT.
 MODULE USER_COMMAND_0100.
```
</br>

**5) `PBO` - 타이틀에 변수 채워서 설정**

- '&1 &2 &3' : 타이틀에 변수를 설정할 수 있음

<img width="537" height="132" alt="image" src="https://github.com/user-attachments/assets/99b90233-b96f-406d-bc97-1c6d6f792f2c" />
</br>
</br>

**6) `PBO` - 표준 버튼을 어떤 `OKCODE` 로 동작시킬지 설정**

- 이름 지정 시 그 이름으로 `OKCODE` 로 받아서 처리 가능
```abap
SET TITLEBAR '타이틀바_이름' WITH <값1> <값2> <값3> ...
```

<img width="591" height="336" alt="image" src="https://github.com/user-attachments/assets/d8a80673-5514-47e1-a54f-bd9d9ed112eb" />

</br>
</br>

**7) `TOP` 모듈 구현**

```abap
PROGRAM sapmzb03002.

TABLES: sdyn_conn.

DATA: ok_code TYPE sy-ucomm,
      gv_mod  TYPE i. " 변경모드 값을 받을 변수
```
</br>

**8) `PAI` 모듈 구현**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZB03002
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.
  CASE OK_CODE.
    WHEN 'CHBTN'.
      IF gv_mod = 1.
        gv_mod = 0.
      ELSE.
        gv_mod = 1.
      ENDIF.
    WHEN 'BACK' OR 'EXIT' OR 'CANCEL'.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```
</br>

**9) `PBO` 모듈 구현**
- 시스템변수 : `SY-DATUM` = 오늘 날짜, `SY-UZEIT` = 현재 시간, `SY-UNAME` = 로그인 사용자 ID
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZB03002
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.
 SET PF-STATUS 'S100'.
 SET TITLEBAR 'T100' WITH sy-datum sy-uzeit sy-uname.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE modify_screen OUTPUT.
  " 헤더가 있는 itab인 SCREEN을 한 건씩 돌면서 동적 처리
  LOOP AT SCREEN.   " INTO SCREEN이 생략
    " SCREEN의 Element 중, group1 값이 'MOD'인 경우
    IF SCREEN-GROUP1 = 'MOD'.
      " Input 속성에 gv_mod 변수 값을 적용함
      SCREEN-INPUT = gv_mod. " 0 또는 1
    ENDIF.

    " Header-Line에 있는 itab 이라서, 작업한 Header를
    " Itab(Body)에 적용시켜야 함
    MODIFY SCREEN. "변경사항 반영
  ENDLOOP.
ENDMODULE.
```
</br>

**9) TCODE 설정**

<img width="571" height="394" alt="image" src="https://github.com/user-attachments/assets/89ecff27-c6a2-4114-8dff-df2a534187ee" />

</br>
</br>

**10) 결과 확인**
- 버튼 클릭시 필드 입력 여부가 바뀜 ( `screen-input` 변경 )
<img width="465" height="316" alt="image" src="https://github.com/user-attachments/assets/32e64b3d-0c48-4144-8e58-5e6b3a007644" />

</br>
</br>
</br>
</br>

---

</br>


## < 실습 코드 >

### 실습 1
</br>

- 문제
<img width="413" height="145" alt="image" src="https://github.com/user-attachments/assets/9381f16c-f73c-4c18-9077-490ef574ed21" />
</br>
</br>

**1) 버튼 생성 후 속성 창에서 FctCode 필드 입력 (펑션코드)**

<img width="566" height="319" alt="image" src="https://github.com/user-attachments/assets/313b5f4b-436d-4f83-8e49-9d3fecd0b853" />
</br>
</br>

**2) 스크린 필드에 `OK_CODE` 추가**

<img width="574" height="344" alt="image" src="https://github.com/user-attachments/assets/b3590a1c-497c-4ea7-882b-dbd3ee47e63a" />
</br>
</br>

**3) 스크린 창에서 모듈 `PBO` , `PAI` 생성**
```abap
PROCESS BEFORE OUTPUT.
 MODULE STATUS_0100.
*
PROCESS AFTER INPUT.
  MODULE CHECK_SFLIGHT.
  MODULE USER_COMMAND_0100.
```
</br>

**4) `TOP` 모듈 구현**
```abap
PROGRAM SAPMZBC410_SOLUTION_03.

TABLES: SDYN_CONN.

DATA: exit_button TYPE C,
      OK_CODE TYPE SY-UCOMM,
      gs_data TYPE SDYN_CONN,
      gv_subrc TYPE sy-subrc,
      gs_data2 LIKE SDYN_CONN,
      gv_button TYPE I.
```
</br>

**5) `PAI` 모듈 구현**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZBC410_SOLUTION_03
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.

  IF exit_button = 'X'.
    LEAVE TO SCREEN 0.
  ENDIF.

ENDMODULE.

*&---------------------------------------------------------------------*

MODULE check_sflight INPUT.

  IF OK_CODE = 'FCBTN'.
    gv_button = 1.

    SELECT SINGLE * FROM sflight
      INTO CORRESPONDING FIELDS OF gs_data
      WHERE carrid = SDYN_CONN-carrid
        AND connid = SDYN_CONN-connid
        AND fldate = SDYN_CONN-fldate.

    IF sy-subrc <> 0.
      gv_subrc = 4.
      message text-007 TYPE 'I'.
    ENDIF.
  ENDIF.

ENDMODULE.
```
</br>

**6) `PBO` 모듈 구현**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZBC410_SOLUTION_03
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.

  IF gv_button = 1.
    IF gv_subrc <> 0.
      CLEAR SDYN_CONN.
      gv_subrc = 0.
    ELSE.
      MOVE-CORRESPONDING gs_data TO SDYN_CONN.
    ENDIF.
  ELSE.
    gv_button = 0.
  ENDIF.

ENDMODULE.
```
</br>

**7) 결과 확인**
- `PUSH` 버튼 클릭 시
<img width="479" height="321" alt="image" src="https://github.com/user-attachments/assets/0f50c4f5-2a6d-4335-827e-cf6d8c4b1b2b" />
</br>
</br>

- 버튼 클릭 시 결과 생성
<img width="481" height="344" alt="image" src="https://github.com/user-attachments/assets/6a103613-7bfb-4107-960a-b531b605849e" />

</br>
</br>
</br>
</br>
</br>

### 실습 2 (과제)
</br>

- 문제

<img width="663" height="666" alt="image" src="https://github.com/user-attachments/assets/59f1e4d6-f2ab-4182-b626-f0e7326db716" />
</br>
</br>

<img width="503" height="473" alt="image" src="https://github.com/user-attachments/assets/2da81cca-14f1-4bca-88e5-945136ae6632" />
</br>
</br>

<img width="660" height="370" alt="image" src="https://github.com/user-attachments/assets/42457db3-b08c-4ab1-a211-d45201d1ff1b" />
</br>
</br>
</br>
</br>
</br>

**1) 버튼 생성 후 속성 창에서 FctCode 필드 입력 (펑션코드)**

- `SCARR` 는 `FCBTN01` , `SFLIGHT` 는 `FCBTN02` , `검색` 은 `FCBTN03`
<img width="603" height="452" alt="image" src="https://github.com/user-attachments/assets/53b2a934-37fb-41ef-a478-72526c2abf72" />

</br>
</br>

**2) 스크린 필드에 `OK_CODE` 추가**

<img width="626" height="464" alt="image" src="https://github.com/user-attachments/assets/13d15983-080c-45b3-9d9e-6b63731e2d93" />
</br>
</br>


**3) 스크린 창에서 모듈 `PBO` , `PAI` 생성**
```abap
PROCESS BEFORE OUTPUT.
 MODULE STATUS_0100.
*
PROCESS AFTER INPUT.
 MODULE USER_COMMAND_0100.
```
</br>

**4) `TOP` 모듈 구현**
```abap
PROGRAM SAPMZPRACTICE02B03.

TABLES: ZSCARRFLIGHT_B03.

DATA: OK_CODE TYPE sy-ucomm,
      gv_button1 TYPE I,
      gv_button2 TYPE I,    " VISIBLE 제어를 위한 플래그 (ex: scarr만 눌렀을 때)
      gv_result_btn1 TYPE I,
      gv_result_btn2 TYPE I,
      gv_result_btn3 TYPE I,   " 결과를 표시하기 위한 플래그 (ex: scarr -> 검색까지)
      gs_data TYPE ZSCARRFLIGHT_B03.
```
</br>

**4) `PAI` 모듈 구현**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZPRACTICE02B03
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.

  CASE OK_CODE.
    WHEN 'FCBTN01'.   " SCARR 눌렀을 때
      CLEAR: ZSCARRFLIGHT_B03-CARRNAME,
             ZSCARRFLIGHT_B03-CURRCODE,
             ZSCARRFLIGHT_B03-PRICE,
             ZSCARRFLIGHT_B03-CURRENCY,
             ZSCARRFLIGHT_B03-PLANETYPE,
             ZSCARRFLIGHT_B03-SEATSMAX,
             ZSCARRFLIGHT_B03-SEATSOCC.
      gv_button1 = 1.
    WHEN 'FCBTN02'.   " SFLIGHT 눌렀을 때
      CLEAR: ZSCARRFLIGHT_B03-CARRNAME,
             ZSCARRFLIGHT_B03-CURRCODE,
             ZSCARRFLIGHT_B03-PRICE,
             ZSCARRFLIGHT_B03-CURRENCY,
             ZSCARRFLIGHT_B03-PLANETYPE,
             ZSCARRFLIGHT_B03-SEATSMAX,
             ZSCARRFLIGHT_B03-SEATSOCC.
      gv_button2 = 1.
    WHEN 'FCBTN03'.   " 검색 눌렀을 때
*      CLEAR: gs_data.
      IF gv_button1 = 1.
        SELECT SINGLE CARRNAME CURRCODE FROM scarr
          INTO CORRESPONDING FIELDS OF gs_data
           WHERE carrid = ZSCARRFLIGHT_B03-CARRID.
        gv_result_btn1 = 1.
      ELSEIF gv_button2 = 1.
        SELECT SINGLE PRICE CURRENCY PLANETYPE SEATSMAX SEATSOCC FROM sflight
          INTO CORRESPONDING FIELDS OF gs_data
          WHERE carrid = ZSCARRFLIGHT_B03-CARRID
            AND connid = ZSCARRFLIGHT_B03-CONNID
            AND fldate = ZSCARRFLIGHT_B03-FLDATE.
        gv_result_btn2 = 1.
      ELSE.
        SELECT SINGLE A~CARRNAME A~CURRCODE B~PRICE B~CURRENCY B~PLANETYPE B~SEATSMAX B~SEATSOCC
          INTO CORRESPONDING FIELDS OF gs_data
          FROM scarr AS A INNER JOIN sflight AS B
            ON A~CARRID = B~CARRID
          WHERE A~carrid = ZSCARRFLIGHT_B03-CARRID
            AND B~connid = ZSCARRFLIGHT_B03-CONNID
            AND B~fldate = ZSCARRFLIGHT_B03-FLDATE.
        gv_result_btn3 = 1.
      ENDIF.

      gs_data-carrid = ZSCARRFLIGHT_B03-CARRID.
      gs_data-connid = ZSCARRFLIGHT_B03-CONNID.
      gs_data-fldate = ZSCARRFLIGHT_B03-FLDATE.
    WHEN OTHERS.
  ENDCASE.

  CLEAR: OK_CODE.
ENDMODULE.
```
</br>

**5) `PBO` 모듈 구현**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZPRACTICE02B03
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.
  IF gv_button1 = 1.
    LOOP AT SCREEN.
      IF SCREEN-GROUP2 = 'FLT'.
        SCREEN-invisible = 1.
        SCREEN-input = 0.
      ENDIF.
      MODIFY SCREEN.
    ENDLOOP.
  ELSEIF gv_button2 = 1.
    LOOP AT SCREEN.
      IF SCREEN-GROUP1 = 'CAR'.
        SCREEN-invisible = 1.
        SCREEN-input = 0.
      ENDIF.
      MODIFY SCREEN.
    ENDLOOP.
  ENDIF.

  IF gv_result_btn1 = 1.    " SCARR -> 검색 눌렀을 때
    LOOP AT SCREEN.
      IF SCREEN-GROUP2 = 'FLT'.
        SCREEN-invisible = 1.
        SCREEN-input = 0.
      ENDIF.
      MODIFY SCREEN.
    ENDLOOP.

    MOVE-CORRESPONDING gs_data TO ZSCARRFLIGHT_B03.
    gv_button1 = 0.
    gv_result_btn1 = 0.

  ELSEIF gv_result_btn2 = 1.    " SFLIGHT -> 검색 눌렀을 때
    LOOP AT SCREEN.
      IF SCREEN-GROUP1 = 'CAR'.
        SCREEN-invisible = 1.
        SCREEN-input = 0.
      ENDIF.
      MODIFY SCREEN.
    ENDLOOP.

    MOVE-CORRESPONDING gs_data TO ZSCARRFLIGHT_B03.
    gv_button2 = 0.
    gv_result_btn2 = 0.

  ELSEIF gv_result_btn3 = 1.    " 검색 눌렀을 때
    MOVE-CORRESPONDING gs_data TO ZSCARRFLIGHT_B03.
    gv_result_btn3 = 0.
  ENDIF.
ENDMODULE.
```
</br>

**6) 결과 확인**
- `검색` 누르면 전체 출력 ( Inner Join 사용 )
  
<img width="467" height="494" alt="image" src="https://github.com/user-attachments/assets/36b2b3a5-6453-437a-8a8b-06a54a9f846a" />
</br>
</br>

- `SCARR` 누르면 해당 데이터 출력

<img width="473" height="432" alt="image" src="https://github.com/user-attachments/assets/6687403b-b8dc-453f-98b5-6f41d04c1c01" />
</br>
</br>

- `SFLIGHT` 누르면 해당 데이터 출력
  
<img width="476" height="480" alt="image" src="https://github.com/user-attachments/assets/71fcff73-4f33-4d7f-bb87-9ec2993efbbf" />

</br>
</br>
</br>
</br>
</br>

### 실습 3 ( call screen / leave to screen 0 활용 )
</br>

**1) 스크린 추가**
- 100의 next dynpro는 200, 200은 300, 300은 400, 400은 400으로 설정

<img width="220" height="303" alt="image" src="https://github.com/user-attachments/assets/a737c19d-04a6-4f0b-a27c-1cb882bd5551" />

</br>
</br>

**2) 모듈 `PAI` 생성**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZB03003
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.

  CASE OK_CODE.
    WHEN 'MOVE'.
     " Next 스크린 200번으로 설정되어 있지만,
     " Next 스크린 300번으로 세팅값 변경(복귀X)
*      SET SCREEN 300.
*      LEAVE SCREEN.
*      => LEAVE TO SCREEN 300. 과 동일함

      " 현재 시점에서 300번 스크린 호출(추후 복귀)
      CALL SCREEN 300.

    WHEN 'BACK' OR 'EXIT' OR 'CANCEL'.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.

ENDMODULE.

*&---------------------------------------------------------------------*

MODULE user_command_0200 INPUT.
  CASE OK_CODE.
    WHEN 'BACK' OR 'EXIT' OR 'CANCEL'.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE user_command_0300 INPUT.
  CASE OK_CODE.
    WHEN 'BACK' OR 'EXIT' OR 'CANCEL'.
       LEAVE SCREEN.
*      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE user_command_0400 INPUT.
  CASE OK_CODE.
    WHEN 'BACK' OR 'EXIT' OR 'CANCEL'.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```
</br>

**3) 모듈 `PBO` 생성**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZB03003
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.
 SET PF-STATUS 'S100'.
 SET TITLEBAR 'T100'.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE status_0200 OUTPUT.
 SET PF-STATUS 'S200'.
* SET TITLEBAR 'xxx'.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE status_0300 OUTPUT.
 SET PF-STATUS 'S300'.
* SET TITLEBAR 'xxx'.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE status_0400 OUTPUT.
 SET PF-STATUS 'S400'.
* SET TITLEBAR 'xxx'.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE clear_ok_code OUTPUT.
  CLEAR OK_CODE.
ENDMODULE.
```
</br>

**4) 결과 확인**
- `100` 에서 버튼 클릭시 `300` 으로 이동
- `300` 에서 뒤로가기 하면 `LEAVE SCREEN` 때문에 Next Dynpro인 `400` 으로 이동
- `400` 에서 뒤로가기 하면 `LEAVE TO SCREEN 0` 때문에 가장 최근 CALL SCREEN 호출자인 100의 Next Dynpro인 `200` 으로 이동
- `200` 에서 뒤로가기 하면 프로그램 종료

<img width="302" height="200" alt="image" src="https://github.com/user-attachments/assets/5b0e964b-c059-4b86-b019-e6cdff26a385" />

</br>
</br>

<img width="263" height="183" alt="image" src="https://github.com/user-attachments/assets/5abd8f7b-a392-44ed-80f6-21b3fff51576" />

</br>
</br>

<img width="272" height="187" alt="image" src="https://github.com/user-attachments/assets/5eb2f35e-26b2-49e7-a6eb-c71e2e3d26c2" />

</br>
</br>

<img width="267" height="208" alt="image" src="https://github.com/user-attachments/assets/00e2cf72-f6e6-4fe2-a165-a1e15a26a3df" />


</br>
</br>

# 12/15

</br>
</br>

## <  핵심 개념 >
</br>

- **1) `SET CURSOR FIELD` - 특정 화면 필드에 포커스를 이동시킴**
- **2) Function Key / Function type 설정하기 ( PF-STATUS - PBO에서 설정 )**
- **3) Titlebar ( all title )**
- **4) `STARTING AT / ENDING AT` - dialog 크기 지정하는 함수 ( CALL SCREEN 과 함께 사용 )**

</br>

---

</br>

## < ABAP 개념 >
</br>

### < ABAP Dynpro CALL SCREEN과 Screen Stack 흐름 >
- **`LEAVE TO SCREEN 0`** 같은 화면 전환 명령은 **`PAI`** 에서만
- **`SCREEN-INPUT`** 같은 화면 속성 변경은 **`PBO`** 에서만
- 사용자 입력 기반 SELECT는 **`PAI`** , 조회 결과 화면 반영/속성 변경은 **`PBO`**
- **OK_CODE 초기화** 코드 꼭 넣어줘야 함 ( 보통 **`PBO`** 에서)
- **`OK_CODE`** 케이스문은 **`PAI`** 에서
```abap
MODULE clear_ok_code OUTPUT.
  CLEAR: OK_CODE.
ENDMODULE.
```

<img width="584" height="323" alt="image" src="https://github.com/user-attachments/assets/2fc3f75c-acfe-4c79-82c7-fd88c67b058c" />
</br>
</br>

---

</br>

## < 스크린 인터페이스(UI) 구성 기능 >
</br>

### 1) SET CURSOR FIELD 
- 보통 **`PBO`** 에서 실행.
- 특정 화면 필드에 포커스를 이동시킴
- `<field_name>` : 화면(Screen)에 존재하는 필드 이름
```abap
SET CURSOR FIELD <field_name>.
```
```abap
SET CURSOR FIELD 'SDYN_CONN-CONNID'.
```
</br>

<img width="462" height="304" alt="image" src="https://github.com/user-attachments/assets/75fa9c97-ee46-4f0a-845d-5fd0105b82fa" />
</br>
</br>

<img width="423" height="303" alt="image" src="https://github.com/user-attachments/assets/ea8a1738-c120-4564-a8df-d43f12b70b24" />
</br>
</br>
</br>
</br>

### 2) Function Key / Function type ( PF-STATUS - PBO에서 설정 )
**2-1) Function Type**
- 종류: `NORMAL / EXIT / TABSTRIP CTRL`
  - 기본값: NORMAL
- Function Type을 비워두면 `NORMAL` 로 처리됨
</br>

- `PF-STATUS` 에서 더블클릭시 function key 및 function code 지정 가능
  
<img width="581" height="216" alt="image" src="https://github.com/user-attachments/assets/9f6448b4-e07b-4a84-bbc1-b4de4aa160c8" />
</br>
</br>

- `function type` 에 따라 저기에 들어가는 내용이 달라짐
  
<img width="656" height="123" alt="image" src="https://github.com/user-attachments/assets/9c6e14cc-89de-4fd6-84fd-09bcd9beb981" />

</br>
</br>

- `PF-STATUS` 를 통한 펑션코드와 속성 설정 예시
  
<img width="577" height="387" alt="image" src="https://github.com/user-attachments/assets/8c638b9d-3e57-4e2d-a325-b5c2e15e1f18" />
</br>
</br>
</br>
</br>

### 3) Titlebar ( TITLEBAR - PBO에서 설정 )
- `All Title` 선택 시 모든 스크린에 동일 적용

<img width="605" height="148" alt="image" src="https://github.com/user-attachments/assets/ab7604b0-4567-4dc4-980a-e714ae96d91f" />
</br>
</br>
</br>
</br>


### 4) STARTING AT / ENDING AT
- dialog 크기 지정하는 함수
- `CALL SCREEN` 과 함께 사용됨
- `STARTING AT col row` : 화면의 왼쪽 위 시작 위치
- `ENDING AT col row` : 화면의 오른쪽 아래 끝 위치
- `col` = 열(X축), `row` = 행(Y축)
```abap
STARTING AT <column1> <row1>
ENDING   AT <column2> <row2>
```
- (5,5) 위치에서 시작
- (40,12)까지의 크기를 가진 팝업 화면 표시
```abap
CALL SCREEN 100
  STARTING AT 5 5
  ENDING AT 40 12.
```
</br>
</br>
</br>

---

</br>

## < PF-STATUS 및 Dialog 스크린 예제 >
**1) 각 스크린 코드에서 모듈 생성**
- CLEAR_OK_CODE. 모듈을 전부 선언해주어 OK_CODE를 클리어 시킴.
</br>

- 100 스크린
```abap
PROCESS BEFORE OUTPUT.
 MODULE STATUS_0100.
 MODULE CLEAR_OK_CODE.
*
PROCESS AFTER INPUT.
 MODULE USER_COMMAND_0100.
```
- 110 스크린
```abap
PROCESS BEFORE OUTPUT.
 MODULE STATUS_0110.
 MODULE CLEAR_OK_CODE.
*
PROCESS AFTER INPUT.
 MODULE USER_COMMAND_0110.
```
- 200 스크린
```abap
PROCESS BEFORE OUTPUT.
 MODULE STATUS_0200.
 MODULE CLEAR_OK_CODE.
*
PROCESS AFTER INPUT.
 MODULE USER_COMMAND_0100.
```
</br>
</br>
</br>

**2) `100 Screen` PF-STATUS, TITLEBAR 생성**
- `Menu Bar` 설정
- **최대 3레벨, 최대 15개까지 가능**

<img width="630" height="331" alt="image" src="https://github.com/user-attachments/assets/8bfe8db3-3162-4493-8349-baa50eb07cdc" />
</br>
</br>

<img width="490" height="207" alt="image" src="https://github.com/user-attachments/assets/8df34555-8d7b-44b8-92ae-acf189e84b3d" />
</br>
</br>

- `Application Toolbar` 설정
<img width="688" height="283" alt="image" src="https://github.com/user-attachments/assets/6256a641-bea8-412f-8963-af18ed670eae" />
</br>
</br>

<img width="702" height="239" alt="image" src="https://github.com/user-attachments/assets/e2f6a8e3-2bcf-4d7a-83d1-e09d127d845f" />
</br>
</br>

<img width="616" height="286" alt="image" src="https://github.com/user-attachments/assets/2273da92-2d35-4198-8c4e-5bcb08e15c6d" />
</br>
</br>

<img width="341" height="169" alt="image" src="https://github.com/user-attachments/assets/eafc8069-42b9-41ea-9101-9f3b4ae584b8" />
</br>
</br>

- `Function Keys` 설정

<img width="648" height="312" alt="image" src="https://github.com/user-attachments/assets/0e476e6d-c8a1-492f-b5dc-b0c90c7621cc" />
</br>
</br>

- `TITLEBAR` 생성
- `&1` 이용해 변수 넣기
  
<img width="583" height="140" alt="image" src="https://github.com/user-attachments/assets/c1f8d966-6167-410d-bf12-f8bb4ec705be" />
</br>
</br>

<img width="386" height="177" alt="image" src="https://github.com/user-attachments/assets/9a38a8ad-5c66-4096-8263-4f49c3ab4c0b" />

</br>
</br>
</br>
</br>

**3) `110 Screen` PF-STATUS 생성 (Dialog)**
- 생성할 때 `Normal` 대신 `Dialog Box` 선택
<img width="514" height="327" alt="image" src="https://github.com/user-attachments/assets/a07132ec-45b0-4431-8018-3930f08a6824" />
</br>
</br>

- `Application Toolbar` 설정
  
<img width="692" height="335" alt="image" src="https://github.com/user-attachments/assets/dddd6815-ae4b-478f-ab33-00747919ed0d" />
</br>
</br>

- `Layout` 설정
<img width="543" height="349" alt="image" src="https://github.com/user-attachments/assets/9ed62e47-491d-45f0-b27b-ce749cc0e054" />
</br>
</br>
</br>
</br>

**4) 각 스크린 `Layout` 설정**
- 110 스크린

<img width="467" height="300" alt="image" src="https://github.com/user-attachments/assets/7fe97864-cebd-44f4-a018-bd8a78d04ea7" />
</br>
</br>

- 200 스크린
  
<img width="452" height="306" alt="image" src="https://github.com/user-attachments/assets/0ba8d3cf-36cb-4b40-b5ab-10c48a7bcaff" />
</br>
</br>
</br>
</br>

**5) `PBO` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZB03004
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.
 SET PF-STATUS 'S100'.
 SET TITLEBAR 'T100' WITH sy-dynnr.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE status_0200 OUTPUT.
 SET PF-STATUS 'S200'.
 SET TITLEBAR 'T100' WITH sy-dynnr.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE status_0110 OUTPUT.
 SET PF-STATUS 'S110'.
 SET TITLEBAR 'T100' WITH sy-dynnr.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE clear_ok_code OUTPUT.
  CLEAR: OK_CODE.
ENDMODULE.
```
</br>
</br>
</br>

**6) `PAI` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZB03004
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.
  CASE OK_CODE.
    WHEN 'BACK'.
      LEAVE TO SCREEN 0.
    WHEN 'EXIT' OR 'CANCEL'.
      LEAVE PROGRAM.
    WHEN 'MOVE'.
      SET SCREEN 200.
      LEAVE SCREEN.
      " LEAVE TO SCREEN 200. 과 동일
    WHEN 'REMARK'.
*      MESSAGE 'Remark 메뉴 선택' TYPE 'I'.
      CALL SCREEN 110
      STARTING AT 5 5
      ENDING AT 50 10.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE user_command_0110 INPUT.
  CASE OK_CODE.
    WHEN 'OK'.
      MESSAGE 'OK 클릭' TYPE 'I'.
    WHEN 'CLOSE'.
      MESSAGE 'CLOSE 클릭' TYPE 'I'.
    WHEN 'DISP'.
      MESSAGE 'DISP 클릭' TYPE 'I'.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```
</br>
</br>
</br>
</br>

**7) 결과 확인**

- 첫 화면 (스크린 100)
  
<img width="436" height="184" alt="image" src="https://github.com/user-attachments/assets/450cb3a4-c027-487f-b5f5-8ac0a202afcb" />
</br>
</br>

- 첫 화면에서 `MOVE` 버튼 클릭 시 (스크린 200)
<img width="319" height="225" alt="image" src="https://github.com/user-attachments/assets/39e30e96-2e00-4ec3-8f0a-fadfe01b1e68" />
</br>
</br>

- 스크린 100에서 비고 클릭 시
  
<img width="463" height="195" alt="image" src="https://github.com/user-attachments/assets/a81b7ded-e7b7-44d1-87fd-37e1a5967b33" />

</br>
</br>

- 스크린 110 (Dialog)
<img width="444" height="382" alt="image" src="https://github.com/user-attachments/assets/cb604364-9370-49a6-96ff-423db4dd8fd3" />

</br>
</br>
</br>

---

</br>

## < 실습 코드 >

### 실습 1
- 문제 ( ABAP Dynpro CALL SCREEN과 Screen Stack 흐름 )

<img width="436" height="226" alt="image" src="https://github.com/user-attachments/assets/9ce0443e-acaf-408a-a37a-e43a75d932fa" />
</br>
</br>

**1) 각 스크린의 `Layout` 설정**
- `Screen 100`
<img width="303" height="183" alt="image" src="https://github.com/user-attachments/assets/3143132f-d12f-40c8-8247-f67a222bd64e" />
</br>
</br>

- `Screen 200`
<img width="321" height="281" alt="image" src="https://github.com/user-attachments/assets/439391c4-5f02-4fbd-9386-15c2c4e57460" />
</br>
</br>
</br>

**2) `TOP` 모듈 생성**
```abap
PROGRAM SAPMZPRACTICE03B03.

TABLES: ZSCARRFLIGHT_B03.

DATA: OK_CODE TYPE sy-ucomm,
      gv_carrid TYPE ZSCARRFLIGHT_B03-CARRID,
      gv_connid TYPE ZSCARRFLIGHT_B03-CONNID,
      gv_fldate TYPE ZSCARRFLIGHT_B03-FLDATE,
      gs_data TYPE ZSCARRFLIGHT_B03.
```
</br>

**3) `F01` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZPRACTICE03B03
*&---------------------------------------------------------------------*

FORM get_data USING pa_carrid pa_connid pa_fldate
              CHANGING gt_data.

  SELECT SINGLE A~CARRID, A~CARRNAME, A~CURRCODE, B~CONNID, B~FLDATE, B~PRICE, B~CURRENCY, B~PLANETYPE, B~SEATSMAX, B~SEATSOCC
    INTO @gs_data
    FROM scarr AS A INNER JOIN sflight AS B
      ON A~carrid = B~carrid
    WHERE B~carrid = @pa_carrid
      AND B~connid = @pa_connid
      AND B~fldate = @pa_fldate.
  MOVE-CORRESPONDING gs_data TO ZSCARRFLIGHT_B03.

ENDFORM.
```
</br>


**4) `PBO` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZPRACTICE03B03
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.
* SET PF-STATUS 'xxxxxxxx'.
* SET TITLEBAR 'xxx'.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE status_0200 OUTPUT.
  PERFORM get_data USING gv_carrid gv_connid gv_fldate
                   CHANGING gs_data.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE clear_ok_code OUTPUT.
  CLEAR: OK_CODE.
ENDMODULE.
```
</br>

**5) `PAI` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZPRACTICE03B03
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.
  gv_carrid = ZSCARRFLIGHT_B03-CARRID.
  gv_connid = ZSCARRFLIGHT_B03-CONNID.
  gv_fldate = ZSCARRFLIGHT_B03-FLDATE.

  CALL SCREEN 200.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE user_command_0200 INPUT.
  IF OK_CODE = 'MOVE'.
    LEAVE TO SCREEN 0.
  ENDIF.
ENDMODULE.
```
</br>

**6) 결과 확인**
- 입력 후 엔터
<img width="324" height="239" alt="image" src="https://github.com/user-attachments/assets/ec51fa6f-cab5-4a2a-91cd-9e817fb0072d" />

</br>
</br>

- 입력한 값에 따라 출력
<img width="373" height="351" alt="image" src="https://github.com/user-attachments/assets/2fabeebc-ec21-4cef-8bb2-33381df28731" />

</br>
</br>
</br>
</br>
</br>

### 실습 2
- 문제 ( 버튼과 Application Toolbar 사용 )
- 전에 했던 실습해서 추가구현

<img width="489" height="253" alt="image" src="https://github.com/user-attachments/assets/53959b85-e2fc-4d5b-b28b-b7d46701d9fd" />
</br>
</br>

**1) 각 스크린 코드에서 모듈 생성**
- `Screen 100`
```abap
PROCESS BEFORE OUTPUT.
 MODULE STATUS_0100.
 MODULE CLEAR_OK_CODE.
*
PROCESS AFTER INPUT.
  MODULE CHECK_SFLIGHT.
  MODULE USER_COMMAND_0100.
```
- `Screen 150`
```abap
PROCESS BEFORE OUTPUT.
 MODULE STATUS_0150.
 MODULE CLEAR_OK_CODE.
*
PROCESS AFTER INPUT.
 MODULE USER_COMMAND_0150.
```
</br>
</br>

**2) `100 Screen` PF-STATUS 생성**

<img width="536" height="225" alt="image" src="https://github.com/user-attachments/assets/00345637-c4ad-41cf-8718-80b9567ee07c" />

</br>
</br>

**3) 각 스크린 `Layout` 설정**
- `Screen 100`
  
<img width="540" height="409" alt="image" src="https://github.com/user-attachments/assets/9414ea76-85b5-4a67-9b88-f2355060bf3f" />
</br>
</br>

- `Screen 150`
  
<img width="366" height="274" alt="image" src="https://github.com/user-attachments/assets/98b72890-c515-45ea-9659-725361985447" />
</br>
</br>

**4) `PBO` 모듈 수정**
- `OK_CODE` 초기화 코드 추가됨
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZBC410_SOLUTION_03_01
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.

  SET PF-STATUS 'S100'.
  IF gv_button = 1.
    IF gv_subrc <> 0.
      CLEAR SDYN_CONN.
      gv_subrc = 0.
    ELSE.
      MOVE-CORRESPONDING gs_data TO SDYN_CONN.
    ENDIF.
  ELSE.
    gv_button = 0.
  ENDIF.

ENDMODULE.

*&---------------------------------------------------------------------*

MODULE status_0150 OUTPUT.
 SET PF-STATUS 'S150'.
 SET TITLEBAR 'xxx'.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE clear_ok_code OUTPUT.
  CLEAR: OK_CODE.
ENDMODULE.
```
</br>
</br>

**5) `PAI` 모듈 수정**
- exit_button = 'T'` 일 때의 if문 추가
- `exit_button` 초기화 코드 추가
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZBC410_SOLUTION_03_01
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.

  IF exit_button = 'X'.
    LEAVE TO SCREEN 0.
  ELSEIF exit_button = 'T'.
    CALL SCREEN 150
    STARTING AT 5 5
    ENDING AT 50 10.
    CLEAR: exit_button.
  ENDIF.

ENDMODULE.

*&---------------------------------------------------------------------*

MODULE check_sflight INPUT.

  IF OK_CODE = 'PUSH'.
    gv_button = 1.

    SELECT SINGLE * FROM sflight
      INTO CORRESPONDING FIELDS OF gs_data
      WHERE carrid = SDYN_CONN-carrid
        AND connid = SDYN_CONN-connid
        AND fldate = SDYN_CONN-fldate.

    IF sy-subrc <> 0.
      gv_subrc = 4.
      message text-007 TYPE 'I'.
    ENDIF.
  ENDIF.

ENDMODULE.

*&---------------------------------------------------------------------*

MODULE user_command_0150 INPUT.
  IF OK_CODE = 'BTN01'.
    LEAVE TO SCREEN 0.
  ENDIF.
ENDMODULE.
```
</br>
</br>

**6) 결과확인**
- 필수 값 입력 후 `T` 입력 후 엔터
<img width="531" height="375" alt="image" src="https://github.com/user-attachments/assets/ae634ba6-75e7-4a91-bd2a-c6e9cdb1094b" />
</br>
</br>

- 다이얼로그 창 띄워짐 ( 시간이 띄워짐 )
<img width="534" height="376" alt="image" src="https://github.com/user-attachments/assets/50a3e05b-2c85-4084-a8ca-3fd02f4e4602" />

</br>
</br>

# 12/16

</br>
</br>

## <  핵심 개념 >
</br>

- **1) MESSAGE TYPE 종류**
- **2) Icon Field 사용 ( `ICON_CREATE` 함수 불러오기 )**
- **3) `Listbox` (드롭다운) = 여러 값 중 하나를 선택**
- **4)  라디오버튼 및 체크박스 ( Radio button / Check box )**
- **5) 버튼에 아이콘을 같이 띄우기** 

</br>

---

</br>


## < MESSAGE TYPE 종류 >
</br>

### 1) TYPE 'A' (Abort)
- 치명적인 오류 발생 시 사용
- 메시지 출력 후 프로그램이 즉시 종료됨
```abap
MESSAGE '치명적 오류 발생' TYPE 'A'.
```
<img width="484" height="148" alt="image" src="https://github.com/user-attachments/assets/b10f81ee-593c-4b2d-97b3-1dfaf2544b8a" />
</br>
</br>
</br>

### 2) TYPE 'X' (Exit)
- 시스템 오류 메시지
- 출력과 동시에 Short Dump 발생
```abap
MESSAGE '시스템 오류 발생' TYPE 'X'.
```
<img width="409" height="330" alt="image" src="https://github.com/user-attachments/assets/7972ecc4-fa92-4c5d-bb7d-8e37987477b2" />

</br>
</br>
</br>

### 3) TYPE 'E' (Error)
- 오류 메시지 출력
- 현재 화면에 머물며 다음 단계로 진행 불가
```abap
MESSAGE '입력값 오류입니다' TYPE 'E'.
```
<img width="233" height="50" alt="image" src="https://github.com/user-attachments/assets/ddf4ff77-2521-44eb-995c-b787a54e435b" />
</br>
</br>
</br>

### 4) TYPE 'W' (Warning)
- 경고 메시지 출력
- Enter를 누르면 처리가 계속 진행됨
```abap
MESSAGE '주의가 필요합니다' TYPE 'W'.
```
<img width="220" height="44" alt="image" src="https://github.com/user-attachments/assets/94150f34-68d1-4055-918c-0b837232cb3a" />

</br>
</br>
</br>

### 5) TYPE 'I' (Information)
- 정보 메시지 출력
- 팝업 창으로 표시됨
```abap
MESSAGE '안내 메시지입니다' TYPE 'I'.
```
<img width="483" height="143" alt="image" src="https://github.com/user-attachments/assets/697e2d8e-593d-403f-a18a-056583a3ae1e" />
</br>
</br>
</br>

### 6) TYPE 'S' (Success)
- 성공 메시지 출력
- 화면 하단 상태바에 표시됨
```abap
MESSAGE '정상 처리되었습니다' TYPE 'S'.
```
<img width="206" height="44" alt="image" src="https://github.com/user-attachments/assets/cadb4bb8-7bbf-439e-8606-66c6b27b3d58" />
</br>
</br>
</br>

### 7) DISPLAY LIKE 사용
- 메시지의 실제 동작(TYPE)은 그대로 유지하면서 화면에 보이는 표시 형태만 변경하는 옵션
```abap
MESSAGE '<메시지 내용>' TYPE '<실제타입>' DISPLAY LIKE '<표시타입>'.
```
- 메시지 동작은 E 타입, 표시 모양만 S 타입으로 보여줌
```abap
MESSAGE 'I타입 메세지입니다.' TYPE 'I' DISPLAY LIKE 'S'.
```
<img width="483" height="143" alt="image" src="https://github.com/user-attachments/assets/f00c3f74-380b-4dae-917a-6798c78c18fa" />
</br>
</br>

```abap
MESSAGE 'E타입 메세지입니다.' TYPE 'E' DISPLAY LIKE 'S'.
```
<img width="225" height="46" alt="image" src="https://github.com/user-attachments/assets/f49a1573-bcd5-4cd6-9b0c-d553f983aeb8" />
</br>
</br>
</br>
</br>
</br>

### < 추가적인 개념 - `SET / GET PARAMETER` >
- 서로 다른 프로그램/화면 간에 입력값을 공유하기 위한 기능
- Data Element에 설정된 Parameter ID를 키로 사용
- 한 프로그램에서 SET으로 저장한 값을 다른 프로그램에서 GET으로 불러옴

<img width="433" height="330" alt="image" src="https://github.com/user-attachments/assets/2092cfa6-8af8-403b-b2e8-4b55492a8c7d" />
</br>
</br>
</br>
</br>

---

</br>

## < Icon Field >
- SAP에서 제공하는 아이콘을 저장하기 위한 데이터 타입
```abap
DATA: <icon_field> TYPE ICONS-TEXT.
```
```abap
DATA: iconfield1 TYPE ICONS-TEXT,
      iconfield2 TYPE ICONS-TEXT.
```

- `/oicon` 으로 아이콘 볼 수 있음
<img width="268" height="81" alt="image" src="https://github.com/user-attachments/assets/fe1f0051-1c41-45f6-8cd2-0bd880d10115" />

</br>
</br>
</br>


### < `ICON_CREATE` 함수 불러오기 >
- `Pattern` 을 통해 가져오기
  
<img width="622" height="391" alt="image" src="https://github.com/user-attachments/assets/ba885de6-4761-440d-bf23-c890d700720d" />

</br>
</br>
</br>
</br>

### < Icon Field 를 이용한  예제 >
</br>
</br>

- 문제

<img width="453" height="294" alt="image" src="https://github.com/user-attachments/assets/343c3b1a-33c2-4845-9ab1-faaf80c25e02" />
</br>
</br>
</br>

**1) `Icon` 이용한 Layout 설정**

<img width="541" height="500" alt="image" src="https://github.com/user-attachments/assets/93017b3d-facf-40a3-806e-7aa830caa00a" />
</br>
</br>
</br>

**2) 100 Screen 모듈 생성**
```abap
PROCESS BEFORE OUTPUT.
 MODULE STATUS_0100.
 MODULE SET_ICONS.
 MODULE CLEAR_OK_CODE.
*
PROCESS AFTER INPUT.
 MODULE USER_COMMAND_0100.
```
</br>
</br>

**3) `TOP` 모듈 생성**
```abap
PROGRAM SAPMZB03004.

DATA: gs_flight TYPE sflight.
DATA: OK_CODE TYPE sy-ucomm.

DATA: gv_button TYPE I,
      ICONFIELD1 TYPE ICONS-TEXT,
      ICONFIELD2 TYPE ICONS-TEXT.
```
</br>
</br>

**4) `F01` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZB03004
*&---------------------------------------------------------------------*

FORM set_icon USING icon_name
              CHANGING icon_result.
  CALL FUNCTION 'ICON_CREATE'
    EXPORTING
      name = icon_name
    IMPORTING
      RESULT                      = icon_result
    EXCEPTIONS
      ICON_NOT_FOUND              = 1
      OUTPUTFIELD_TOO_SHORT       = 2
      OTHERS                      = 3
    .
  IF sy-subrc <> 0.
    MESSAGE 'Error' TYPE 'E'.
  ENDIF.
ENDFORM.
```
</br>
</br>

**5) `PAI` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZB03004
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.
  CASE OK_CODE.
    WHEN 'BTN01'.
      IF gv_button = 1.
        gv_button = 0.
      ELSE.
        gv_button = 1.
      ENDIF.
    WHEN 'ICON'.
      IF gv_button = 1.
        gv_button = 0.
      ELSE.
        gv_button = 1.
      ENDIF.
    WHEN 'BACK'.
      LEAVE TO SCREEN 0.
    WHEN 'EXIT' OR 'CANCEL'.
      LEAVE PROGRAM.
    WHEN 'MOVE'.
      SET SCREEN 200.
      LEAVE SCREEN.
      " LEAVE TO SCREEN 200. 과 동일
    WHEN 'REMARK'.
*      MESSAGE 'Remark 메뉴 선택' TYPE 'I'.
      CALL SCREEN 110
      STARTING AT 5 5
      ENDING AT 50 10.
    WHEN OTHERS.
  ENDCASE.

ENDMODULE.

*&---------------------------------------------------------------------*

MODULE user_command_0110 INPUT.
  CASE OK_CODE.
    WHEN 'OK'.
      MESSAGE 'OK 클릭' TYPE 'I'.
    WHEN 'CLOSE'.
      MESSAGE 'CLOSE 클릭' TYPE 'I'.
    WHEN 'DISP'.
      MESSAGE 'DISP 클릭' TYPE 'I'.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```
</br>
</br>

**6) `PBO` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZB03004
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.
 SET PF-STATUS 'S100'.
 SET TITLEBAR 'T100' WITH sy-dynnr.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE status_0200 OUTPUT.
 SET PF-STATUS 'S200'.
 SET TITLEBAR 'T100' WITH sy-dynnr.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE status_0110 OUTPUT.
 SET PF-STATUS 'S110'.
 SET TITLEBAR 'T100' WITH sy-dynnr.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE set_icons OUTPUT.

  PERFORM set_icon USING 'ICON_CHANGE' CHANGING ICONFIELD2.

  IF gv_button = 1.
    PERFORM set_icon USING 'ICON_SYSTEM_OKAY' CHANGING ICONFIELD1.
  ELSE.
    PERFORM set_icon USING 'ICON_DISPLAY' CHANGING ICONFIELD1.
  ENDIF.

ENDMODULE.

*&---------------------------------------------------------------------*

MODULE clear_ok_code OUTPUT.
  CLEAR: OK_CODE.
ENDMODULE.
```
</br>
</br>

**7) 결과 확인**
- 아이콘 변경 버튼 클릭시 체크 아이콘으로 바뀜 ( 다시 누르면 원래대로 바뀜 )
<img width="538" height="443" alt="image" src="https://github.com/user-attachments/assets/ed54eb70-b443-4760-a6f8-5a003bf65f0e" />

</br>
</br>
</br>
</br>

---

</br>

## < 스크린 인터페이스(UI) 구성 기능 >
</br>

### 1) 드롭다운
- `Listbox` (드롭다운) = 여러 값 중 하나를 선택
</br>

- `Listbox with key` 선택 시
  
<img width="581" height="411" alt="image" src="https://github.com/user-attachments/assets/b2fad37b-7386-42c8-8728-9c2f080e2044" />
</br>
</br>

<img width="540" height="457" alt="image" src="https://github.com/user-attachments/assets/02045538-3903-4b1e-a475-98ac10ddd584" />

</br>
</br>

- `Listbox` 선택 시
<img width="575" height="448" alt="image" src="https://github.com/user-attachments/assets/d07b66a3-b33f-4635-802f-d2377f769e15" />
</br>
</br>

<img width="531" height="460" alt="image" src="https://github.com/user-attachments/assets/ff0a7dda-af17-4df5-b638-82cfe09cf818" />

</br>
</br>
</br>
</br>

### 2) 라디오버튼 및 체크박스 ( Radio button / Check box )

- 라디오 버튼끼리 그룹 지정 가능
- 그룹 지정시 라디오버튼을 그룹 중 하나만 선택 가능하게 됨
- `OK_CODE` 없이 바로 라디오버튼 체크 가능
```abap
CASE 'X'.
  WHEN view.
    gv_title = 1.
  WHEN maintain_flights.
    gv_title = 2.
  WHEN maintain_bookings.
    gv_title = 3.
ENDCASE.
```

<img width="724" height="373" alt="image" src="https://github.com/user-attachments/assets/9bfbf8d0-91fa-4f9b-b11c-d6fcf922a92f" />

</br>
</br>

- 라디오 버튼끼리 그룹 지정 시 하나만 펑션코드 설정하면 됨
<img width="696" height="356" alt="image" src="https://github.com/user-attachments/assets/d7e18577-96db-4a89-8d98-4e2f119d5dd2" />

</br>
</br>
</br>
</br>

### 3) 버튼의 아이콘 지정
- 버튼에 아이콘을 같이 띄울 수 있음
<img width="699" height="434" alt="image" src="https://github.com/user-attachments/assets/ec5b76f3-e4e2-413f-94d2-9006dc726313" />

</br>
</br>
</br>
</br>

---

</br>

## < 실습 코드 >

### 실습 1
</br>


**1) Screen 100 `Layout` 설정**
- `Foreign Key Check` 해제해야 오류 Message 가 안뜸
  
<img width="550" height="506" alt="image" src="https://github.com/user-attachments/assets/d4b1fba2-bbd3-4d9f-93d9-35b6a8e85b0c" />
</br>
</br>
</br>
</br>

**2) `TOP` 모듈 생성**
```abap
PROGRAM SAPMZPRACTICE04B03.

TABLES: SDYN_CONN.

DATA: OK_CODE TYPE sy-ucomm,
      ICONFIELD01 TYPE ICONS-TEXT,
      gs_spfli TYPE SPFLI,
      gv_subrc TYPE I.
```
</br>
</br>

**3) `F01` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZPRACTICE04B03
*&---------------------------------------------------------------------*

FORM set_icons USING icon_name CHANGING icon_result.
  CALL FUNCTION 'ICON_CREATE'
    EXPORTING
      name                        = icon_name
    IMPORTING
      RESULT                      = icon_result
    EXCEPTIONS
      ICON_NOT_FOUND              = 1
      OUTPUTFIELD_TOO_SHORT       = 2
      OTHERS                      = 3
             .
    IF sy-subrc <> 0.
      MESSAGE 'Error' TYPE 'E'.
    ENDIF.
ENDFORM.
```
</br>
</br>

**4) `PAI` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZPRACTICE04B03
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.
  IF OK_CODE = 'BTN01'.
    SELECT SINGLE * FROM SPFLI
      INTO CORRESPONDING FIELDS OF gs_spfli
      WHERE carrid = SDYN_CONN-carrid
        AND connid = SDYN_CONN-connid.
    IF sy-subrc <> 0.
      gv_subrc = 4.
    ELSE.
      gv_subrc = 1.
    ENDIF.
  ENDIF.
ENDMODULE.
```
</br>
</br>

**5) `PBO` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZPRACTICE04B03
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.
  IF gv_subrc = 4.
    PERFORM set_icons USING 'ICON_LED_RED' CHANGING ICONFIELD01.
  ELSEIF gv_subrc = 1.
    PERFORM set_icons USING 'ICON_LED_GREEN' CHANGING ICONFIELD01.
  ENDIF.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE clear_ok_code OUTPUT.
  CLEAR: OK_CODE.
ENDMODULE.
```
</br>
</br>

**6) 결과 확인**

<img width="314" height="284" alt="image" src="https://github.com/user-attachments/assets/9cc57410-24da-4d26-a7b8-de86f9cbafa9" />
</br>
</br>
</br>
</br>
</br>
</br>

### 실습 2
- 라디오버튼 활용 실습
- 타이틀 변경 실습 (titlebar)
</br>

**1) Screen 100 `Layout` 설정**

<img width="738" height="307" alt="image" src="https://github.com/user-attachments/assets/17c29bf5-c52d-48cb-a710-43ddc3b44549" />
</br>
</br>
</br>
</br>

**2) `TOP` 모듈 수정**
```abap
PROGRAM SAPMZBC410_SOLUTION_03_01.

TABLES: SDYN_CONN.

DATA: exit_button TYPE C,
      OK_CODE TYPE SY-UCOMM,
      gs_data TYPE SDYN_CONN,
      gv_subrc TYPE sy-subrc,
      gs_data2 LIKE SDYN_CONN,
      gv_button TYPE I.

DATA: VIEW TYPE C VALUE 'X',
      MAINTAIN_FLIGHTS TYPE C,
      MAINTAIN_BOOKINGS TYPE C,
      gv_title TYPE I.
```
</br>
</br>

**3) `PAI` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZBC410_SOLUTION_03_01
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.

  IF exit_button = 'X'.
    LEAVE TO SCREEN 0.
  ELSEIF exit_button = 'T'.
    CALL SCREEN 150
    STARTING AT 5 5
    ENDING AT 50 10.
    CLEAR: exit_button.
  ENDIF.

ENDMODULE.

*----------------------------------------------------------------------*

MODULE check_sflight INPUT.

  CASE OK_CODE.
    WHEN 'MODE'.
      CASE 'X'.
        WHEN VIEW.
          gv_title = 1.
        WHEN MAINTAIN_FLIGHTS.
          gv_title = 2.
        WHEN MAINTAIN_BOOKINGS.
          gv_title = 3.
        WHEN OTHERS.
      ENDCASE.
    WHEN 'PUSH'.
      gv_button = 1.

      SELECT SINGLE * FROM sflight
        INTO CORRESPONDING FIELDS OF gs_data
        WHERE carrid = SDYN_CONN-carrid
          AND connid = SDYN_CONN-connid
          AND fldate = SDYN_CONN-fldate.

      IF sy-subrc <> 0.
        gv_subrc = 4.
        message text-007 TYPE 'I'.
      ENDIF.
    WHEN OTHERS.
  ENDCASE.

ENDMODULE.

*----------------------------------------------------------------------*

MODULE user_command_0150 INPUT.
  IF OK_CODE = 'BTN01'.
    LEAVE TO SCREEN 0.
  ENDIF.
ENDMODULE.
```
</br>
</br>

**4) `PBO` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZBC410_SOLUTION_03_01
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.

  SET PF-STATUS 'S100'.

  IF gv_title = 1.
    SET TITLEBAR 'T100' WITH 'View'.
  ELSEIF gv_title = 2.
    SET TITLEBAR 'T100' WITH 'Maintain flights'.
    LOOP AT SCREEN.
      IF screen-name = 'SDYN_CONN-PLANETYPE'.
        screen-input = 1.
      ENDIF.
      MODIFY SCREEN.
    ENDLOOP.
  ELSEIF gv_title = 3.
    SET TITLEBAR 'T100' WITH 'Maintain bookings'.
  ENDIF.

  IF gv_button = 1.
    IF gv_subrc <> 0.
      CLEAR SDYN_CONN.
      gv_subrc = 0.
    ELSE.
      MOVE-CORRESPONDING gs_data TO SDYN_CONN.
    ENDIF.
  ELSE.
    gv_button = 0.
  ENDIF.

ENDMODULE.

*&---------------------------------------------------------------------*

MODULE status_0150 OUTPUT.
 SET PF-STATUS 'S150'.
 SET TITLEBAR 'xxx'.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE clear_ok_code OUTPUT.
  CLEAR: OK_CODE.
ENDMODULE.
```
</br>
</br>

**5) 결과 확인**
- 라디오 버튼 클릭에 따라 타이틀이 바뀌고 `Maintain flights` 클릭 시 `Plane type` 인풋이 가능
<img width="607" height="277" alt="image" src="https://github.com/user-attachments/assets/d0bb79eb-a9ef-4b8f-80d3-65a332a3e71a" />
</br>
</br>
</br>
</br>
</br>
</br>

### 실습 3
</br>

- 문제
<img width="370" height="211" alt="image" src="https://github.com/user-attachments/assets/b718816c-c7b8-4164-b521-3fb326df95fc" />
</br>
</br>
</br>
</br>


**1) Screen 100 `Layout` 설정**

<img width="537" height="275" alt="image" src="https://github.com/user-attachments/assets/21e4e168-07c9-478a-a864-f2f762d419d5" />
</br>
</br>
</br>
</br>

**2) 100 Screen 모듈 생성**
```abap
PROCESS BEFORE OUTPUT.
 MODULE STATUS_0100.
 MODULE CLEAR_OK_CODE.
*
PROCESS AFTER INPUT.
 MODULE USER_COMMAND_0100.
```
</br>
</br>

**3) `F01` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZPRACTICE04B03
*&---------------------------------------------------------------------*

FORM set_icons USING icon_name CHANGING icon_result.
  CALL FUNCTION 'ICON_CREATE'
    EXPORTING
      name                        = icon_name
    IMPORTING
      RESULT                      = icon_result
    EXCEPTIONS
      ICON_NOT_FOUND              = 1
      OUTPUTFIELD_TOO_SHORT       = 2
      OTHERS                      = 3
             .
    IF sy-subrc <> 0.
      MESSAGE 'Error' TYPE 'E'.
    ENDIF.
ENDFORM.
```
</br>
</br>

**4) `TOP` 모듈 생성**
```abap
PROGRAM SAPMZPRACTICE04B03.

TABLES: SDYN_CONN, SFLIGHT.

DATA: OK_CODE TYPE sy-ucomm,
      ICONFIELD01 TYPE ICONS-TEXT,
      gs_spfli TYPE SPFLI,
      gs_sflight TYPE sflight,
      gv_subrc TYPE I,
      gv_max_fldate TYPE S_DATE,
      gv_remain_seat TYPE INT4.
```
</br>
</br>

**5) `PAI` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZPRACTICE04B03
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.
  IF OK_CODE = 'BTN01'.
    SELECT SINGLE * FROM SPFLI
      INTO CORRESPONDING FIELDS OF gs_spfli
      WHERE carrid = SDYN_CONN-carrid
        AND connid = SDYN_CONN-connid.
    IF sy-subrc <> 0.
      MESSAGE '일치하는 데이터가 없습니다.' TYPE 'I'.
    ELSE.
      SELECT MAX( fldate ) FROM sflight
        INTO gv_max_fldate
        WHERE carrid = SDYN_CONN-carrid
          AND connid = SDYN_CONN-connid.

      SELECT SINGLE * FROM sflight
        INTO gs_sflight
        WHERE fldate = gv_max_fldate.

      gv_remain_seat = gs_sflight-SEATSMAX - gs_sflight-SEATSOCC.

      IF gv_remain_seat = 0.
        gv_subrc = 1.
      ELSEIF gv_remain_seat >= 10.
        gv_subrc = 2.
      ELSEIF gv_remain_seat < 10.
        gv_subrc = 3.
      ENDIF.

    ENDIF.
  ENDIF.
ENDMODULE.
```
</br>
</br>

**6) `PBO` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZPRACTICE04B03
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.
  MOVE-CORRESPONDING gs_sflight TO SFLIGHT.
  IF gv_subrc = 3.
    PERFORM set_icons USING 'ICON_LED_YELLOW' CHANGING ICONFIELD01.
  ELSEIF gv_subrc = 2.
    PERFORM set_icons USING 'ICON_LED_RED' CHANGING ICONFIELD01.
  ELSEIF gv_subrc = 1.
    PERFORM set_icons USING 'ICON_LED_GREEN' CHANGING ICONFIELD01.
  ENDIF.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE clear_ok_code OUTPUT.
  CLEAR: OK_CODE.
ENDMODULE.
```
</br>
</br>

**7) 결과 확인**
- 잔여석이 0 이면 초록색, 10 이상이면 빨간색, 10 미만이면 노란색

<img width="567" height="292" alt="image" src="https://github.com/user-attachments/assets/ff6f0c7c-a3a4-440f-b7e2-2cc87cdefd7b" />

</br>
</br>

# 12/17

</br>
</br>

## <  핵심 개념 >
</br>

- **1) FIELD / CHAIN 입력 체크 방식**
- **2) `AT EXIT-COMMAND` - E 타입 메시지 일 때 나가기**
- **3) `Back` 예제 - `POPUP` 팝업**

</br>

- **`LEAVE TO SCREEN 0`** 같은 화면 전환 명령은 **`PAI`** 에서만
- **`SCREEN-INPUT`** 같은 화면 속성 변경은 **`PBO`** 에서만
- 사용자 입력 기반 SELECT는 **`PAI`** , 조회 결과 예 반영/속성 변경은 **`PBO`**
- **OK_CODE 초기화** 코드 꼭 넣어줘야 함 ( 보통 **`PBO`** 에서)
- **`OK_CODE`** 케이스문은 **`PAI`** 에서
- LOOP AT SCREEN 사용시 **`MODIFY SCREEN`** 넣기
- **`FIELD / CHAIN`** 은 무조건 **PAI** 에서만 구현
- **`AT EXIT-COMMAND`** 은 무조건 **PAI** 에서만 구현
- **`AT EXIT-COMMAND`** 는 Screen 코드에서 **맨 위** 에 두는 게 좋음

</br>

---

</br>

## < PAI FIELD / CHAIN 입력 체크 방식 >
- **`FIELD / CHAIN`** 은 무조건 **PAI** 에서만 구현
- 화면에 입력된 값을 기준으로 검증하기 위해 사용
</br>

### 1) 기본형 (옵션 없음) – 항상 실행
- PAI 발생 시 무조건 MODULE 실행
- 값 입력 여부, 변경 여부 모두 무관
</br>

- **단일값 체크 (FIELD)**
```abap
FIELD <field> MODULE <module>.
```
```abap
FIELD SCARR-CARRID MODULE CHECK_INPUT.
```
- **다중값 체크 (CHAIN)**
```abap
CHAIN.
  FIELD: <field1>, <field2>.
  MODULE <module>.
ENDCHAIN.
```
```abap
CHAIN.
  FIELD: SDYN_CONN-CARRID, SDYN_CONN-CONNID.
  MODULE CHECK_INPUTS.
ENDCHAIN.
```
</br>
</br>

### 2) 입력값 존재 기준 (ON INPUT / ON CHAIN-INPUT)
- 값이 입력된 경우에만 MODULE 실행
- 다중 값 체크 시 CHAIN 내 하나라도 값이 있으면 실행 (OR 조건)
</br>

- **단일값 체크 (ON INPUT)**
```abap
FIELD <field> MODULE <module> ON INPUT.
```
```abap
FIELD SCARR-CARRID MODULE CHECK_INPUT ON INPUT.
```
- **다중값 체크 (ON CHAIN-INPUT)**
```abap
CHAIN.
  FIELD: <field1>, <field2>.
  MODULE <module> ON CHAIN-INPUT.
ENDCHAIN.
```
```abap
CHAIN.
  FIELD: SDYN_CONN-CARRID, SDYN_CONN-CONNID.
  MODULE CHECK_INPUTS ON CHAIN-INPUT.
ENDCHAIN.
```
</br>
</br>

### 3) 값 변경 기준 (ON REQUEST / ON CHAIN-REQUEST)
- 이전 값과 비교하여 변경되었을 때만 MODULE 실행
- 다중 값 체크 시 CHAIN 내 하나라도 값이 변경되면 실행
- 값의 존재 여부와 무관하게, 이전 값과 달라지기만 하면 실행 ( 값이 있다가 빈 값이어도 실행 )
</br>

- **단일값 체크 (ON REQUEST)**
```abap
FIELD <field> MODULE <module> ON REQUEST.
```
```abap
FIELD SCARR-CARRID MODULE CHECK_INPUT ON REQUEST.
```
- **다중값 체크 (ON CHAIN-REQUEST)**
```abap
CHAIN.
  FIELD: <field1>, <field2>.
  MODULE <module> ON CHAIN-REQUEST.
ENDCHAIN.
```
```abap
CHAIN.
  FIELD: SDYN_CONN-CARRID, SDYN_CONN-CONNID.
  MODULE CHECK_INPUTS ON CHAIN-REQUEST.
ENDCHAIN.
```
</br>
</br>
</br>

## < PAI FIELD / CHAIN 예제 >
</br>

**1) `Layout` 설정**

<img width="538" height="255" alt="image" src="https://github.com/user-attachments/assets/f839bae4-e194-4514-b412-e8e6838c230b" />

</br>
</br>

**2) `Screen` 코드에서 모듈 생성 ( PAI, PBO )**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZB03005
*&---------------------------------------------------------------------*

PROCESS BEFORE OUTPUT.
 MODULE STATUS_0100.
 MODULE INIT_DATA.
*
PROCESS AFTER INPUT.
  MODULE EXIT AT EXIT-COMMAND.

**********************************************************************

* FIELD SCARR-CARRID MODULE CHECK_INPUT. " 단일값 체크
*
* CHAIN. " 다중값 체크
*  FIELD: SDYN_CONN-CARRID, SDYN_CONN-CONNID.
*  MODULE CHECK_INPUTS.
* ENDCHAIN.

**********************************************************************

*  " 단일값 체크 : ON INPUT 값이 있을때만 체크하도록 설정
*  FIELD SCARR-CARRID MODULE CHECK_INPUT ON INPUT.
*
*  " 다중값 체크 : ON CHAIN-INPUT 값이 있을때만 체크하도록 설정
*  CHAIN.
*    FIELD: SDYN_CONN-CARRID, SDYN_CONN-CONNID.
*    MODULE CHECK_INPUTS ON CHAIN-INPUT.
*  ENDCHAIN.
* MODULE USER_COMMAND_0100.

**********************************************************************

   " 단일값 체크 : ON REQUEST 값이 변경되었을 때 체크하도록 설정
  FIELD SCARR-CARRID MODULE CHECK_INPUT ON REQUEST.

  " 다중값 체크 : ON CHAIN-REQUEST 값이 변경되었을 때만 체크하도록 설정
  CHAIN.
    FIELD: SDYN_CONN-CARRID, SDYN_CONN-CONNID.
    MODULE CHECK_INPUTS ON CHAIN-REQUEST.
  ENDCHAIN.
 MODULE USER_COMMAND_0100.
```
</br>

**3) `PAI` 에서 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZB03005
*&---------------------------------------------------------------------*

" 단일입력
MODULE check_input INPUT.
  IF SCARR-CARRID IS NOT INITIAL.
    SELECT SINGLE CARRID
      FROM SPFLI " 여기엔 AB값이 없음
      INTO SCARR-CARRID
      WHERE CARRID = SCARR-CARRID.
    IF sy-subrc <> 0.
      MESSAGE '해당 항공사 데이터는 존재하지 않습니다.' TYPE 'E'.
    ENDIF.
  ENDIF.
ENDMODULE.

" 다중입력
MODULE check_inputs INPUT.
  IF SDYN_CONN-CARRID IS NOT INITIAL AND
     SDYN_CONN-CONNID IS NOT INITIAL.
    SELECT SINGLE *
      FROM SPFLI
      INTO CORRESPONDING FIELDS OF SDYN_CONN
      WHERE CARRID = SDYN_CONN-CARRID
        AND CONNID = SDYN_CONN-CONNID.
    IF sy-subrc <> 0.
      MESSAGE '해당 항공사의 항공편이 존재하지 않습니다.' TYPE 'E'.
    ENDIF.
  ENDIF.
ENDMODULE.
```

</br>
</br>
</br>

---

</br>

## < AT EXIT-COMMAND >
- **`AT EXIT-COMMAND`** 은 무조건 **PAI** 에서만 구현
- `AT EXIT-COMMAND` 는 Screen 코드에서 맨 위에 두는 게 좋음
- PF-STATUS에서 Function Type = E(Exit) 로 정의된 커맨드만 대상으로 동작함
- 메시지 E로 화면 진행이 막힌 상태에서, 사용자가 “종료”를 선택했을 때 빠져나가기 위한 용도
</br>
</br>

**1) `Function Type` 설정**
- `EXIT` , `CANCEL` 일 때 `Function Type` 을 `E` 로 설정

<img width="669" height="331" alt="image" src="https://github.com/user-attachments/assets/b0aae6c7-d74c-49c6-887c-1824e4d1c110" />

</br>
</br>
</br>
</br>

**2) `PAI` 모듈 생성**
- Screen 코드에서 모듈 생성
```abap
PROCESS AFTER INPUT.
  MODULE <module_name> AT EXIT-COMMAND.
```
```abap
PROCESS AFTER INPUT.
  MODULE EXIT AT EXIT-COMMAND.
```
- 해당 PAI 모듈에서 코드 작성
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZB03005
*&---------------------------------------------------------------------*

MODULE exit INPUT.
  CASE OK_CODE.
    WHEN 'EXIT'.
      LEAVE PROGRAM. " 프로그램 종료
    WHEN 'CANCEL'.
      LEAVE TO SCREEN 0. " 스크린 종료
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```
</br>
</br>

**3) 결과 확인**
- `EXIT` , `CANCEL` 누르면 에러가 나도 빠져나올 수 있음 ( `BACK` 은 불가능 )

<img width="580" height="383" alt="image" src="https://github.com/user-attachments/assets/5c8e4e7b-c752-4f23-b7d2-928950bfda70" />
</br>
</br>
</br>
</br>

---

</br>

## < 종료(Function) 버튼 로직 >
- **🟢 Back (뒤로가기)**

  - 일반적인 화면 이동용 버튼
  - 이전 화면으로 돌아가며 프로그램은 종료되지 않음
- **🟡 Exit (노란색)**

  - 현재 프로그램을 완전히 종료
  - SAP Easy Access(초기 화면)로 이동
- **🔴 Cancel (빨간색)**
  
  - 오류 발생 등으로 진행이 불가능할 때 사용
  - 현재 처리를 취소하고 이전 상태로 복귀

<img width="550" height="377" alt="image" src="https://github.com/user-attachments/assets/1b0e6a46-aec0-4a37-b379-d4190f733c21" />
</br>
</br>
</br>
</br>
</br>

### < `Back` 예제 - POPUP 팝업 >
</br>

**1) `TOP` 모듈 생성**
```abap
PROGRAM SAPMZB03005.

" TABLES에는 직접적으로 Table 이름 넣는것보단
" 필요한 필드 구성하여 만든 Structure 이름 넣는게 좋음.
" => 지금은 테스트용으로..
TABLES: SCARR, SDYN_CONN.
DATA: OK_CODE TYPE sy-ucomm.

" 신호등 결과 값으로 '1', '2', 'A' 를 받을 변수
DATA: gv_answer TYPE C.
```
</br>

**2) `PAI` 모듈 생성**

<img width="598" height="304" alt="image" src="https://github.com/user-attachments/assets/4a27c9a0-3465-4118-a1f0-72829a58743b" />
</br>
</br>

```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZB03005
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.
  CASE OK_CODE.
    WHEN 'BACK'.
      CALL FUNCTION 'POPUP_TO_CONFIRM'
        EXPORTING
          titlebar =  'Information'
          text_question               = 'Are you sure?'
        IMPORTING
          ANSWER                      = gv_answer
        EXCEPTIONS
          TEXT_NOT_FOUND              = 1
          OTHERS                      = 2.

      IF sy-subrc <> 0.
        MESSAGE '오류 발생' TYPE 'E'.
      ELSE.
        IF gv_answer = 1.
          LEAVE TO SCREEN 0.
        ENDIF.
      ENDIF.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```
</br>

**3) 결과 확인**
- `BACK` 누르면 팝업이 뜸

<img width="611" height="294" alt="image" src="https://github.com/user-attachments/assets/c1948e66-7c1b-4390-a450-c088b3697217" />
</br>
</br>
</br>
</br>
</br>

---

</br>

## < 추가적인 기능 >

</br>

- **`PAI` 에 있는 모듈들은 순차적으로 실행됨**
<img width="525" height="363" alt="image" src="https://github.com/user-attachments/assets/fb5f10f3-4de3-41cc-884e-4ea875403676" />
</br>
</br>
</br>
</br>

### `SWITCH` ( TCODE : `SFW5` ) 기반 MODULE 호출
- SWITCH는 스위치가 ON일 때만 MODULE을 실행하는 제어 장치
- PAI에서 조건부로 로직을 활성/비활성하기 위해 사용
```abap
PROCESS AFTER INPUT.
  MODULE <module_name> SWITCH <switch_name>.
```
```abap
PROCESS AFTER INPUT.
  MODULE add_check SWITCH sw_bc410.
```
- `PAI` 모듈 코드
```abap
MODULE add_check INPUT.
  CASE ok_code.
    WHEN 'ADD_FUNCTION'.
      " 기능 처리
  ENDCASE.
ENDMODULE.
```
</br>
</br>

### `SET / GET PARAMETER`
- 서로 다른 프로그램/화면 간에 입력값을 공유하기 위한 기능
- Data Element에 설정된 Parameter ID를 키로 사용
- 한 프로그램에서 SET으로 저장한 값을 다른 프로그램에서 GET으로 불러옴

<img width="433" height="330" alt="image" src="https://github.com/user-attachments/assets/2092cfa6-8af8-403b-b2e8-4b55492a8c7d" />
</br>
</br>
</br>
</br>

---

</br>

## < 실습 코드 >
</br>

### 실습 1
</br>

- 문제
  
<img width="445" height="225" alt="image" src="https://github.com/user-attachments/assets/64038eae-eb24-46ab-9a1f-a283a997be7c" />
</br>
</br>
</br>

**1) `Layout` 설정**

<img width="282" height="256" alt="image" src="https://github.com/user-attachments/assets/752bef5c-f436-4598-8335-657595f20b67" />
</br>
</br>

**2) `Screen` 코드에서 모듈 생성 ( PAI, PBO )**
```abap
PROCESS BEFORE OUTPUT.
 MODULE STATUS_0100.
 MODULE CLEAR_OK_CODE.
*
PROCESS AFTER INPUT.
 MODULE EXIT AT EXIT-COMMAND.
 CHAIN.
  FIELD: SDYN_BOOK-CARRID, SDYN_BOOK-CONNID, SDYN_BOOK-FLDATE,
SDYN_BOOK-BOOKID.
  MODULE CHECK_INPUTS ON CHAIN-REQUEST.
 ENDCHAIN.
 MODULE USER_COMMAND_0100.
```
</br>


**3) `TOP` 모듈 생성**
```abap
PROGRAM SAPMZPRACTICE05B03.

TABLES: SDYN_BOOK.

DATA: OK_CODE TYPE sy-ucomm,
      gv_cancelled TYPE C LENGTH 1,
      gs_data TYPE SDYN_BOOK.
```
</br>

**4) `PAI` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZPRACTICE05B03
*&---------------------------------------------------------------------*

MODULE check_inputs INPUT.
  IF SDYN_BOOK-CARRID IS NOT INITIAL AND
     SDYN_BOOK-CONNID IS NOT INITIAL AND
     SDYN_BOOK-FLDATE IS NOT INITIAL AND
     SDYN_BOOK-BOOKID IS NOT INITIAL.
    SELECT SINGLE CANCELLED FROM SBOOK
      INTO gv_cancelled
      WHERE carrid = SDYN_BOOK-CARRID
        AND connid = SDYN_BOOK-CONNID
        AND fldate = SDYN_BOOK-FLDATE
        AND bookid = SDYN_BOOK-BOOKID.
    SELECT SINGLE carrid connid fldate bookid CUSTOMID CUSTTYPE FROM SBOOK
      INTO CORRESPONDING FIELDS OF gs_data
      WHERE carrid = SDYN_BOOK-CARRID
        AND connid = SDYN_BOOK-CONNID
        AND fldate = SDYN_BOOK-FLDATE
        AND bookid = SDYN_BOOK-BOOKID.

    IF gv_cancelled = 'X'.
      MESSAGE '항공편 예약이 취소된 건 입니다.' TYPE 'E'.
    ENDIF.
  ENDIF.
ENDMODULE.

*----------------------------------------------------------------------*

MODULE user_command_0100 INPUT.
  CASE OK_CODE.
    WHEN 'BACK'.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.

*----------------------------------------------------------------------*

MODULE EXIT INPUT.
  CASE OK_CODE.
    WHEN 'EXIT'.
      LEAVE PROGRAM.
    WHEN 'CANCEL'.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```
</br>

**5) `PBO` 모듈 생성**

<img width="536" height="186" alt="image" src="https://github.com/user-attachments/assets/d8623302-5ef3-45b0-b053-ce9d166d5cc1" />
</br>
</br>

```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZPRACTICE05B03
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.
  SET PF-STATUS 'S100'.
  MOVE-CORRESPONDING gs_data TO SDYN_BOOK.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE clear_ok_code OUTPUT.
  CLEAR: OK_CODE.
ENDMODULE.
```
</br>

**6) 결과 확인**
- CANCELLED 가 `X` 일 때

<img width="289" height="258" alt="image" src="https://github.com/user-attachments/assets/ad495b9a-3564-4de0-80be-5a8bed2ddd53" />
</br>
</br>

- CANCELLED 가 `X` 가 아닐 때

<img width="280" height="257" alt="image" src="https://github.com/user-attachments/assets/f31a0317-f737-4867-8f4d-b54428c2f1e5" />
</br>
</br>
</br>
</br>
</br>

### 실습 2
</br>

- 문제
  
<img width="382" height="229" alt="image" src="https://github.com/user-attachments/assets/ec99c30b-7f0b-4501-9ac8-3cbe00bae763" />
</br>
</br>
</br>

- **위 문제 코드에서 `PAI` 코드 수정**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZPRACTICE05B03
*&---------------------------------------------------------------------*

MODULE check_inputs INPUT.
  IF SDYN_BOOK-CARRID IS NOT INITIAL AND
     SDYN_BOOK-CONNID IS NOT INITIAL AND
     SDYN_BOOK-FLDATE IS NOT INITIAL AND
     SDYN_BOOK-BOOKID IS NOT INITIAL.
    SELECT SINGLE CANCELLED FROM SBOOK
      INTO gv_cancelled
      WHERE carrid = SDYN_BOOK-CARRID
        AND connid = SDYN_BOOK-CONNID
        AND fldate = SDYN_BOOK-FLDATE
        AND bookid = SDYN_BOOK-BOOKID.
    SELECT SINGLE carrid connid fldate bookid CUSTOMID CUSTTYPE FROM SBOOK
      INTO CORRESPONDING FIELDS OF gs_data
      WHERE carrid = SDYN_BOOK-CARRID
        AND connid = SDYN_BOOK-CONNID
        AND fldate = SDYN_BOOK-FLDATE
        AND bookid = SDYN_BOOK-BOOKID.

    IF gv_cancelled = 'X'.
      MESSAGE '항공편 예약이 취소된 건 입니다.' TYPE 'E'.
    ENDIF.
  ELSE.
    IF SDYN_BOOK-CARRID IS INITIAL.
      SET CURSOR FIELD 'SDYN_BOOK-CARRID'.
    ELSEIF SDYN_BOOK-CONNID IS INITIAL.
      SET CURSOR FIELD 'SDYN_BOOK-CONNID'.
    ELSEIF SDYN_BOOK-FLDATE IS INITIAL.
      SET CURSOR FIELD 'SDYN_BOOK-FLDATE'.
    ELSEIF SDYN_BOOK-BOOKID IS INITIAL.
      SET CURSOR FIELD 'SDYN_BOOK-BOKKID'.
    ENDIF.
    MESSAGE '1개 이상의 필드가 비워져 있습니다.' TYPE 'E'.
  ENDIF.
ENDMODULE.

*----------------------------------------------------------------------*

MODULE EXIT INPUT.
  CASE OK_CODE.
    WHEN 'EXIT'.
      MESSAGE '정말 이동하시겠습니까?' TYPE 'I'.
      LEAVE PROGRAM.
    WHEN 'CANCEL'.
      MESSAGE '정말 이동하시겠습니까?' TYPE 'I'.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```
</br>

- **결과 확인**

- 빈칸에 커서가 옮겨짐
<img width="319" height="268" alt="image" src="https://github.com/user-attachments/assets/dc38a9cd-5fac-4423-89b8-519d2a896335" />
</br>
</br>

- 나가면 창이 띄워짐
  
<img width="439" height="134" alt="image" src="https://github.com/user-attachments/assets/be90aad3-8164-45d5-9dc7-a11a2e4153fe" />


</br>
</br>


# 12/18

</br>
</br>

## <  핵심 개념 >
</br>

- **1) `CALL SUBSCREEN`**
- **2) Tabstrip (Tab Page) - 로컬 스크롤링**
- **3) Tabstrip (Tab Page) - PAI 스크롤링**
- **`ACTIVETAB`** 은 무조건 **`PBO`** 에서 해야 함
- **`ACTIVETAB`** 값 = 탭의 **`Function Code`**

</br>

- **`LEAVE TO SCREEN 0`** 같은 화면 전환 명령은 **`PAI`** 에서만
- **`SCREEN-INPUT`** 같은 화면 속성 변경은 **`PBO`** 에서만
- 사용자 입력 기반 SELECT는 **`PAI`** , 조회 결과 화면 반영/속성 변경은 **`PBO`**
- **OK_CODE 초기화** 코드 꼭 넣어줘야 함 ( 보통 **`PBO`** 에서 )
- **`OK_CODE`** 케이스문은 **`PAI`** 에서
- LOOP AT SCREEN 사용시 **`MODIFY SCREEN`** 넣기
- **`FIELD / CHAIN`** 은 무조건 **PAI** 에서만 구현
- **`AT EXIT-COMMAND`** 은 무조건 **PAI** 에서만 구현
- **`AT EXIT-COMMAND`** 는 Screen 코드에서 **맨 위** 에 두는 게 좋음
- **서로 다른 스크린의 버튼** 은 같은 MODULE에서 처리하면 **안됨**
- **즉시 반응** = **`Function Code`** 필수
- **버튼** → **`Function Code`** 만 OK_CODE로 옴
- **라디오·체크** → 보통 **`Name`** 값(X)으로 판단 ( `Function Code` 지정 필수 )
- **`ACTIVETAB`** 은 무조건 **`PBO`** 에서 해야 함
- **`ACTIVETAB`** 값 = 탭의 **`Function Code`**

</br>
</br>

---

</br>

## < 서브스크린 (Subscreen) >
- 메인 화면에 `Subscreen Area` (예약 영역) 를 미리 정의
- 실행 시 다른 Screen( `Subscreen` )을 해당 영역에 채워 넣음
- 메인 화면은 유지되며 부분 화면을 재사용·동적으로 교체 가능
- 서브스크린은 영역 1개당 1개만 표시되며, 영역을 여러 개 만들면 여러 개를 동시에 띄울 수 있음
</br>

### < Subscreen 제약사항 정리 >
- LOOP 문 내부 사용 불가
  - `LOOP AT SCREEN` , `LOOP AT itab` 등 반복문 안에서 `CALL SUBSCREEN` 사용 ❌
- CHAIN … ENDCHAIN 내부 사용 불가
- OK Code 필드 가질 수 없음
- 스크린 번호(Screen No.)는 유니크해야 함
- 화면 제어 명령 사용 불가
  - 타이틀, 메뉴, 버튼은 메인 스크린에서만 설정
</br>
</br>

### < `CALL SUBSCREEN` >
- `CALL SUBSCREEN` 은 화면 전환이 아님
- 메인 스크린 안의 `Subscreen Area` 에 다른 Screen을 포함시키는 동작
- 메인 스크린의 흐름(PBO/PAI) 안에서 서브스크린의 PBO/PAI도 함께 실행됨
- 시스템변수 `SY-CPROG` = 현재 호출된(실행 중인) ABAP 프로그램명
</br>

- PBO에서 사용 (서브스크린 지정)
- `INCLUDING` 은 PBO에서만 사용
```abap
CALL SUBSCREEN <subscreen_area>
  INCLUDING <program> <dynpro>.
```
- PAI에서 사용 (입력 처리)
```abap
CALL SUBSCREEN <subscreen_area>.
```
```abap
PROCESS BEFORE OUTPUT.
  CALL SUBSCREEN sub1
    INCLUDING SY-CPROG '0101'.

PROCESS AFTER INPUT.
  CALL SUBSCREEN sub1.
```
</br>
</br>

### < `CALL SUBSCREEN` 예제 >
</br>

**1) 메인 스크린 Layout에 `Subscreen Area` 정의**

<img width="381" height="338" alt="image" src="https://github.com/user-attachments/assets/6c0e373f-b0d1-4018-ad6f-f1ca417b747d" />

</br>
</br>

<img width="407" height="334" alt="image" src="https://github.com/user-attachments/assets/9f55763e-9639-4ce3-82f5-2a5951dfa53e" />
</br>
</br>

- 스크린 생성 시 `Dynpro Type` 을 `Subscreen` 으로 설정
<img width="480" height="314" alt="image" src="https://github.com/user-attachments/assets/642f35c6-806b-4b9a-b02e-38530152fa33" />

</br>
</br>
</br>

**2) Screen 100 에서 모듈 생성**
```abap
PROCESS BEFORE OUTPUT.
 MODULE STATUS_0100.
 MODULE set_subscreen.
 MODULE CLEAR_OK_CODE.

  " SUB 라는 이름의 서브스크린 공간에 서브스크린을 세팅함
  " sy-cprog : 현재 프로그램 이름
  " gv_dynnr : TOP에 추가한 변수이며 '0110' 과 같은 서브스크린 번호가 들어감
  CALL SUBSCREEN SUB
  INCLUDING SY-CPROG gv_dynnr.

PROCESS AFTER INPUT.
 MODULE USER_COMMAND_0100.
   CALL SUBSCREEN SUB.
```
</br>

**3) `TOP` 모듈 생성**
```abap
PROGRAM SAPMZB03006.

DATA: OK_CODE TYPE sy-ucomm.
DATA: RAD1 TYPE C,
      RAD2 TYPE C,
      RAD3 TYPE C VALUE 'X'.
DATA: gv_dynnr TYPE sy-dynnr.
```
</br>

**4) `PAI` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZB03006
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.
  CASE OK_CODE.
    WHEN 'BACK'.
      LEAVE TO SCREEN 0.
    WHEN 'EXIT' OR 'CANCEL'.
      LEAVE PROGRAM.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```
</br>

**5) `PBO` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZB03006
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.
 SET PF-STATUS 'S100'.
 SET TITLEBAR 'T100' WITH sy-uname.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE set_subscreen OUTPUT.
  CASE 'X'.
    WHEN RAD1.
      gv_dynnr = '0110'.
    WHEN RAD2.
      gv_dynnr = '0120'.
    WHEN RAD3.
      gv_dynnr = '0130'.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE clear_ok_code OUTPUT.
  CLEAR OK_CODE.
ENDMODULE.
```
</br>
</br>
</br>

---

</br>

## < Tabstrip (Tab Page) >
- `Tabstrip` = 여러 화면을 탭으로 전환하는 컨트롤
- 탭 제목 = Pushbutton
- 탭 내용 = Subscreen Area + Subscreen Screen
- 실제 데이터/화면 로직은 Subscreen에서 처리
  
</br>

### < Tabstrip(Tab Page) 스크롤링 방식 >
**1) 로컬 스크롤링**
- Tab Page마다 Subscreen Area 각각 보유
- 구조 단순, 탭별 화면·데이터 완전 분리
- Function Type = `P`
  
**2) PAI 스크롤링**
- Tab Page 여러 개 + Subscreen Area 1개 재사용
- 탭 선택 시 PAI에서 서브스크린 교체
- Function Type = 공백(` `)
</br>

- `TOP` 모듈 (컨트롤 선언)
```abap
CONTROLS : <탭스트립명> TYPE TABSTRIP.
```
```abap
CONTROLS: TAB_STRIP TYPE TABSTRIP.
```
- `Screen` 코드 (서브스크린 호출)
```abap
CALL SUBSCREEN <Area명> INCLUDING <프로그램> <스크린번호>.
```
```abap
CALL SUBSCREEN REFSUB1 INCLUDING sy-cprog '110'.
CALL SUBSCREEN REFSUB2 INCLUDING sy-cprog '120'.
CALL SUBSCREEN REFSUB3 INCLUDING sy-cprog '130'.
```
</br>
</br>
</br>
</br>

### 1) 로컬 스크롤링
</br>

**1) Layout에서 tabstrip 생성**

<img width="526" height="352" alt="image" src="https://github.com/user-attachments/assets/7fbe02c8-0a59-4855-822b-31e6b4fb23a1" />
</br>
</br>

- `Tap Title` 로 TAP 개수 정할 수 있음
  
<img width="527" height="325" alt="image" src="https://github.com/user-attachments/assets/e29e8f16-1056-4783-a1d0-64f7c68e703f" />
</br>
</br>
</br>

**2) Layout에서 `FctCode` 와 `FctType` 설정**
- `FctType` 은 **`P`** 로 설정
  
<img width="553" height="325" alt="image" src="https://github.com/user-attachments/assets/1fa73db5-aa96-4b1d-911d-72dbeb5ebb59" />
</br>
</br>
</br>

**3) Layout에서 Tab 안에 Subscreen 넣기**
-  Subscreen area를 추가
-  추가하면 REF 자동으로 할당됨


<img width="553" height="306" alt="image" src="https://github.com/user-attachments/assets/f7dec350-de01-4a2c-84e2-85cbe1543b08" />

</br>
</br>
</br>

**4) `TOP` 모듈 생성**
```abap
PROGRAM SAPMZB03006.

DATA: OK_CODE TYPE sy-ucomm.
DATA: RAD1 TYPE C,
      RAD2 TYPE C,
      RAD3 TYPE C VALUE 'X',
      CHK1 TYPE C,
      CHK2 TYPE C VALUE 'X'.

CONTROLS: TAB_STRIP TYPE TABSTRIP.
```
</br>

**5) `Screen` 에서 모듈 생성**
```abap
PROCESS BEFORE OUTPUT.
 MODULE STATUS_0100.
 MODULE set_subscreen.
 MODULE CLEAR_OK_CODE.

" TAB_STRIP 로컬 스크롤링 버전
  CALL SUBSCREEN REFSUB1 INCLUDING sy-cprog '110'.
  CALL SUBSCREEN REFSUB2 INCLUDING sy-cprog '120'.
  CALL SUBSCREEN REFSUB3 INCLUDING sy-cprog '130'.

PROCESS AFTER INPUT.
 MODULE USER_COMMAND_0100.

" TAB_STRIP 로컬 스크롤링 버전
   CALL SUBSCREEN REFSUB1.
   CALL SUBSCREEN REFSUB2.
   CALL SUBSCREEN REFSUB3.
```
</br>
</br>
</br>
</br>
</br>

### 2) PAI 스크롤링
- `TAB_STRIP-activetab` : 현재 선택된 Tab Page를 저장하는 필드
- `activetab` = 현재 활성화된 탭의 Function Code ( 설정해야 탭 서브스크린에 그려짐 )
</br>

**1) Layout에서 `FctCode` 을 None으로 지정**

<img width="543" height="318" alt="image" src="https://github.com/user-attachments/assets/d875863d-8584-4761-be6e-8483bbf82461" />
</br>
</br>
</br>

**2) 첫 번째 Tab에만 Subscreen 넣기 / 나머지 Tab `Ref` 설정하기**

<img width="547" height="305" alt="image" src="https://github.com/user-attachments/assets/a93ceb3f-b07d-4ef1-a087-9ecfda083457" />
</br>
</br>
</br>

**3) `TOP` 모듈 생성**
```abap
PROGRAM SAPMZB03006.

DATA: OK_CODE TYPE sy-ucomm.
DATA: RAD1 TYPE C,
      RAD2 TYPE C,
      RAD3 TYPE C VALUE 'X',
      CHK1 TYPE C,
      CHK2 TYPE C VALUE 'X'.
DATA: gv_dynnr TYPE sy-dynnr,
      gv_tabdynnr TYPE sy-dynnr.

CONTROLS: TAB_STRIP TYPE TABSTRIP.
```

</br>

**4) `Screen` 에서 모듈 생성**
```abap
PROCESS BEFORE OUTPUT.
 MODULE STATUS_0100.
 MODULE set_subscreen.
 MODULE CLEAR_OK_CODE.
   MODULE set_tabstrip.

   " TAP_STRIP PAI 스크롤링 버전
   CALL SUBSCREEN REFSUB1 INCLUDING sy-cprog gv_tabdynnr.

PROCESS AFTER INPUT.
 MODULE USER_COMMAND_0100.

  " TAP_STRIP PAI 스크롤링 버전
   CALL SUBSCREEN REFSUB1.
```
</br>

**5) `PAI` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZB03006
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.
  CASE OK_CODE.
    WHEN 'BACK'.
      LEAVE TO SCREEN 0.
    WHEN 'EXIT' OR 'CANCEL'.
      LEAVE PROGRAM.
    WHEN '200BUTTON'.
      LEAVE TO SCREEN 200.
    " activetab 속성에 들어가는 값은 Function Code여야 함
    WHEN 'TABFC1' OR 'TABFC2' OR 'TABFC3'.
      tab_strip-activetab = OK_CODE. " 펑션코드 그대로 넣어주면 됨
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```
</br>

**6) `PBO` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZB03006
*&---------------------------------------------------------------------*

MODULE set_tabstrip OUTPUT.
  CASE TAB_STRIP-activetab.
    WHEN 'TABFC1'.
      gv_tabdynnr = '0110'.
    WHEN 'TABFC2'.
      gv_tabdynnr = '0120'.
    WHEN 'TABFC3'.
      gv_tabdynnr = '0130'.
    WHEN OTHERS.
      gv_tabdynnr = '0110'.
      tab_strip-activetab = 'TABFC1'.
  ENDCASE.
ENDMODULE.
```
</br>
</br>
</br>

---

</br>

## < 추가적인 개념 >
</br>

### < 펑션그룹을 활용한 서브스크린 데이터 공유 >
- 서브스크린은 `Function Group` 안에 정의 가능
- 같은 Function Group의 글로벌 데이터(전역변수)를 서브스크린에서 직접 사용 가능
- PBO/PAI에서 `Function Module` 호출로 데이터 EXPORT / IMPORT 가능
</br>
</br>
</br>

### < Maintenance View 에서 TCODE 생성 >
**1) SCARR 테이블 복사해서 새 테이블 만들기**

<img width="407" height="298" alt="image" src="https://github.com/user-attachments/assets/216741b5-5d23-4bd5-b1e4-ac7a49400ff7" />

</br>
</br>

**2) Maintenance View 설정**

<img width="430" height="382" alt="image" src="https://github.com/user-attachments/assets/17be6231-9dc9-4ecd-923c-134dd9d1320e" />

</br>
</br>

<img width="556" height="246" alt="image" src="https://github.com/user-attachments/assets/042332ac-3efb-4e8a-9c56-822f726ad6f4" />
</br>
</br>

**3) Maintenance View `TCODE` 생성**

- `Transaction with parameters` 선택

<img width="465" height="291" alt="image" src="https://github.com/user-attachments/assets/53e1c5af-a876-4adc-94de-8d272dc65fe8" />
</br>
</br>

- `UPDATE = 'X'` → 변경/저장 가능
- `UPDATE 비어 있음` → 조회(Display) 모드
  
<img width="401" height="463" alt="image" src="https://github.com/user-attachments/assets/29ecfcce-9a90-4b5f-9771-679496e1e7ca" />

</br>
</br>
</br>

---

</br>

## < 실습 코드 >
</br>

### 실습 1
</br>

- 문제
  
<img width="391" height="234" alt="image" src="https://github.com/user-attachments/assets/972bf0b6-b73c-4140-a8a4-20be7ba81441" />
</br>
</br>
</br>
</br>

**1) 200 Screen Layout 생성**
- 체크 박스 즉시 반응 시키려면 `Function code` 무조건 설정해야 함

<img width="458" height="309" alt="image" src="https://github.com/user-attachments/assets/4022d7d7-b302-46cf-84e8-c7aba5e35552" />
</br>
</br>
</br>
</br>

**2) Screen 코드 수정 및 생성**
- 100 Screen 코드 생성
```abap
PROCESS BEFORE OUTPUT.
 MODULE STATUS_0100.
 MODULE set_subscreen.
 MODULE CLEAR_OK_CODE.

  " SUB 라는 이름의 서브스크린 공간에 서브스크린을 세팅함
  " sy-cprog : 현재 프로그램 이름
  " gv_dynnr : TOP에 추가한 변수이며 '0110' 과 같은 서브스크린 번호가 들어감
  CALL SUBSCREEN SUB
  INCLUDING SY-CPROG gv_dynnr.

PROCESS AFTER INPUT.
 MODULE USER_COMMAND_0100.
   CALL SUBSCREEN SUB.
```
- 200 Screen 코드 생성
```abap
PROCESS BEFORE OUTPUT.
 MODULE STATUS_0200.
 MODULE set_subscreen2.
 MODULE CLEAR_OK_CODE.
   CALL SUBSCREEN SUB2
   INCLUDING sy-cprog gv_dynnr.
*
PROCESS AFTER INPUT.
 MODULE USER_COMMAND_0200.
   CALL SUBSCREEN SUB2.
```
</br>
</br>

**3) `TOP` 모듈 수정**
```abap
PROGRAM SAPMZB03006.

DATA: OK_CODE TYPE sy-ucomm.
DATA: RAD1 TYPE C,
      RAD2 TYPE C,
      RAD3 TYPE C VALUE 'X',
      CHK1 TYPE C,
      CHK2 TYPE C VALUE 'X'.
DATA: gv_dynnr TYPE sy-dynnr.
```
</br>
</br>

**4) `PAI` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZB03006
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.
  CASE OK_CODE.
    WHEN 'BACK'.
      LEAVE TO SCREEN 0.
    WHEN 'EXIT' OR 'CANCEL'.
      LEAVE PROGRAM.
    WHEN '200BUTTON'.
      LEAVE TO SCREEN 200.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE user_command_0200 INPUT.
  CASE OK_CODE.
    WHEN 'BACK'.
      LEAVE TO SCREEN 0.
    WHEN 'EXIT' OR 'CANCEL'.
      LEAVE PROGRAM.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```
</br>
</br>

**5) `PBO` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZB03006
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.
 SET PF-STATUS 'S100'.
 SET TITLEBAR 'T100' WITH sy-uname.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE set_subscreen OUTPUT.
  CASE 'X'.
    WHEN RAD1.
      gv_dynnr = '0110'.
    WHEN RAD2.
      gv_dynnr = '0120'.
    WHEN RAD3.
      gv_dynnr = '0130'.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE set_subscreen2 OUTPUT.
  IF CHK1 = 'X' AND CHK2 = 'X'.
    MESSAGE '입력값이 2개 입니다.' TYPE 'E' DISPLAY LIKE 'I'.
  ELSE.
    CASE 'X'.
      WHEN CHK1.
        gv_dynnr = '0140'.
      WHEN CHK2.
        gv_dynnr = '0150'.
      WHEN OTHERS.
    ENDCASE.
  ENDIF.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE clear_ok_code OUTPUT.
  CLEAR OK_CODE.
ENDMODULE.
```
</br>
</br>

**6) 결과 확인**
- 체크에 따라 서브스크린이 달라짐
  
<img width="469" height="270" alt="image" src="https://github.com/user-attachments/assets/4175ec54-93b6-46f5-b8be-3f8e85984167" />
</br>
</br>
</br>
</br>
</br>

### 실습 2
- 기존 프로그램 코드에서 서브스크린 추가
</br>

**1) 각 스크린의 `Layout` 지정**
- Screen 100
  
<img width="621" height="367" alt="image" src="https://github.com/user-attachments/assets/f16219aa-d986-4b18-95bd-53da8499413d" />
</br>
</br>

- Screen 110
  
<img width="241" height="186" alt="image" src="https://github.com/user-attachments/assets/a401a937-5697-4e15-8a56-c75ec40e87e0" />

</br>
</br>

- Screen 120
  
<img width="227" height="116" alt="image" src="https://github.com/user-attachments/assets/9a03cf31-a18e-43ba-ae37-a353d44bb8eb" />
</br>
</br>

- Screen 130

<img width="176" height="139" alt="image" src="https://github.com/user-attachments/assets/6211cda0-42b1-4b2a-9c0e-fb3f029dec3e" />
</br>
</br>
</br>
</br>

**2) `Screen 100` 에서의 모듈 생성**
```abap
PROCESS BEFORE OUTPUT.
 MODULE STATUS_0100.
 MODULE set_subscreen.
   CALL SUBSCREEN SUB
   INCLUDING sy-cprog gv_tabdynnr.
 MODULE CLEAR_OK_CODE.

PROCESS AFTER INPUT.
  MODULE CHECK_SFLIGHT.
  MODULE USER_COMMAND_0100.
    CALL SUBSCREEN SUB.
```
</br>
</br>

**3) `TOP` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZBC410_SOLUTION_03_02
*&---------------------------------------------------------------------*

TABLES: SDYN_CONN, SPFLI, SCARR, SBOOK.

DATA: exit_button TYPE C,
      OK_CODE TYPE SY-UCOMM,
      gs_data TYPE SDYN_CONN,
      gv_subrc TYPE sy-subrc,
      gv_button TYPE I.

DATA: VIEW TYPE C VALUE 'X',
      MAINTAIN_FLIGHTS TYPE C,
      MAINTAIN_BOOKINGS TYPE C,
      gv_title TYPE I VALUE 1,
      gv_tabdynnr TYPE sy-dynnr.

CONTROLS: MY_TABSTRIP TYPE TABSTRIP.

DATA: gs_spfli TYPE spfli,
      gs_scarr TYPE scarr,
      gs_sbook TYPE sbook.
```
</br>
</br>

**4) 100 Screen `PAI` 모듈 수정**
- CASE문에서는 `OR` 절만 가능
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZBC410_SOLUTION_03_02
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.

  IF exit_button = 'X'.
    LEAVE TO SCREEN 0.
  ELSEIF exit_button = 'T'.
    CALL SCREEN 150
    STARTING AT 5 5
    ENDING AT 50 10.
    CLEAR: exit_button.
  ENDIF.

ENDMODULE.

*----------------------------------------------------------------------*

MODULE check_sflight INPUT.

  CASE OK_CODE.
    WHEN 'FC1' OR 'FC2' OR 'FC3'.
      MY_TABSTRIP-activetab = OK_CODE.
    WHEN 'MODE'.
      CASE 'X'.
        WHEN VIEW.
          gv_title = 1.
        WHEN MAINTAIN_FLIGHTS.
          gv_title = 2.
        WHEN MAINTAIN_BOOKINGS.
          gv_title = 3.
        WHEN OTHERS.
      ENDCASE.
    WHEN 'PUSH'.
      gv_button = 1.

      SELECT SINGLE * FROM sflight
        INTO CORRESPONDING FIELDS OF gs_data
        WHERE carrid = SDYN_CONN-carrid
          AND connid = SDYN_CONN-connid
          AND fldate = SDYN_CONN-fldate.

      SELECT SINGLE * FROM spfli
        INTO CORRESPONDING FIELDS OF gs_spfli
        WHERE carrid = SDYN_CONN-carrid
          AND connid = SDYN_CONN-connid.

      SELECT SINGLE * FROM scarr
        INTO CORRESPONDING FIELDS OF gs_scarr
        WHERE carrid = SDYN_CONN-carrid.

      SELECT SINGLE * FROM sbook
        INTO CORRESPONDING FIELDS OF gs_sbook
        WHERE carrid = SDYN_CONN-carrid
          AND connid = SDYN_CONN-connid
          AND fldate = SDYN_CONN-fldate.

      IF sy-subrc <> 0.
        gv_subrc = 4.
        message text-007 TYPE 'I'.
      ENDIF.
    WHEN OTHERS.
  ENDCASE.

ENDMODULE.

*----------------------------------------------------------------------*

MODULE user_command_0150 INPUT.
  IF OK_CODE = 'BTN01'.
    LEAVE TO SCREEN 0.
  ENDIF.
ENDMODULE.
```
</br>
</br>

**5) 100 Screen `PBO` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Module Pool      SAPMZBC410_SOLUTION_03_02
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.

  SET PF-STATUS 'S100'.

  IF gv_title = 1.
    SET TITLEBAR 'T100' WITH 'View'.
  ELSEIF gv_title = 2.
    SET TITLEBAR 'T100' WITH 'Maintain flights'.
    LOOP AT SCREEN.
      IF screen-name = 'SDYN_CONN-PLANETYPE'.
        screen-input = 1.
      ENDIF.
      MODIFY SCREEN.
    ENDLOOP.
  ELSEIF gv_title = 3.
    SET TITLEBAR 'T100' WITH 'Maintain bookings'.
  ENDIF.

  IF gv_button = 1.
    IF gv_subrc <> 0.
      CLEAR SDYN_CONN.
      gv_subrc = 0.
    ELSE.
      MOVE-CORRESPONDING gs_data TO SDYN_CONN.
    ENDIF.
  ELSE.
    gv_button = 0.
  ENDIF.

ENDMODULE.

*&---------------------------------------------------------------------*

MODULE status_0150 OUTPUT.
 SET PF-STATUS 'S150'.
 SET TITLEBAR 'xxx'.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE clear_ok_code OUTPUT.
  CLEAR: OK_CODE.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE set_subscreen OUTPUT.
  CASE MY_TABSTRIP-activetab.
    WHEN 'FC1'.
      gv_tabdynnr = '0110'.
    WHEN 'FC2'.
      gv_tabdynnr = '0120'.
    WHEN 'FC3'.
      gv_tabdynnr = '0130'.
    WHEN OTHERS.
      gv_tabdynnr = '0110'.
      MY_TABSTRIP-activetab = 'FC1'.
  ENDCASE.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE status_0110 OUTPUT.
  MOVE-CORRESPONDING gs_spfli TO SPFLI.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE status_0120 OUTPUT.
  MOVE-CORRESPONDING gs_scarr TO SCARR.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE status_0130 OUTPUT.
  MOVE-CORRESPONDING gs_sbook TO SBOOK.
ENDMODULE.
```
</br>
</br>

**6) 결과 확인**
- 아래 서브스크린에도 데이터가 뜸

<img width="538" height="341" alt="image" src="https://github.com/user-attachments/assets/2c183bbf-c0dc-49f1-b516-5a79827d846c" />


</br>
</br>


# 12/19
</br>
</br>

## <  핵심 개념 >
</br>

- **1) Search Help (F4 도움말) 설정하기**

</br>

- **`LEAVE TO SCREEN 0`** 같은 화면 전환 명령은 **`PAI`** 에서만
- **`SCREEN-INPUT`** 같은 화면 속성 변경은 **`PBO`** 에서만
- 사용자 입력 기반 SELECT는 **`PAI`** , 조회 결과 화면 반영/속성 변경은 **`PBO`**
- **OK_CODE 초기화** 코드 꼭 넣어줘야 함 ( 보통 **`PBO`** 에서 )
- **`OK_CODE`** 케이스문은 **`PAI`** 에서
- LOOP AT SCREEN 사용시 **`MODIFY SCREEN`** 넣기
- **`FIELD / CHAIN`** 은 무조건 **PAI** 에서만 구현
- **`AT EXIT-COMMAND`** 은 무조건 **PAI** 에서만 구현
- **`AT EXIT-COMMAND`** 는 Screen 코드에서 **맨 위** 에 두는 게 좋음
- **서로 다른 스크린의 버튼** 은 같은 MODULE에서 처리하면 **안됨**
- **즉시 반응** = **`Function Code`** 필수
- **버튼** → **`Function Code`** 만 OK_CODE로 옴
- **라디오·체크** → 보통 **`Name`** 값(X)으로 판단 ( `Function Code` 지정 필수 )
- **`ACTIVETAB`** 은 무조건 **`PBO`** 에서 해야 함
- **`ACTIVETAB`** 값 = 탭의 **`Function Code`**

</br>
</br>

---

</br>

## < Search Help (F4 도움말) >
- F4 Help / Input Help / Value Help / Possible Entry 전부 같은 의미
- 입력 필드 옆 버튼 클릭 시 유효한 값 목록 조회
- 테이블/뷰 기반 + 조건(제한) 걸어서 조회 가능
</br>
</br>

### < Dialog Behavior >
- 조회 전에 조건 입력(Restriction) 다이얼로그 표시 가능
- 조건 입력 → 조회 결과 목록(히트 리스트) 표시
</br>
</br>

### < Search Help 연결 >
- **Dictionary(테이블/구조 필드)** 에 Search Help 연결 → 화면에서 자동 F4 제공 (권장)
- 연결 가능 위치
  - Data Element / Table 필드 / Structure 필드 / Check Table
  - Domain에는 F4(Search Help) 직접 연결 ❌
- Screen Painter에서 직접 연결도 가능하지만 비추천
</br>

- Structure 안의 개별 필드에 Search Help 연결
<img width="597" height="196" alt="image" src="https://github.com/user-attachments/assets/2d59e5d9-6cbb-4ac6-9026-fee832da0165" />
</br>

<img width="594" height="318" alt="image" src="https://github.com/user-attachments/assets/a1976759-8f11-4f58-b03f-5f7a8870530a" />

</br>

- DB Table 안의 개별 필드에 Search Help 연결
  
<img width="562" height="322" alt="image" src="https://github.com/user-attachments/assets/4b7047c7-d893-4475-8cc4-953dba163f14" />
</br>

- Screen 에 Search Help 연결
  
<img width="364" height="328" alt="image" src="https://github.com/user-attachments/assets/798d500a-9a0f-4ca8-b2e8-100fd585897c" />
</br>

- Data element 에 Search Help 연결
<img width="587" height="432" alt="image" src="https://github.com/user-attachments/assets/2d1b75a3-476b-43a1-ac62-79d8f7ebe75f" />
</br>
</br>
</br>
</br>

### < Input Help(F4) 적용 우선순위 >

- **1) Program(화면)**
  - 화면 필드 직접 지정 (최우선)

- **2) Dictionary – Table / Structure 필드**
  - 필드에 Search Help 연결

- **3) Check Table(FK)**
  - Check Table → 텍스트 → 키값

- **4) Data Element**
  - Data Element에 연결된 Search Help

- **5) Domain**
  - Fixed Values 목록

- **6) 날짜/시간**
  - Calendar / Clock 자동 제공

<img width="464" height="296" alt="image" src="https://github.com/user-attachments/assets/f88d9d3c-8fa0-4471-9044-e2f60e0a5e1b" />
</br>
</br>
</br>
</br>

### < Search Help 생성 예제 >
**1) Search Help 생성**
  
- `Selection Method`
    
  - Table 또는 View 지정
  - F4 조회 시 데이터를 가져오는 대상
- `Dialog Type`

  - `System-dependent` : 데이터 양에 따라 시스템이 자동 판단. 바로 결과 or 조건 화면 중 선택.
  - `Display values immediately` : 조건 없이 즉시 조회 결과 출력.
  - `Display restriction dialog` : 조회 조건 입력 화면 먼저 출력.
- `Parameter` 설정

  - Search Help에서 사용하는 필드 정의
  - `IMP` : 화면 값 → Search Help로 전달 (조회 조건)
  - `EXP` : Search Help 선택 값 → 화면으로 반환
  - `LPOS (List Position)` → 결과 리스트에 표시되는 순서
  - `SPOS (Selection Position)` → 조회조건(Restriction) 화면에 표시되는 순서
</br>

<img width="329" height="104" alt="image" src="https://github.com/user-attachments/assets/cccc53b0-5bed-4eea-94ec-20e24ed826c0" />
</br>

<img width="577" height="344" alt="image" src="https://github.com/user-attachments/assets/1cf7d842-4c95-41c2-b602-7922949e575a" />

</br>
</br>
</br>
</br>

**2) DB Table에 Search Help 설정**
- 원하는 필드 선택 후에 `Search Help` 버튼 클릭

<img width="592" height="201" alt="image" src="https://github.com/user-attachments/assets/ea73a953-873d-47b1-a836-b49a1ff16ee3" />
</br>
</br>

<img width="410" height="98" alt="image" src="https://github.com/user-attachments/assets/0f15a1ea-c88b-4c70-9ce4-e14b830ee483" />
</br>
</br>

<img width="391" height="266" alt="image" src="https://github.com/user-attachments/assets/88907ec1-4d5c-4214-a709-281ee8b12ad0" />
</br>
</br>

- 설정된 것을 확인
<img width="593" height="191" alt="image" src="https://github.com/user-attachments/assets/af75078c-a3d8-41da-8317-fd39b3ee03a3" />
</br>
</br>
</br>
</br>

**3) Search Help 에서 제안 기능 활성화 가능**
- `Enhanced Options` : 입력하면서 자동으로 추천·검색을 도와주는 기능
  
<img width="597" height="338" alt="image" src="https://github.com/user-attachments/assets/5f5e7db7-3009-4ad0-af0b-9573ea0972cc" />

</br>
</br>

<img width="417" height="238" alt="image" src="https://github.com/user-attachments/assets/de6386ef-a61f-45d1-a742-e565fa3ebd3e" />

</br>
</br>

---
</br>

---

</br>
</br>

# 12/23
</br>
</br>

## <  핵심 개념 >
</br>

- **1) ABAP 이벤트**
- **2) Selection Screen - Selection Screen Block / Selection Screen Lines**
- **3) AT SELECTION-SCREEN ON <field>**
- **4) Selection Screen 서브스크린(Subscreen) & 탭스트립(Tabstrip)**
- **5) Message Class**
- **6) Variant**

</br>
</br>

---

</br>

## < Selection Screen >
- **프로그램 실행 시 표준 선택화면(Screen 1000) 자동 생성**
```abap
PARAMETERS: ...
SELECT-OPTIONS: ...
```
- **직접 번호를 지정한 사용자 정의 Selection Screen 생성**
```abap
SELECTION-SCREEN BEGIN OF SCREEN <no>.
  PARAMETERS ...
  SELECT-OPTIONS ...
SELECTION-SCREEN END OF SCREEN <no>.
```
```abap
*************** TOP ****************
SELECTION-SCREEN BEGIN OF SCREEN 1100.
  PARAMETERS: p_name TYPE string.
  SELECT-OPTIONS: s_date FOR sy-datum.
SELECTION-SCREEN END OF SCREEN 1100.
```
</br>
</br>

### 1) ABAP 이벤트 
- `LOAD-OF-PROGRAM` : 프로그램이 메모리에 로드될 때 한 번 실행됨
- `INITIALIZATION` : Selection Screen이 처음 뜨기 전에 초기값을 설정함
- `AT SELECTION-SCREEN OUTPUT (PBO)` : Selection Screen이 그려질 때마다 실행되어 화면을 제어함
- `AT SELECTION-SCREEN (PAI)` : 사용자가 Enter나 실행을 누를 때 입력값을 검사함
- `START-OF-SELECTION` : Selection Screen을 통과한 후 본 처리 로직이 시작됨
```abap
LOAD-OF-PROGRAM
→ INITIALIZATION
→ AT SELECTION-SCREEN OUTPUT   (PBO)
→ [Selection Screen 표시]
→ AT SELECTION-SCREEN          (PAI)
→ START-OF-SELECTION
```
```abap
*************** E01 ****************
LOAD-OF-PROGRAM.
  "프로그램 로딩 시 1회 실행

INITIALIZATION.
  p_carr = 'AA'.   "초기값 세팅

AT SELECTION-SCREEN OUTPUT.   "PBO
  LOOP AT SCREEN.
    IF screen-group1 = 'A1'.
      screen-active = 0.
    ENDIF.
    MODIFY SCREEN.
  ENDLOOP.

AT SELECTION-SCREEN.          "PAI
  IF p_carr IS INITIAL.
    MESSAGE '필수 입력값 누락' TYPE 'E'.
  ENDIF.

START-OF-SELECTION.
  PERFORM get_data.
```
</br>
</br>

### 2) SELECT-OPTIONS
- `SELECT-OPTIONS` → 범위 입력용 선택 조건
- `SELECT-OPTIONS` 는 헤더라인이 있는 내부 테이블이므로 `INTO` 생략 가능
- 내부적으로 `SIGN / OPTION / LOW / HIGH` 구조
```abap
*************** TOP ****************
SELECT-OPTIONS so_carr FOR sflight-carrid.

*************** E01 ****************
INITIALIZATION.
  MOVE: 'I'  TO so_carr-sign,
        'BT' TO so_carr-option,
        'AA' TO so_carr-low,
        'LH' TO so_carr-high.
  APPEND so_carr.
  CLEAR so_carr.

  MOVE: 'E'  TO so_carr-sign,
        'EQ' TO so_carr-option,
        'DL' TO so_carr-low.
  APPEND so_carr.
```
- `SELECT-OPTIONS`는 데이터베이스 테이블 필드를 직접 참조할 수 없고, 해당 필드가 포함된 이미 선언된 변수(Work Area 또는 Structure)의 필드를 통해 참조해야 함

```abap
SELECT-OPTIONS <seltab> FOR <field>
  [DEFAULT <value>]
  [DEFAULT <value1> TO <value2>]
  [SIGN <I|E> OPTION <op>]
  [MEMORY ID <pid>]
  [LOWER CASE]
  [OBLIGATORY]
  [NO-EXTENSION]
  [NO INTERVALS]
  [MODIF ID <mod>].
```
```abap
*************** TOP ****************
SELECT-OPTIONS so_car FOR sflight-carrid
  DEFAULT 'AA'                 "초기값 AA
  SIGN I OPTION EQ             "포함(I), 같음(EQ)
  MEMORY ID CAR                "이전 입력값 자동 불러오기
  OBLIGATORY                   "필수 입력
  NO-EXTENSION                 "다중 선택 버튼 비활성화
  NO INTERVALS                 "from~to 범위 입력 금지
  MODIF ID A1.                 "화면 제어용 그룹 ID
```

- SIGN : `I` - 포함, `E` - 제외
  
| ABAP OPTION 값 | 의미 (Meaning) | LOW/HIGH 사용 | SQL 연산자 개념 |
| :---: | :--- | :---: | :---: |
| **`EQ`** | Equal (같음) | `LOW` 값만 사용 | `fieldName = LOW` |
| **`BT`** | Between (사이) | `LOW`와 `HIGH` 값 모두 사용 | `fieldName BETWEEN LOW AND HIGH` |
| **`GE`** | Greater or Equal (크거나 같음) | `LOW` 값만 사용 | `fieldName >= LOW` |
| **`LE`** | Less or Equal (작거나 같음) | `LOW` 값만 사용 | `fieldName <= LOW` |
| **`GT`** | Greater Than (초과) | `LOW` 값만 사용 | `fieldName > LOW` |
| **`LT`** | Less Than (미만) | `LOW` 값만 사용 | `fieldName < LOW` |
| **`CP`** | Contains Pattern (패턴 포함) | `LOW` 값만 사용 (`*`, `?` 등 사용) | `fieldName LIKE LOW` |
| **`NE`** | Not Equal (같지 않음) | `LOW` 값만 사용 | `fieldName != LOW` (또는 `NOT =`) |
| **`NP`** | Not Contains Pattern (패턴 불일치) | `LOW` 값만 사용 | `NOT (fieldName LIKE LOW)` |

</br>
</br>

### 3) Selection Screen Block
- `Selection Screen` 을 **논리적인 그룹(박스)** 으로 묶어 화면을 보기 좋게 구성
- `WITH FRAME` 를 쓰면 테두리 박스가 생김
- TITLE로 블록 제목 표시 가능
- 블록 안에는 PARAMETERS, SELECT-OPTIONS 모두 배치 가능
```abap
SELECTION-SCREEN BEGIN OF BLOCK <block>
  [WITH FRAME [TITLE <text>]].

  " PARAMETERS / SELECT-OPTIONS 선언

SELECTION-SCREEN END OF BLOCK <block>.
```
```abap
*************** TOP ****************
SELECTION-SCREEN BEGIN OF BLOCK limit
  WITH FRAME TITLE text-001.

PARAMETERS:
  pa_lim_1 RADIOBUTTON GROUP lim DEFAULT 'X',
  pa_lim_2 RADIOBUTTON GROUP lim,
  pa_lim_3 RADIOBUTTON GROUP lim.

SELECTION-SCREEN END OF BLOCK limit.
```
</br>
</br>

### 4) Selection Screen Lines
- Selection Screen에서 여러 필드를 한 줄(row)에 나란히 배치하기 위한 문법
- 라벨(COMMENT), 위치(POSITION), 입력필드(PARAMETERS)를 한 줄로 묶음
```abap
SELECTION-SCREEN BEGIN OF LINE.
  SELECTION-SCREEN COMMENT <pos>(<len>) <text> [FOR FIELD <field>].
  SELECTION-SCREEN POSITION <pos>.
  PARAMETERS <p> ...
SELECTION-SCREEN END OF LINE.
```
- `BEGIN OF LINE / END OF LINE` → 같은 줄에 화면 요소 배치
- `COMMENT pos(len) text` → 화면에 설명 텍스트 출력
- `FOR FIELD <field>` → 해당 입력 필드와 텍스트 연결
- `POSITION pos` → 출력 시작 위치 직접 지정
```abap
*************** TOP ****************
SELECTION-SCREEN BEGIN OF LINE.

  SELECTION-SCREEN COMMENT 1(20) text-s03.
  SELECTION-SCREEN COMMENT pos_low(8) text-s04 FOR FIELD pa_col.
  PARAMETERS pa_col AS CHECKBOX.
  SELECTION-SCREEN COMMENT pos_high(8) text-s05.
  PARAMETERS pa_ico AS CHECKBOX.

SELECTION-SCREEN END OF LINE.
```
</br>
</br>

### 5) AT SELECTION-SCREEN ON <field>

- Selection Screen 전체 Enter / 실행 시 호출
- 전체 입력값 공통 체크
```abap
`AT SELECTION-SCREEN`
```
- 특정 입력 필드 하나만 검사
- 그 필드 값이 바뀌거나 Enter 시 실행
```abap
AT SELECTION-SCREEN ON <field>
```
```abap
*************** TOP ****************
SELECTION-SCREEN BEGIN OF SCREEN 1100.
PARAMETERS:
  pa_cus AS CHECKBOX,
  pa_agy AS CHECKBOX.
SELECTION-SCREEN END OF SCREEN 1100.

*************** E01 ****************
AT SELECTION-SCREEN ON pa_add.
  IF pa_add = 'X'.
    CALL SELECTION-SCREEN 1100
      STARTING AT 5 5
      ENDING   AT 50 10.

    IF sy-subrc <> 0.
      LEAVE TO SCREEN 1000.
    ENDIF.
  ENDIF.
```
- SELECT-OPTIONS 전체 라인(low/high) 검사
```abap
AT SELECTION-SCREEN ON <select-options>
```
- 라디오버튼 그룹 중 선택 상태 검사
```abap
AT SELECTION-SCREEN ON RADIOBUTTON GROUP <grp>
```
- 블록 안의 입력값 전체를 한 번에 검사
```abap
AT SELECTION-SCREEN ON BLOCK <block>
```
- Selection Screen에서 특정 필드에서 F1(Help) 를 눌렀을 때 실행되는 이벤트
```abap
AT SELECTION-SCREEN ON HELP-REQUEST FOR <field>
```
```abap
PARAMETERS pa_carr TYPE sflight-carrid.

AT SELECTION-SCREEN ON HELP-REQUEST FOR pa_carr.
  CALL SCREEN 100
    STARTING AT 5 5.
```
</br>
</br>

### 6) Selection Screen 서브스크린 & 탭스트립
- 서브스크린 코드 형식
```abap
SELECTION-SCREEN BEGIN OF SCREEN <subscreen_number> AS SUBSCREEN.
  PARAMETERS / SELECT-OPTIONS <input_field>.
SELECTION-SCREEN END OF SCREEN <subscreen_number>.
```
- 탭스트립 코드 형식
```abap
SELECTION-SCREEN BEGIN OF TABBED BLOCK <tab_block_name> FOR <number_of_lines> LINES.

  SELECTION-SCREEN TAB (<max_tab_text_length>) <tab_text_variable>
    USER-COMMAND <ok_code> DEFAULT SCREEN <subscreen_number>.

SELECTION-SCREEN END OF BLOCK <tab_block_name>.
```
- 탭스트립 초기 활성 탭 / 서브스크린 지정
```abap
<tab_block_name>-activetab = '<ok_code>'.
<tab_block_name>-dynnr     = '<subscreen_number>'.
```
```abap
*************** TOP ****************
SELECTION-SCREEN BEGIN OF SCREEN 101 AS SUBSCREEN.
  SELECT-OPTIONS so_carr FOR spfli-carrid.
SELECTION-SCREEN END OF SCREEN 101.

SELECTION-SCREEN BEGIN OF SCREEN 102 AS SUBSCREEN.
  PARAMETERS pa_date TYPE sy-datum.
SELECTION-SCREEN END OF SCREEN 102.

SELECTION-SCREEN BEGIN OF SCREEN 103 AS SUBSCREEN.
  PARAMETERS pa_flag AS CHECKBOX.
SELECTION-SCREEN END OF SCREEN 103.


SELECTION-SCREEN BEGIN OF TABBED BLOCK tab_strip FOR 5 LINES.
  SELECTION-SCREEN TAB (20) tab1
    USER-COMMAND COMM1 DEFAULT SCREEN 101.

  SELECTION-SCREEN TAB (20) tab2
    USER-COMMAND COMM2 DEFAULT SCREEN 102.

  SELECTION-SCREEN TAB (20) tab3
    USER-COMMAND COMM3 DEFAULT SCREEN 103.
SELECTION-SCREEN END OF BLOCK tab_strip.


*************** E01 ****************
INITIALIZATION.
  tab1 = 'Carrier'.
  tab2 = 'Date'.
  tab3 = 'Option'.

  tab_strip-activetab = 'COMM1'.
  tab_strip-dynnr     = '0101'.
```
</br>
</br>

### 7) Variant
- Selection Screen 입력값을 저장해두고 재사용하는 실행 조건
<img width="472" height="390" alt="image" src="https://github.com/user-attachments/assets/e64f958c-25d6-4824-b7b5-8d6f30db8eda" />
</br>

<img width="485" height="214" alt="image" src="https://github.com/user-attachments/assets/f9b18ff3-9c06-44f2-816b-00880e01fc90" />
</br>
</br>

- DB Table 에서도 Variant 생성 가능
<img width="485" height="339" alt="image" src="https://github.com/user-attachments/assets/d0f76d8f-7a8f-4fb1-8e10-d3b6f24545eb" />
</br>

<img width="485" height="360" alt="image" src="https://github.com/user-attachments/assets/c722b5e3-a61d-496a-b57f-c0f17f39d7fa" />
</br>
</br>

- 삭제 가능
<img width="481" height="215" alt="image" src="https://github.com/user-attachments/assets/242e7596-1590-466d-8ea3-fe423286c99c" />

</br>
</br>
</br>

---

</br>

## < ABAP 기본 문법 >
</br>

### 1) WRITE 추가 옵션
- `WRITE AT` : 위치 지정 출력 모드 선언
- `<pos>(<len>)` : 출력 시작 열과 길이 지정
- `COLOR <color>` : 출력 색상 지정
- `CURRENCY <f>` : 금액을 통화 단위에 맞게 포맷 출력
```abap
WRITE AT: / <pos>(<len>) <field>
          COLOR <color>
          CURRENCY <currency_field>.
```
```abap
*************** TOP ****************
CONSTANTS: gc_pos     TYPE i VALUE 12,
           gc_len     TYPE i VALUE 10,
           gc_len_pri TYPE i VALUE 15,
           gc_len_cur TYPE i VALUE 5.

WRITE AT: / sy-line,
          gc_pos(gc_len) gs_sflight-fldate COLOR COL_KEY,
          (gc_len_pri)   gs_sflight-price  CURRENCY gs_sflight-currency,
          (gc_len_cur)   gs_sflight-currency.
```
</br>

- `NO-GAP` → 필드 뒤에 출력되는 공백 제거
- `NO-ZERO` → 값이 0이면 공백 출력, 선행 0을 공백으로 치환
- `DD/MM/YY` → 날짜 출력 형식(일/월/년) 지정
- `CURRENCY <currency_key>` → 통화 키 기준으로 금액 포맷 적용 (TCURX 기준)
- `UNIT <unit_key>` → 단위 키 기준으로 수량 포맷 적용 (T006 기준)
- `USING EDIT MASK <mask>` → 지정한 편집 마스크 형식으로 출력
- `UNDER <g>` → <g> 필드가 출력된 열 아래에서 출력 시작
- `LEFT-JUSTIFIED` → 왼쪽 정렬 (C, N, D, T, X 기본)
- `CENTERED` → 출력 길이 기준 가운데 정렬
- `RIGHT-JUSTIFIED` → 오른쪽 정렬 (숫자 타입 기본)
```abap
WRITE [AT /<pos>(<len>)] <field>
      [NO-GAP]
      [NO-ZERO]
      [DD/MM/YY]
      [CURRENCY <currency_key>]
      [UNIT <unit_key>]
      [USING EDIT MASK <mask>]
      [UNDER <g>]
      [LEFT-JUSTIFIED | CENTERED | RIGHT-JUSTIFIED].
```
```abap
DATA: gv_char TYPE c LENGTH 5 VALUE 'ABC',
      gv_num  TYPE n LENGTH 4 VALUE '0004',
      gv_date TYPE d VALUE sy-datum,
      gv_amt  TYPE p DECIMALS 2 VALUE '1234.50',
      gv_qty  TYPE p DECIMALS 1 VALUE '10.0'.

WRITE AT: / 1(10)  gv_char NO-GAP,
          12(10)   gv_num  NO-ZERO,
          23(10)   gv_date DD/MM/YY,
          35(15)   gv_amt  CURRENCY 'KRW',
          52(10)   gv_qty  UNIT 'EA',
          / 1(10)  gv_amt  USING EDIT MASK '__,___',
          / 1(10)  gv_char UNDER gv_char,
          / 1(10)  gv_char LEFT-JUSTIFIED,
          / 1(10)  gv_char CENTERED,
          / 1(10)  gv_char RIGHT-JUSTIFIED.
```
</br>
</br>

### 2) PARAMETERS
- `OBLIGATORY` : 필수 입력값
- `LOWER CASE` : 소문자 입력 허용
- `VALUE CHECK` : 도메인/서치헬프 기준으로 입력값 유효성 자동 검사
- `MEMORY ID <pid>` : 이전에 입력했던 값을 SAP 메모리에서 자동 불러옴
- `MODIF ID <mod>` : 같은 MODIF ID끼리 묶어 화면 활성/비활성 등 동적 제어에 사용 (그룹핑)
```abap
PARAMETERS <f>
  [TYPE <type> | LIKE <f1>]
  [DECIMALS <n>]
  [OBLIGATORY]
  [DEFAULT <value>]
  [LOWER CASE]
  [VALUE CHECK]
  [AS CHECKBOX]
  [RADIOBUTTON GROUP <grp>]
  [MEMORY ID <pid>]
  [MODIF ID <mod>].
```
```abap
*************** TOP ****************
PARAMETERS: pa_carr TYPE sflight-carrid MEMORY ID CAR OBLIGATORY,
            pa_name AS CHECKBOX DEFAULT 'X',
            pa_curr AS CHECKBOX DEFAULT 'X',
            pa_lim1 RADIOBUTTON GROUP lim DEFAULT 'X',
            pa_lim2 RADIOBUTTON GROUP lim,
            pa_lim3 RADIOBUTTON GROUP lim,
            pa_price TYPE p DECIMALS 2 DEFAULT '500',
            pa_text TYPE string LOWER CASE.

CONSTANTS gc_mark VALUE 'X'.

IF pa_name EQ gc_mark.
  " Output name
ENDIF.

CASE gc_mark.
  WHEN pa_lim1.
  WHEN pa_lim2.
  WHEN pa_lim3.
ENDCASE.
```
</br>
</br>

### 3) SELECTION-SCREEN SKIP
- Selection Screen에서 빈 줄(여백)을 추가해서 화면을 보기 좋게 만듦
- <n> 생략 시 → 1줄, <n> 지정 시 → n줄
```abap
SELECTION-SCREEN SKIP [<n>].
```
```abap
*************** TOP ****************
SELECTION-SCREEN SKIP 2.
```
</br>
</br>

### 4) CHECK 조건식
- 조건이 참이면 계속 진행, 거짓이면 즉시 현재 처리 블록 종료
```abap
CHECK <조건식>.
```
```abap
LOOP AT gt_data INTO gs_data.
  CHECK gs_data-status = 'A'.        " status ≠ 'A' 인 데이터는 자동으로 건너뜀
  WRITE: / gs_data-id.
ENDLOOP.
```
</br>
</br>

---

</br>

## < 모듈풀 프로그램 카피 방법 >
- 이름 다르게 설정해야 함
  
<img width="279" height="112" alt="image" src="https://github.com/user-attachments/assets/4349df47-c2dc-4617-a1e9-66967b391097" />

</br>

<img width="299" height="204" alt="image" src="https://github.com/user-attachments/assets/5ca4ac8e-7abc-404d-a8ea-3b99dfce6222" />
</br>

<img width="450" height="250" alt="image" src="https://github.com/user-attachments/assets/07819a3b-7694-4b4f-a43f-c7c919b9abee" />
</br>
</br>

---

</br>

## < 실습 코드 >
</br>

### 실습 1
- program 27에서 진행
- Selection screen
- AT SELECTION-SCREEN ON <field>
- Selection Screen 서브스크린 & 탭스트립
- Message Class & Variant
- HELP-REQUEST 사용 (특정 필드에서 F1(Help) 를 눌렀을 때 실행되는 이벤트)
</br>

- Program 코드에 `TOP` , `E01` 모듈 생성
```abap
REPORT ZPROGB03_0027.

INCLUDE ZPROGB03_0027_TOP.
INCLUDE ZPROGB03_0027_E01.
```
- `TOP` 모듈 생성
```abap
*&---------------------------------------------------------------------*
*& Include          ZPROGB03_0027_TOP
*&---------------------------------------------------------------------*

DATA: gs_flight TYPE dv_flights,
      gt_flight TYPE TABLE OF dv_flights.

PARAMETERS: pa_carr LIKE gs_flight-carrid DEFAULT 'AA',
            pa_conn TYPE s_conn_id MEMORY ID con.

SELECTION-SCREEN SKIP 2. "두줄 띄우기

SELECTION-SCREEN BEGIN OF BLOCK blk1 WITH FRAME TITLE TEXT-001.

  PARAMETERS: pa_rad1 RADIOBUTTON GROUP rad,
              pa_rad2 RADIOBUTTON GROUP rad DEFAULT 'X',
              pa_rad3 RADIOBUTTON GROUP rad.
  SELECT-OPTIONS: so_car FOR gs_flight-carrid DEFAULT 'AA' TO 'LH' OPTION BT SIGN E,
                  so_con FOR gs_flight-connid DEFAULT '0017' NO-EXTENSION. " NO INTERVALS

SELECTION-SCREEN END OF BLOCK blk1.

SELECTION-SCREEN BEGIN OF BLOCK blk2 WITH FRAME.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(8) TEXT-002.
    PARAMETERS: pa_name AS CHECKBOX DEFAULT 'X'.
    SELECTION-SCREEN COMMENT 20(8) TEXT-003.
    PARAMETERS: pa_curr AS CHECKBOX.
  SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN END OF BLOCK blk2.

SELECTION-SCREEN BEGIN OF SCREEN 101 AS SUBSCREEN.
  SELECT-OPTIONS: so_fdt FOR gs_flight-fldate.
SELECTION-SCREEN END OF SCREEN 101.

SELECTION-SCREEN BEGIN OF SCREEN 102 AS SUBSCREEN.
  PARAMETERS: pa_chk1 AS CHECKBOX.
SELECTION-SCREEN END OF SCREEN 102.

SELECTION-SCREEN BEGIN OF SCREEN 103 AS SUBSCREEN.
  PARAMETERS: pa_chk2 AS CHECKBOX.
SELECTION-SCREEN END OF SCREEN 103.

"TAB STRIP + Sub screen 추가
SELECTION-SCREEN BEGIN OF TABBED BLOCK tab_strip FOR 5 LINES.
  SELECTION-SCREEN TAB (20) TEXT-SB1
    USER-COMMAND comm1 DEFAULT SCREEN 101.
  SELECTION-SCREEN TAB (20) TEXT-SB2
    USER-COMMAND comm2 DEFAULT SCREEN 102.
  SELECTION-SCREEN TAB (20) TEXT-SB3
    USER-COMMAND comm3 DEFAULT SCREEN 103.
SELECTION-SCREEN END OF BLOCK tab_strip.
```
- `E01` 모듈 생성
```abap
*&---------------------------------------------------------------------*
*& Include          ZPROGB03_0027_E01
*&---------------------------------------------------------------------*

INITIALIZATION.
  so_car-sign = 'I'.
  so_car-option = 'BT'.
  so_car-low = 'AA'.
  so_car-high = 'AZ'.
  APPEND so_car.

  CLEAR so_car. " Header (Structure)만 클리어됨
  so_car-sign = 'E'.
  so_car-option = 'EQ'.
  so_car-low = 'LH'.
  APPEND so_car.

  tab_strip-activetab ='COMM3'.
  tab_strip-dynnr = '0103'. " 초기 스크린 설정

*AT SELECTION-SCREEN ON pa_carr.
*  IF pa_carr IS INITIAL.
*    MESSAGE e003(zmcb03).
*  ENDIF.

AT SELECTION-SCREEN ON so_car.
  IF so_car IS INITIAL.
    MESSAGE e003(zmcb03).
  ENDIF.

AT SELECTION-SCREEN ON RADIOBUTTON GROUP rad.
  IF pa_rad1 = 'X'.
    MESSAGE e003(zmcb03).
  ENDIF.

AT SELECTION-SCREEN ON BLOCK blk1.
  IF pa_rad3 = 'X' AND so_con IS NOT INITIAL.
    MESSAGE e003(zmcb03).
  ENDIF.

AT SELECTION-SCREEN ON HELP-REQUEST FOR pa_carr.
  CALL SCREEN 100 STARTING AT 5 5.

START-OF-SELECTION.

  SELECT *
    FROM dv_flights
    INTO TABLE gt_flight
    WHERE carrid = 'AA'
      AND connid = '0017'.

  IF sy-subrc = 0.
    LOOP AT gt_flight INTO gs_flight.
      WRITE:/ gs_flight-carrid,
              gs_flight-connid,
              gs_flight-fldate,
              gs_flight-cityfrom,
              gs_flight-cityto.
    ENDLOOP.
  ENDIF.
```
- 결과 확인
<img width="454" height="248" alt="image" src="https://github.com/user-attachments/assets/30389e0a-7f6a-482b-a2c7-946649622acc" />
</br>

<img width="287" height="208" alt="image" src="https://github.com/user-attachments/assets/94fd9122-9436-43d6-8084-4d3dd75ac8fa" />
</br>

<img width="463" height="333" alt="image" src="https://github.com/user-attachments/assets/daef5024-c8bb-478d-8fe2-00ed21c31262" />

</br>
</br>
</br>
</br>

### 실습 2
- Selection screen 예제
- 라디오버튼에 따라 조건에 맞는 all / 국제선 / 국내선 조회 프로그램
</br>

- Program 코드에 `TOP` , `E01` 모듈 생성
```abap
REPORT ZBC400_B03_PRACTICE4.

INCLUDE ZBC400_B03_PRACTICE4_TOP.
INCLUDE ZBC400_B03_PRACTICE4_E01.
```
- `TOP` 모듈 생성
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_B03_PRACTICE4_TOP
*&---------------------------------------------------------------------*

DATA: gs_flight TYPE dv_flights,
      gt_flight TYPE TABLE OF dv_flights.

SELECT-OPTIONS: so_car FOR gs_flight-carrid MEMORY ID car,
                so_con FOR gs_flight-connid,
                so_dat FOR gs_flight-fldate NO-EXTENSION.

SELECTION-SCREEN BEGIN OF BLOCK blk1 WITH FRAME.
  PARAMETERS: pa_all RADIOBUTTON GROUP rad,
              pa_nat RADIOBUTTON GROUP rad,
              pa_int RADIOBUTTON GROUP rad DEFAULT 'X'.
SELECTION-SCREEN END OF BLOCK blk1.
```
- `E01` 모듈 생성
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_B03_PRACTICE4_E01
*&---------------------------------------------------------------------*

INITIALIZATION.
  so_car-sign = 'I'.
  so_car-option = 'BT'.
  so_car-low = 'AA'.
  so_car-high = 'QZ'.
  APPEND so_car.

  CLEAR so_car.
  so_car-sign = 'E'.
  so_car-option = 'EQ'.
  so_car-low = 'AZ'.
  APPEND so_car.

START-OF-SELECTION.
  CASE 'X'.
    WHEN pa_all.
      SELECT * FROM dv_flights
        INTO TABLE gt_flight
        WHERE carrid IN so_car
          AND connid IN so_con
          AND fldate IN so_dat.
    WHEN pa_nat.
      SELECT * FROM dv_flights
        INTO TABLE gt_flight
        WHERE carrid IN so_car
          AND connid IN so_con
          AND fldate IN so_dat
          AND countryto <> dv_flights~countryfr.
    WHEN pa_int.
      SELECT * FROM dv_flights
        INTO TABLE gt_flight
        WHERE carrid IN so_car
          AND connid IN so_con
          AND fldate IN so_dat
          AND countryto = dv_flights~countryfr.
    WHEN OTHERS.
  ENDCASE.

  LOOP AT gt_flight INTO gs_flight.
    WRITE:/ gs_flight-carrid,
            gs_flight-connid,
            gs_flight-fldate,
            gs_flight-countryfr,
            gs_flight-cityfrom,
            gs_flight-airpfrom,
            gs_flight-countryto,
            gs_flight-cityto,
            gs_flight-airpto,
            gs_flight-price,
            gs_flight-currency,
            gs_flight-seatsmax,
            gs_flight-seatsocc.
  ENDLOOP.
```
- 결과 확인

<img width="436" height="162" alt="image" src="https://github.com/user-attachments/assets/02267c6c-8889-4516-9d8a-1c7fdb2c8bb9" />

</br>

<img width="565" height="204" alt="image" src="https://github.com/user-attachments/assets/b694d73b-55ca-4b64-8327-79d87c8aa313" />
</br>
</br>
</br>
</br>

### 실습 3
- 서브스크린과 탭스크린 실습
- 실습 2 에서 이어서 진행
</br>

- `TOP` 모듈 수정
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_B03_PRACTICE4_TOP
*&---------------------------------------------------------------------*

DATA: gs_flight TYPE dv_flights.

PARAMETERS: pa_name TYPE c LENGTH 3.
SELECT-OPTIONS: so_car FOR gs_flight-carrid,
                so_con FOR gs_flight-connid.

SELECTION-SCREEN SKIP 2.

SELECTION-SCREEN BEGIN OF BLOCK blk1 WITH FRAME TITLE TEXT-001.
  SELECTION-SCREEN SKIP 2.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(15) TEXT-003.
    SELECTION-SCREEN COMMENT 35(10) TEXT-004 FOR FIELD pa_abap.
    PARAMETERS: pa_abap AS CHECKBOX.
    SELECTION-SCREEN COMMENT 60(10) TEXT-005 FOR FIELD pa_fiori.
    PARAMETERS: pa_fiori AS CHECKBOX.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN SKIP 2.
  SELECTION-SCREEN BEGIN OF BLOCK blk2 WITH FRAME TITLE TEXT-002.
    PARAMETERS: pa_all RADIOBUTTON GROUP rad,
                pa_nat RADIOBUTTON GROUP rad,
                pa_int RADIOBUTTON GROUP rad DEFAULT 'X'.
  SELECTION-SCREEN END OF BLOCK blk2.
SELECTION-SCREEN END OF BLOCK blk1.
```
- `E01` 모듈 수정
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_B03_PRACTICE4_E01
*&---------------------------------------------------------------------*

tab_strip-activetab = 'comm2'.
tab_strip-dynnr = '1200'.
```
- 결과 확인
  
<img width="550" height="148" alt="image" src="https://github.com/user-attachments/assets/9f69be33-2db6-4d5f-b09a-e3fec3bb8ca4" />
</br>

<img width="540" height="206" alt="image" src="https://github.com/user-attachments/assets/c56cb335-aa82-413e-a355-33e8dd5c5a07" />
</br>
</br>
</br>
</br>

### 실습 4
- Message Class, Variant 예제
- 실습 3 에서 이어서 진행
</br>

- `TOP` 모듈 수정
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_B03_PRACTICE4_TOP
*&---------------------------------------------------------------------*

SELECTION-SCREEN BEGIN OF SCREEN 1300 AS SUBSCREEN.
  SELECTION-SCREEN BEGIN OF BLOCK blk.
    PARAMETERS: pa_all RADIOBUTTON GROUP rad,
                pa_nat RADIOBUTTON GROUP rad,
                pa_int RADIOBUTTON GROUP rad DEFAULT 'X'.
    PARAMETERS: pa_con LIKE gs_flight-countryfr.      " countryfr 파라미터 추가
  SELECTION-SCREEN END OF BLOCK blk.
SELECTION-SCREEN END OF SCREEN 1300.
```
- `E01` 모듈 수정
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_B03_PRACTICE4_E01
*&---------------------------------------------------------------------*

AT SELECTION-SCREEN ON BLOCK blk.
  IF pa_nat = 'X' AND pa_con IS INITIAL.
    MESSAGE e003(bc405).
  ENDIF.

START-OF-SELECTION.
  CASE 'X'.
    WHEN pa_all.
      SELECT * FROM dv_flights
        INTO TABLE gt_flight
        WHERE carrid IN so_car
          AND connid IN so_con
          AND fldate IN so_dat.
    WHEN pa_nat.
      SELECT * FROM dv_flights
        INTO TABLE gt_flight
        WHERE carrid IN so_car
          AND connid IN so_con
          AND fldate IN so_dat
          AND countryto <> dv_flights~countryfr
          AND countryfr = pa_con.
    WHEN pa_int.
      SELECT * FROM dv_flights
        INTO TABLE gt_flight
        WHERE carrid IN so_car
          AND connid IN so_con
          AND fldate IN so_dat
          AND countryto = dv_flights~countryfr.
    WHEN OTHERS.
  ENDCASE.
```
- 결과 확인
  
<img width="596" height="194" alt="image" src="https://github.com/user-attachments/assets/9dfeae5f-6b89-4237-8d67-b663454e459c" />
</br>

<img width="307" height="189" alt="image" src="https://github.com/user-attachments/assets/c348cd17-17a0-46a5-b774-77e8924e9f9b" />
</br>

<img width="547" height="317" alt="image" src="https://github.com/user-attachments/assets/15e61821-6653-48c6-94f1-2a98c4387acd" />
</br>

- countyfr 입력 안하면 오류 ( message class )
  
<img width="140" height="35" alt="image" src="https://github.com/user-attachments/assets/3f16b039-3eef-4334-b13a-26857c62a9bc" />


</br>
</br>

# 12/14
</br>
</br>

## <  핵심 개념 >
</br>

- **1) Pushbutton**
- **2) Selection Screen 필드 제어**
</br>

- 그룹명 같은 **이름** 지정 시 무조건 **대문자**
</br>
</br>

---

</br>

## < Selection Screen >
</br>

### 1) Pushbutton
- Selection Screen 에 버튼을 하나 추가
- 버튼 클릭 시 USER-COMMAND(OKCODE) 발생
- 버튼 생성 안되면 `/` 또는 `SKIP` 으로 띄우고 생성하기
```abap
TABLES <screen_fields>.

SELECTION-SCREEN
  PUSHBUTTON <position>(<length>) <text_var>
  USER-COMMAND <okcode>.
```
```abap
INITIALIZATION.
  <text_var> = '<버튼 텍스트>'.

AT SELECTION-SCREEN.
  CASE <screen_fields>-ucomm.
    WHEN '<okcode>'.
      " 버튼 클릭 시 처리 로직
  ENDCASE.
```
- 예시 코드
```abap
*************** TOP ****************
TABLES SSCRFIELDS.

DATA gv_btn_text TYPE string.

PARAMETERS p_carr TYPE scarr-carrid.

SELECTION-SCREEN
  PUSHBUTTON /10(20) gv_btn_text USER-COMMAND btn.    " / 은 줄 바꿈

*************** E01 ****************
INITIALIZATION.
  gv_btn_text = 'Display details'.

AT SELECTION-SCREEN.
  CASE SSCRFIELDS-ucomm.
    WHEN 'BTN'.
      MESSAGE 'Pushbutton 클릭됨' TYPE 'I'.
  ENDCASE.
```

</br>
</br>

### 2) Selection Screen 필드 제어
- Selection Screen에서 필드의 표시/입력 여부를 화면 출력 직전에 제어
- **CS (Contain String)** : 왼쪽 문자열 안에 오른쪽 문자열이 포함되면 TRUE
```abap
AT SELECTION-SCREEN OUTPUT.

  LOOP AT SCREEN.
    IF <조건>.
      screen-<속성> = <값>.
      MODIFY SCREEN.
    ENDIF.
  ENDLOOP.
```
- `screen-active` → 0이면 필드 완전 숨김, 1이면 표시
- `screen-invisible` → 1이면 값이 *****로 마스킹되어 보임
- `screen-input` → 0이면 입력 불가(읽기 전용), 1이면 입력 가능
- `screen-output` → 0이면 출력 안 함, 1이면 출력
- `screen-required` → 1이면 필수 입력 표시
- `screen-intensified` → 1이면 필드 강조 표시
- `screen-display_3d` → 1이면 3D 스타일, 0이면 Flat 스타일
```abap
*************** TOP ****************
DATA: gs_booking TYPE sbook.

SELECT-OPTIONS:
  so_car FOR gs_booking-carrid,
  so_con FOR gs_booking-connid MODIF ID abc.

*************** E01 ****************
AT SELECTION-SCREEN OUTPUT.

  LOOP AT SCREEN.
    IF screen-name CS 'SO_CON'
       OR screen-group1 = 'ABC'.
      screen-active = 0.
      MODIFY SCREEN.
    ENDIF.
  ENDLOOP.
```
</br>
</br>

---

</br>

## < 실습 코드 >
</br>

### 실습 1
</br>

- 문제
  
<img width="554" height="250" alt="image" src="https://github.com/user-attachments/assets/ca025a6b-eab5-4677-bdfb-d307ad114460" />
</br>
</br>
</br>
</br>

- `TOP` 모듈 생성
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_B03_PRACTICE5_TOP
*&---------------------------------------------------------------------*

DATA: gs_flight TYPE dv_flights.

PARAMETERS: pa_name TYPE c LENGTH 3.
SELECT-OPTIONS: so_car FOR gs_flight-carrid,
                so_con FOR gs_flight-connid.

SELECTION-SCREEN SKIP 2.

SELECTION-SCREEN BEGIN OF BLOCK blk1 WITH FRAME TITLE TEXT-001.
  SELECTION-SCREEN SKIP 2.

  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT 1(15) TEXT-003.
    SELECTION-SCREEN COMMENT 35(10) TEXT-004.
    PARAMETERS: pa_abap AS CHECKBOX.
    SELECTION-SCREEN COMMENT 60(10) TEXT-005.
    PARAMETERS: pa_fiori AS CHECKBOX.
  SELECTION-SCREEN END OF LINE.

  SELECTION-SCREEN SKIP 2.
  SELECTION-SCREEN BEGIN OF BLOCK blk2 WITH FRAME TITLE TEXT-002.
    PARAMETERS: pa_all RADIOBUTTON GROUP rad,
                pa_nat RADIOBUTTON GROUP rad,
                pa_int RADIOBUTTON GROUP rad DEFAULT 'X'.
  SELECTION-SCREEN END OF BLOCK blk2.
SELECTION-SCREEN END OF BLOCK blk1.
```
</br>

- `E01` 모듈 생성
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_B03_PRACTICE5_E01
*&---------------------------------------------------------------------*

INITIALIZATION.
  so_car-sign = 'I'.
  so_car-option = 'BT'.
  so_car-low = 'AA'.
  so_car-high = 'QF'.
  APPEND so_car.

  CLEAR so_car.
  so_car-sign = 'E'.
  so_car-option = 'EQ'.
  so_car-low = 'LH'.
  APPEND so_car.

AT SELECTION-SCREEN ON RADIOBUTTON GROUP rad.
  IF pa_all = 'X'.
    MESSAGE 'ERROR !' TYPE 'E'.
  ENDIF.
```
</br>

- 결과 확인
  
<img width="554" height="262" alt="image" src="https://github.com/user-attachments/assets/250511f8-7d2d-4ce1-82a2-7ab4724209c0" />
</br>

- PA_ALL 선택하고 실행하면 에러 발생하며 라디오 버튼 그룹만 활성화
<img width="546" height="424" alt="image" src="https://github.com/user-attachments/assets/041c32eb-eb29-4ba4-8681-fb6c6d8ed2b5" />
</br>
</br>
</br>
</br>

### 실습 2
- 전 실습에서 program 27에 이어서 진행
- Selection Screen 필드 제어
- ALV 실습 활용
</br>

- `TOP` 모듈 생성
```abap
*&---------------------------------------------------------------------*
*& Include          ZPROGB03_0027_TOP
*&---------------------------------------------------------------------*

TABLES sscrfields.

DATA: gs_flight TYPE dv_flights,
      gt_flight TYPE TABLE OF dv_flights,
      gv_mode TYPE C VALUE '1'.

" 2025-12-24: SALV 관련 변수 선언
DATA: go_salv TYPE REF TO cl_salv_table.

SELECTION-SCREEN BEGIN OF BLOCK blk1 WITH FRAME TITLE TEXT-001.
  SELECTION-SCREEN SKIP 2.
  "버튼 추가. 버튼명:gv_text, 버튼코드: ON
  SELECTION-SCREEN PUSHBUTTON pos_low(20) gv_text USER-COMMAND ON.

  PARAMETERS: pa_rad1 RADIOBUTTON GROUP rad,
              pa_rad2 RADIOBUTTON GROUP rad DEFAULT 'X',
              pa_rad3 RADIOBUTTON GROUP rad.
  SELECT-OPTIONS: so_car FOR gs_flight-carrid DEFAULT 'AA' TO 'LH' OPTION BT SIGN E,
                  so_con FOR gs_flight-connid DEFAULT '0017' NO-EXTENSION. " NO INTERVALS

SELECTION-SCREEN END OF BLOCK blk1.
```
</br>

- `E01` 모듈 생성
```abap
*&---------------------------------------------------------------------*
*& Include          ZPROGB03_0027_E01
*&---------------------------------------------------------------------*

INITIALIZATION.
  tab_strip-activetab ='COMM3'.
  tab_strip-dynnr = '0103'. " 초기 스크린 설정

  gv_text = '잠금 적용'.

AT SELECTION-SCREEN OUTPUT. " PBO
  LOOP AT SCREEN.
    IF screen-name CS 'RAD3'.
      screen-input = gv_mode.
    ENDIF.
    MODIFY SCREEN.
  ENDLOOP.

AT SELECTION-SCREEN. " PAI
  CHECK sy-dynnr = 1000.
  CASE sscrfields-ucomm.
    WHEN 'ON'.
      IF gv_mode = '1'.
        gv_mode = '0'.
        gv_text = '잠금해제'.
      ELSE.
        gv_mode = '1'.
        gv_text = '잠금 적용'.
      ENDIF.
    WHEN OTHERS.
  ENDCASE.
```
</br>

- ALV 적용 방식
- `Pattern` 클릭 후'ABAP Objects Patterns' 더블클릭
<img width="579" height="307" alt="image" src="https://github.com/user-attachments/assets/1f21c1ac-9374-4ca0-9ae2-f645d5ea9a68" />
</br>
</br>

<img width="351" height="333" alt="image" src="https://github.com/user-attachments/assets/101a0700-8bac-448b-ae9b-632edf5a6447" />
</br>
</br>
</br>

- 결과 확인

<img width="543" height="292" alt="image" src="https://github.com/user-attachments/assets/a1325d18-9403-4923-9f58-8691794b55e1" />
</br>
</br>

- 버튼 누르면 잠금
<img width="548" height="298" alt="image" src="https://github.com/user-attachments/assets/95dc1dfe-6b7e-4887-9985-226981e7421e" />
</br>
</br>

- ALV 이용하여 출력
<img width="543" height="176" alt="image" src="https://github.com/user-attachments/assets/571dc55b-d20f-4b93-9d2c-378d8d026ebd" />

</br>
</br>
</br>
</br>

### 실습 3
- `Pushbutton` 을 이용한 `Selection Screen` 필드 제어 실습
- 전 실습(exercise)에서 이어서 진행
</br>
</br>

**1) 프로그램 최초 실행**
- `INITIALIZATION` 실행
  → `AT SELECTION-SCREEN OUTPUT(PBO, 1000)`
  → `AT SELECTION-SCREEN OUTPUT(PBO, 1200)`
  → 화면 표시
  
**2) 탭을 1100번으로 이동**
- `AT SELECTION-SCREEN OUTPUT(PAI, 1200)`
  → `AT SELECTION-SCREEN OUTPUT(PAI, 1000)`
  → `AT SELECTION-SCREEN OUTPUT(PBO, 1000)`
  → `AT SELECTION-SCREEN(PBO, 1100)`
  → 1100 화면 출력
  
**3) 1100 화면에서 HIDE 버튼 클릭**
- 버튼 클릭
  → `AT SELECTION-SCREEN(PAI, 1100)`
  → `AT SELECTION-SCREEN OUTPUT(PAI, 1000)`
</br>
</br>
</br>

- `TOP` 모듈 수정
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_B03_PRACTICE4_TOP
*&---------------------------------------------------------------------*

TABLES SSCRFIELDS.

DATA: gs_flight TYPE dv_flights,
      gt_flight TYPE TABLE OF dv_flights,
      gv_mode TYPE I VALUE 1.

SELECTION-SCREEN BEGIN OF SCREEN 1100 AS SUBSCREEN.
  SELECT-OPTIONS: so_car FOR gs_flight-carrid MEMORY ID car,
                  so_con FOR gs_flight-connid.
  SELECTION-SCREEN SKIP 2.
  SELECTION-SCREEN PUSHBUTTON 1(10) gv_text USER-COMMAND hide.
  SELECTION-SCREEN SKIP 1.
  SELECTION-SCREEN BEGIN OF BLOCK blk1 WITH FRAME TITLE TEXT-001.
    SELECT-OPTIONS: so_cif FOR gs_flight-cityfrom MODIF ID grp,
                    so_cit FOR gs_flight-cityto MODIF ID grp.
  SELECTION-SCREEN END OF BLOCK blk1.
SELECTION-SCREEN END OF SCREEN 1100.
```
</br>

- `E01` 모듈 수정
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_B03_PRACTICE4_E01
*&---------------------------------------------------------------------*

INITIALIZATION.
  tab_strip-activetab = 'COMM2'.
  tab_strip-dynnr = '1200'.

  gv_text = '숨김모드 적용'.

AT SELECTION-SCREEN OUTPUT.
*  CHECK sy-dynnr = 1100.  " IF sy-dynnr = 1100. 도 가능
  LOOP AT SCREEN.
    IF screen-group1 = 'GRP'.
      screen-active = gv_mode.
      MODIFY SCREEN.
    ENDIF.
  ENDLOOP.

AT SELECTION-SCREEN.
  CHECK sy-dynnr = 1100.  " 1100번일때만 로직 실행
  CASE SSCRFIELDS-ucomm.
    WHEN 'HIDE'.
      IF gv_mode = 1.
        gv_mode = 0.
        gv_text = '숨김모드 해제'.
      ELSE.
        gv_mode = 1.
        gv_text = '숨김모드 적용'.
      ENDIF.
    WHEN OTHERS.
  ENDCASE.
```
</br>

- 결과 확인
<img width="578" height="221" alt="image" src="https://github.com/user-attachments/assets/72062d90-598c-41b5-b648-f9e50eb3c5c1" />
</br>
</br>

- 버튼 클릭하면 입력창이 숨겨짐
<img width="579" height="222" alt="image" src="https://github.com/user-attachments/assets/0045c78e-b46c-439c-8095-df18e8af3f99" />
</br>
</br>
</br>
</br>

### 실습 4 (과제)
- 문제
- `FOR ALL ENTRIES IN <itab>` 사용
- `LOOP AT <itab> … ENDLOOP` 사용
- `READ TABLE <itab> INTO .. WITH KEY …` 사용
- `SORT <itab>` 사용
<img width="501" height="553" alt="image" src="https://github.com/user-attachments/assets/35361289-6707-4c88-a1fd-94288881aefd" />
</br>
</br>
</br>
</br>

- `TOP` 모듈 생성
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_B03_PRACTICE6_TOP
*&---------------------------------------------------------------------*

DATA: gs_scarr TYPE scarr,
      gt_scarr TYPE TABLE OF scarr.

DATA: BEGIN OF gs_data,
        carrid    TYPE s_carr_id,     "DV_FLIGHTS
        carrname  TYPE s_carrname,    "SCARR
        connid    TYPE s_conn_id,     "DV_FLIGHTS
        fldate    TYPE s_date,        "DV_FLIGHTS
        cityfrom  TYPE s_from_cit,    "DV_FLIGHTS
        cityto    TYPE s_to_city,     "DV_FLIGHTS
        countryfr TYPE land1,         "DV_FLIGHTS
        countryto TYPE land1,         "DV_FLIGHTS
      END OF gs_data.
DATA: gt_data LIKE TABLE OF gs_data.

SELECT-OPTIONS: SO_CAR FOR gs_data-carrid,
                SO_CON FOR gs_data-connid,
                SO_FDT FOR gs_data-fldate NO INTERVALS.

DATA: go_salv TYPE REF TO cl_salv_table.
```
</br>

- `E01` 모듈 수정
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_B03_PRACTICE6_E01
*&---------------------------------------------------------------------*

INITIALIZATION.
  SO_car-sign = 'I'.
  so_car-option = 'BT'.
  so_car-low = 'AA'.
  so_car-high = 'QF'.
  APPEND so_car.

START-OF-SELECTION.
  SELECT * FROM dv_flights
    INTO CORRESPONDING FIELDS OF TABLE gt_data
    WHERE carrid IN SO_car
      AND connid IN SO_con
      AND fldate IN SO_fdt.

  MOVE-CORRESPONDING gt_data TO gt_copy_data.

  SORT gt_copy_data BY carrid.
  DELETE ADJACENT DUPLICATES FROM gt_copy_data COMPARING carrid.

  " scarr에서 dv_flights의 carrid 에 맞는 데이터 뽑기
  SELECT carrid carrname FROM scarr
    INTO TABLE gt_scarr
    FOR ALL ENTRIES IN gt_copy_data
    WHERE carrid = gt_copy_data-carrid.

  LOOP AT gt_data INTO gs_data.
    READ TABLE gt_scarr INTO gs_scarr WITH KEY carrid = gs_data-carrid.
    gs_data-carrname = gs_scarr-carrname.
    MODIFY gt_data FROM gs_data.
  ENDLOOP.

  SORT gt_data BY carrid connid fldate ASCENDING.

  TRY.
      CALL METHOD cl_salv_table=>factory
        IMPORTING
          r_salv_table = go_salv
        CHANGING
          t_table      = gt_data.
    CATCH cx_salv_msg.
      MESSAGE 'Error !' TYPE 'E'.
  ENDTRY.

  go_salv->get_functions( )->set_all( abap_true ).
  go_salv->display( ).
```
</br>

- 결과 확인
<img width="460" height="407" alt="image" src="https://github.com/user-attachments/assets/d34e516b-a7ed-4f27-9a7f-78410d3f9406" />

</br>
</br>

# 12/26
</br>
</br>

## <  핵심 개념 >
</br>

- **1) ABAP 객체 생성 기본 문법**
- **2) ALV 레이아웃 Variant 저장 옵션**

</br>
</br>

---

</br>

## < ALV 화면 구성 >
</br>

- **ALV 기본 툴바 버튼 기능 설명**
<img width="444" height="337" alt="image" src="https://github.com/user-attachments/assets/4e7d929d-9c27-4a8b-aede-4acf4a0965b2" />

</br>
</br>
</br>

- **상단 영역**
- `List Header` (선택) : ALV 제목/설명
- `Application Toolbar` : 정렬·필터·엑셀 버튼 (클릭 시 이벤트 발생)
</br>

- **중앙(Data Area)**
- `Column Header` : 컬럼 제목 + 정렬 기준
- `Key Column` : 왼쪽 고정 핵심 컬럼
- `Selection Button` (선택) : 행 선택용 체크/아이콘
- `Data` : 실제 조회 데이터
</br>

- **하단 영역**
- `Total Column` : 합계 대상 컬럼
- `Aggregation Row` : 합계 / 평균 / 최소 / 최대

<img width="490" height="346" alt="image" src="https://github.com/user-attachments/assets/5a287e4b-e177-4673-99a7-acdc4164259f" />
</br>
</br>


<img width="495" height="393" alt="image" src="https://github.com/user-attachments/assets/c069f6ba-2f59-4113-a372-eaa7a211bf23" />
</br>
</br>

### < ALV 마우스 사용 >
- **행 선택** : 클릭 (Ctrl = 다중)
- **컬럼 선택** : 헤더 클릭 (Ctrl = 다중)
- **컬럼 이동** : 드래그
- **폭 조절** : 컬럼 경계 드래그
- **헤더 우클릭** : 복사 / 숨김 / 자동폭 / 고정
</br>
</br>

### < ALV Subtotals >
- `Total` : 전체 데이터 합계 → 맨 아래 1줄
- `Subtotal` : 기준 컬럼별 그룹 합계 → 그룹마다 표시

<img width="465" height="361" alt="image" src="https://github.com/user-attachments/assets/5be7e416-eda5-42ea-a17d-f8bf3a0f0a0d" />
</br>
</br>
</br>
</br>
</br>

---

</br>

## < ABAP 객체 생성 기본 문법 >
- **Area는 Container로, Container는 ALV Grid로 연결됨**
- **클래스** : 객체의 설계도
- **인스턴스(객체)** : 클래스로 생성된 실제 실체
- **참조 변수** : 객체를 가리키는 포인터 변수
</br>
</br>

**1) 참조 변수 선언**
- 객체를 담는 변수가 아니라 객체를 가리키는 참조 변수
- 실제 객체는 아직 없음
```abap
DATA: <ref_var> TYPE REF TO <class_name>.
```
- `CL_GUI_CUSTOM_CONTAINER` : Screen의 Area와 연결되는 컨테이너
- `CL_GUI_ALV_GRID` : Container 안에서 데이터를 표시하는 ALV Grid 객체
```abap
*************** TOP ****************                   " REPORT ZPROGB03_0028.
DATA: go_cont TYPE REF TO CL_GUI_CUSTOM_CONTAINER,     " Container 참조변수 생성 (아직 객체 생성되기 전)
      go_alv TYPE REF TO CL_GUI_ALV_GRID.              " ALV 참조변수 생성 (아직 객체 생성되기 전)
```
</br>
</br>

**2) 객체 생성**
- `CREATE OBJECT` 로 실제 객체 생성 (생성자 자동 호출)
- 생성 시 생성자(CONSTRUCTOR) 호출
- 필요한 값은 `EXPORTING` 으로 전달
- PBO에서 INITIAL 체크 후 1회 생성, Container → ALV 순서
```abap
IF <ref_var> IS INITIAL.
  CREATE OBJECT <ref_var>
    EXPORTING
      <param> = <value>.
    EXCEPTIONS
      <exception_1> = <rc_1>
ENDIF.
```
- `container_name` → Screen의 Area와 연결
- `i_parent` → ALV ↔ Container 연결
```abap
REPORT ZPROGB03_0028.

*************** PBO ****************
MODULE init_alv OUTPUT.
  " 1. SCREEN에 Custom Area 추가
  " 2. Container Control 생성 (AREA와 연결)
  IF go_cont IS INITIAL. " 최초 1번만 실행
    CREATE OBJECT go_cont
      EXPORTING
        container_name              = 'AREA'
      EXCEPTIONS
        cntl_error                  = 1
        cntl_system_error           = 2
        create_error                = 3
        lifetime_error              = 4
        lifetime_dynpro_dynpro_link = 5
        others                      = 6.

    " 3. ALV Grid 생성
    CREATE OBJECT go_alv
      EXPORTING
        i_parent          = go_cont " Container와 연결
      EXCEPTIONS
        error_cntl_create = 1
        error_cntl_init   = 2
        error_cntl_link   = 3
        error_dp_create   = 4
        others            = 5.
  ENDIF.
ENDMODULE.
```
</br>
</br>

- `Custom Container` 객체 생성
  
<img width="377" height="363" alt="image" src="https://github.com/user-attachments/assets/6d99dc1d-c5bd-4140-b21a-e41130485067" />
</br>
</br>

- `ALV Grid` 객체 생성

<img width="375" height="359" alt="image" src="https://github.com/user-attachments/assets/90735023-c617-449e-98ad-6b3eed0e0f61" />
</br>
</br>
</br>
</br>

**3) ALV 컨트롤 인스턴스 해제**
- 화면 종료 시 PAI에서 ALV/Container → free 호출로 자원 해제
- PAI(EXIT, CANCEL) 에서 수행
```abap
FORM free_control_resources.
  CALL METHOD <alv_ref>->free.
  CALL METHOD <container_ref>->free.
  FREE: <alv_ref>, <container_ref>.
ENDFORM.
```
- `->FREE()` : 객체가 사용하는 GUI 컨트롤 자원 해제
- `FREE ref` : 참조 변수만 해제(값 INITIAL로 초기화)
```abap
REPORT ZPROGB03_0028.

*************** PAI ****************
MODULE exit INPUT.
  CASE OK_CODE.
    WHEN 'EXIT'.
      PERFORM FREE_ALV.
      LEAVE PROGRAM.
    WHEN 'CANCEL'.
      PERFORM FREE_ALV.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.

*************** F01 ****************
FORM free_alv.
  IF GO_ALV IS NOT INITIAL.
    GO_ALV->FREE( ).
  ENDIF.
  IF GO_CONT IS NOT INITIAL.
    GO_CONT->FREE( ).
  ENDIF.
  FREE: GO_ALV, GO_CONT.
ENDFORM.
```
</br>
</br>

**4) ALV Grid 데이터 표시**
- ALV Grid에 처음으로 데이터를 출력하는 메서드
- 내부 테이블( `it_outtab` )의 데이터를 기준으로 화면 구성
- `i_structure_name` 에 지정한 DDIC 구조 기준으로 ALV 컬럼 구조가 자동 출력됨
```abap
CALL METHOD <alv_ref>->set_table_for_first_display
  EXPORTING
    i_structure_name = '<DDIC_STRUCTURE>'
  CHANGING
    it_outtab        = <internal_table>
  EXCEPTIONS
    invalid_parameter_combination = 1
    program_error                 = 2
    too_many_lines                = 3
    others                        = 4.
```
- `SET_TABLE_FOR_FIRST_DISPLAY` : 내부 테이블 데이터를 ALV Grid에 최초로 표시하는 메서드
- SET_TABLE* 하고 f4 누르면 자동완성
```abap
REPORT ZPROGB03_0028.

*************** PBO ****************
" 4. ALV Grid 안에 Data Display
CALL METHOD go_alv->set_table_for_first_display
  EXPORTING
    i_structure_name              = 'SFLIGHT'
  CHANGING
    it_outtab                     = gt_flight
  EXCEPTIONS
    invalid_parameter_combination = 1
    program_error                 = 2
    too_many_lines                = 3
    others                        = 4.
```
</br>
</br>

- ALV Grid 메서드 호출
<img width="384" height="362" alt="image" src="https://github.com/user-attachments/assets/e2594dd2-511b-4721-b9c6-b9e5ec7d13ab" />
</br>
</br>
</br>
</br>

**5) ALV 데이터 갱신**
- `REFRESH_TABLE_DISPLAY`
- 이미 생성된 ALV Grid가 있을 때 ALV를 다시 만들지 않고 데이터만 화면에 반영
```abap
REPORT ZPROGB03_0028.

*************** PBO ****************
IF go_cont IS INITIAL. " 최초 1번만 실행
   " ALV 생성 로직
ELSE.
   " 최초에 1번 생성된 후, 두번째부터는 ELSE구문을 실행한다
   CALL METHOD go_alv->refresh_table_display
     EXCEPTIONS
       finished       = 1
       others         = 2.
ENDIF.
```
</br>
</br>

**6) 결과 확인**

<img width="475" height="127" alt="image" src="https://github.com/user-attachments/assets/a7190486-1fe1-40c7-be7f-222564219cbc" />
</br>

<img width="574" height="174" alt="image" src="https://github.com/user-attachments/assets/9b72474e-7ab8-47fd-a1f1-5c8b5a0c0e48" />
</br>
</br>
</br>
</br>
</br>

---

</br>

## < ALV 레이아웃 Variant 저장 옵션 >
</br>

**1) `I_SAVE` (저장 범위)**
- 프로그램 실행 시 자동 적용 여부 지정
- `A` : Global / Local 레이아웃 모두 저장 가능
- `U` : Local(사용자별) 레이아웃만 저장 가능
- `X` : Global(공용) 레이아웃만 저장 가능
- `space` : 레이아웃 저장 불가
```abap
i_save = '<A|U|X|space>'.      " ' ' (공백 문자) 쓰지 않기. '' 는 가능.
```
</br>

**2) `I_DEFAULT` (기본 레이아웃)**
- 프로그램 실행 시 자동 적용 여부 지정
- `space` : 레이아웃은 저장되지만 자동 적용 안 됨
- `X` : 해당 레이아웃을 기본(Default) 으로 저장 → 실행 시 자동 적용
```abap
i_default = '<X|space>'.
```
</br>

**3) `<ls_variant>-report`**
- 레이아웃 Variant가 속한 프로그램명
- Variant 저장/조회에 필수
- 보통 항상 sy-cprog 사용
```abap
<ls_variant>-report = sy-cprog.
```
</br>

**4) `<ls_variant>-variant`**
- 적용할 레이아웃(Variant) 이름
- Selection Screen에서 입력받은 Variant를 ALV에 적용할 때 사용
```abap
<ls_variant>-variant = <p_var>.
```
</br>

**5) `<ls_variant>-handle`**
- 같은 프로그램에서 여러 ALV Grid 구분용 식별자
- ALV 1개면 생략 가능
```abap
<ls_variant>-handle = '1'.
```
</br>

**6) `<ls_variant>-username`**
- 특정 사용자 전용 Variant 지정
- 대부분 시스템이 자동 처리 → 직접 설정 거의 안 함
```abap
<ls_variant>-username = sy-uname.
```
</br>

**7) <ls_variant>-text**
- 레이아웃 설명 텍스트
- Variant 저장 화면에서 입력·표시되는 값
```abap
<ls_variant>-text = 'Flight ALV Layout'.
```
</br>
</br>
</br>

### 1) ALV 레이아웃 Variant 저장
- `<ls_variant>-report = sy-cprog.` 는 필수
```abap
DATA: <ls_variant> TYPE disvariant,
      <lv_save>    TYPE c LENGTH 1.

<ls_variant>-report = sy-cprog.
<lv_save> = '<A|U|X|space>'.

CALL METHOD <alv_ref>->set_table_for_first_display
  EXPORTING
    is_variant = <ls_variant>
    i_save     = <lv_save>
    i_default  = '<X|space>'
  CHANGING
    it_outtab  = <itab>.
```
```abap
REPORT ZPROGB03_0029.

*************** TOP ****************
DATA: gs_variant TYPE disvariant,
      gv_save    TYPE c LENGTH 1.

gs_variant-report = sy-cprog.
gv_save = 'A'.   " Global / Local 모두 저장

*************** PBO ****************
CALL METHOD go_alv_grid->set_table_for_first_display
  EXPORTING
    is_variant = gs_variant
    i_save     = gv_save
    i_default  = 'X'
  CHANGING
    it_outtab  = gt_bookings.
```
</br>

### 2) Selection Screen에서 Variant 전달
```abap
DATA <ls_variant> TYPE disvariant.
PARAMETERS <p_var> TYPE disvariant-variant.

<ls_variant>-report  = sy-cprog.
<ls_variant>-variant = <p_var>.

CALL METHOD <alv_ref>->set_table_for_first_display
  EXPORTING
    is_variant = <ls_variant>
  CHANGING
    it_outtab  = <itab>.
```
```abap
REPORT ZPROGB03_0029.

*************** TOP ****************
DATA gv_variant TYPE disvariant.
PARAMETERS pa_lv TYPE disvariant-variant.

gv_variant-report  = sy-cprog.
gv_variant-variant = pa_lv.

*************** PBO ****************
CALL METHOD go_alv_grid->set_table_for_first_display
  EXPORTING
    is_variant = gv_variant
  CHANGING
    it_outtab  = gt_bookings.
```
</br>
</br>
</br>
</br>

## < ALV 레이아웃 Variant 저장 옵션 (I_SAVE) 예제 >
</br>

**1) `TOP` 모듈 수정**
```abap
REPORT ZPROGB03_0029.

DATA: gs_variant TYPE disvariant.

INITIALIZATION.
  PERFORM set_options.
  gs_variant-report = sy-cprog.
  gs_variant-username = sy-uname.
  gs_variant-handle = 'MAIN'.
  " handle : 하나의 화면에 여러개의 ALV가 있는 경우
  "          각 ALV마다 구분자가 필요하므로 구분자 지정해줌
```
</br>

**2) `PBO` 의 `init_alv` 모듈 수정**
```abap
REPORT ZPROGB03_0029.

" 4. ALV Grid 안에 Data display
    CALL METHOD go_alv->set_table_for_first_display
      EXPORTING
        i_structure_name              = 'SBOOK'
        is_variant                    = gs_variant
        i_save                        = 'A' " A, X, U, ''
        i_default                     = 'X'
      CHANGING
        it_outtab                     = gt_data
      EXCEPTIONS
        invalid_parameter_combination = 1
        program_error                 = 2
        too_many_lines                = 3
        others                        = 4.
```
</br>

**3) `Variant` 지정**
- 레이아웃 수정 후 레이아웃 저장
  
<img width="511" height="174" alt="image" src="https://github.com/user-attachments/assets/2066b032-4300-445e-b15d-6943b89a5324" />
</br>
</br>

- `/` 로 시작 → Global(공용) 레이아웃
- `/` 없음 → Local(개인) 레이아웃

<img width="435" height="351" alt="image" src="https://github.com/user-attachments/assets/fbab5ce1-d915-4938-a262-f83736fe20f4" />
</br>
</br>

- **`User-Specific`** ✔ → Local(개인) / ✖ → Global(공용)
- **`Default`** ✔ → 실행 시 자동 적용 / ✖ → 수동 선택
<img width="435" height="361" alt="image" src="https://github.com/user-attachments/assets/fd7a76e1-0a81-4205-b3d7-70edded26b4d" />
</br>
</br>
</br>

**4) Default 선택 안했을 때 레이아웃 선택하면 바뀜**

<img width="546" height="178" alt="image" src="https://github.com/user-attachments/assets/f3b2e2a4-e952-4c70-8c8b-c3efbe07d126" />

</br>
</br>
</br>
</br>

---

</br>

## < 실습 코드 >
</br>

### 실습 1
- ALV 실습
</br>
</br>

**1) Program 에 모듈 생성**
```abap
REPORT ZPROGB03_0029.

INCLUDE ZPROGB03_0029_TOP.
INCLUDE ZPROGB03_0029_O01.
INCLUDE ZPROGB03_0029_I01.
INCLUDE ZPROGB03_0029_F01.
```
</br>
</br>

**2) `TOP` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZPROGB03_0029_TOP
*&---------------------------------------------------------------------*

DATA: gt_data TYPE TABLE OF sbook,
      gs_data LIKE LINE OF gt_data.

DATA: ok_code TYPE sy-ucomm,
      go_cont TYPE REF TO cl_gui_custom_container,
      go_alv  TYPE REF TO cl_gui_alv_grid.

SELECTION-SCREEN BEGIN OF BLOCK blk1 WITH FRAME.
  SELECT-OPTIONS: so_car FOR gs_data-carrid,
                  so_con FOR gs_data-connid,
                  so_fdt FOR gs_data-fldate.
SELECTION-SCREEN END OF BLOCK blk1.

INITIALIZATION.
  PERFORM set_options.

START-OF-SELECTION.
  PERFORM GET_DATA.
  CALL SCREEN 100.
```
</br>
</br>

**3) `F01` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZPROGB03_0029_F01
*&---------------------------------------------------------------------*

FORM set_options.
  so_fdt-sign = 'I'.
  so_fdt-option = 'BT'.
  so_fdt-low = sy-datum(4) && '0101'. " 매년 첫째날
  so_fdt-high = sy-datum(4) && '1231'. " 매년 마지막날
  APPEND so_fdt.

  so_car-sign = 'I'.
  so_car-option = 'GT'.
  so_car-low = 'AZ'.
  APPEND so_car.

  CLEAR so_car.
  so_car-sign = 'E'.
  so_car-option = 'EQ'.
  so_car-low = 'LH'.
  APPEND so_car.
ENDFORM.

*&---------------------------------------------------------------------*

FORM get_data.
  SELECT * FROM SBOOK
    INTO TABLE gt_data
    WHERE carrid IN so_car
      AND connid IN so_con
      AND fldate IN so_fdt.
ENDFORM.
```
</br>
</br>

**4) `PBO` 모듈 생성**
- `SY-UNAME` : 현재 로그인한 사용자 ID
- `SY-DATUM` : 현재 시스템 날짜 (`YYYYMMDD`)
- `SY-UZEIT` : 현재 시스템 시간 (`HHMMSS`)
```abap
*&---------------------------------------------------------------------*
*& Include          ZPROGB03_0029_O01
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.
 SET PF-STATUS 'S100'.
 SET TITLEBAR 'T100' WITH sy-uname sy-datum sy-uzeit.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE init_alv OUTPUT.
  " 1. 100번 스크린 Layout에 Area 추가
  " 2. 만약 Container 가 만들어지기 전이라면, 객체 생성함
  "    Custom Container 생성
  IF go_cont IS INITIAL.
    CREATE OBJECT go_cont
      EXPORTING
        container_name              = 'AREA'
      EXCEPTIONS
        cntl_error                  = 1
        cntl_system_error           = 2
        create_error                = 3
        lifetime_error              = 4
        lifetime_dynpro_dynpro_link = 5
        others                      = 6.
    IF sy-subrc <> 0.
*     MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*                WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    ENDIF.

    " 3. ALV Grid 객체 생성해서 Container와 연결
    CREATE OBJECT go_alv
      EXPORTING
        i_parent          = go_cont
      EXCEPTIONS
        error_cntl_create = 1
        error_cntl_init   = 2
        error_cntl_link   = 3
        error_dp_create   = 4
        others            = 5.
    IF sy-subrc <> 0.
*     MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*                WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    ENDIF.

    " 4. ALV Grid 안에 Data display
    CALL METHOD go_alv->set_table_for_first_display
      EXPORTING
        i_structure_name              = 'SBOOK'
      CHANGING
        it_outtab                     = gt_data
      EXCEPTIONS
        invalid_parameter_combination = 1
        program_error                 = 2
        too_many_lines                = 3
        others                        = 4
            .
    IF sy-subrc <> 0.
*     Implement suitable error handling here
    ENDIF.

  ENDIF.
ENDMODULE.
```
</br>
</br>

**5) `PAI` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZPROGB03_0029_I01
*&---------------------------------------------------------------------*

MODULE exit INPUT.
  CASE OK_CODE.
    WHEN 'EXIT'.
      LEAVE PROGRAM.
    WHEN 'CANCEL'.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.
  CASE OK_CODE.
    WHEN 'BACK'.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```
</br>
</br>

**6) 결과 확인**

<img width="488" height="141" alt="image" src="https://github.com/user-attachments/assets/0593593a-ab76-4ee7-a844-32473cfcbab4" />
</br>

<img width="515" height="238" alt="image" src="https://github.com/user-attachments/assets/3e58a92f-1c2d-4be3-af54-f6a5e9ea0fb8" />
</br>
</br>
</br>
</br>
</br>

### 실습 2
- 문제
<img width="356" height="208" alt="image" src="https://github.com/user-attachments/assets/f0ef060a-6af1-4039-baf9-1cb3d57ad293" />
</br>
</br>
</br>
</br>
</br>

**1) Program 에 모듈 생성**
```abap
REPORT ZBC405_03_ALV.

INCLUDE ZBC405_03_ALV_TOP.
INCLUDE ZBC405_03_ALV_O01.
INCLUDE ZBC405_03_ALV_I01.
INCLUDE ZBC405_03_ALV_F01.

START-OF-SELECTION.

*PERFORM get_data.
PERFORM get_data2.
CALL SCREEN 100.
```
</br>
</br>

**2) `TOP` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV_TOP
*&---------------------------------------------------------------------*

DATA: OK_CODE TYPE sy-ucomm,
      go_container TYPE REF TO cl_gui_custom_container,
      go_alv_grid TYPE REF TO cl_gui_alv_grid.

DATA: gs_flight TYPE sflight,
      gt_flight TYPE TABLE OF sflight.

DATA: gs_flight2 TYPE BC400_S_FLIGHT,
      gt_flight2 TYPE TABLE OF BC400_S_FLIGHT.

SELECT-OPTIONS: so_car FOR gs_flight-carrid,
                so_con FOR gs_flight-connid.
```
</br>
</br>

**3) `F01` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV_F01
*&---------------------------------------------------------------------*

FORM get_data.
  SELECT * FROM sflight
    INTO TABLE gt_flight
    WHERE carrid IN so_car
      AND connid IN so_con.
ENDFORM.

*&---------------------------------------------------------------------*

FORM get_data2.
  SELECT carrid connid fldate seatsmax seatsocc FROM sflight
    INTO CORRESPONDING FIELDS OF TABLE gt_flight2
    WHERE carrid IN so_car
      AND connid IN so_con.

  LOOP AT gt_flight2 INTO gs_flight2.
    gs_flight2-PERCENTAGE = ( gs_flight2-seatsocc / gs_flight2-seatsmax ) * 100.
    MODIFY gt_flight2 FROM gs_flight2.
  ENDLOOP.
ENDFORM.

*&---------------------------------------------------------------------*

FORM free_alv.
  IF go_container IS INITIAL.
    go_container->free( ).
  ENDIF.
  IF go_alv_grid IS INITIAL.
    go_alv_grid->free( ).
  ENDIF.
  FREE: go_container, go_alv_grid.
ENDFORM.
```
</br>
</br>

**4) `PBO` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV_O01
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.
 SET PF-STATUS 'S100'.
 SET TITLEBAR 'T100'.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE create_and_transfer OUTPUT.
  IF go_container IS INITIAL.
    CREATE OBJECT go_container
      EXPORTING
        container_name              = 'MY_CONTROL_AREA'
      EXCEPTIONS
        cntl_error                  = 1
        cntl_system_error           = 2
        create_error                = 3
        lifetime_error              = 4
        lifetime_dynpro_dynpro_link = 5
        others                      = 6.
    IF sy-subrc <> 0.
      MESSAGE A010(BC405_408).
    ENDIF.

    CREATE OBJECT go_alv_grid
      EXPORTING
        i_parent          = go_container
      EXCEPTIONS
        error_cntl_create = 1
        error_cntl_init   = 2
        error_cntl_link   = 3
        error_dp_create   = 4
        others            = 5.
    IF sy-subrc <> 0.
      MESSAGE A010(BC405_408).
    ENDIF.

    CALL METHOD go_alv_grid->set_table_for_first_display
      EXPORTING
        i_structure_name              = 'BC400_S_FLIGHT'
      CHANGING
        it_outtab                     = gt_flight2
      EXCEPTIONS
        invalid_parameter_combination = 1
        program_error                 = 2
        too_many_lines                = 3
        others                        = 4.
    IF sy-subrc <> 0.
      MESSAGE A012(BC405_408).
    ENDIF.


  ENDIF.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE clear_ok_code OUTPUT.
  CLEAR OK_CODE.
ENDMODULE.
```
</br>
</br>

**5) `PAI` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV_I01
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.
  CASE OK_CODE.
    WHEN 'BACK'.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE exit INPUT.
  CASE OK_CODE.
    WHEN 'EXIT'.
      LEAVE PROGRAM.
      PERFORM free_alv.
    WHEN 'CANCEL'.
      PERFORM free_alv.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```
</br>
</br>

**6) 결과 확인**

<img width="500" height="103" alt="image" src="https://github.com/user-attachments/assets/91faf0f7-6bcc-4e33-91bf-32f8557a5f2a" />
</br>

<img width="506" height="227" alt="image" src="https://github.com/user-attachments/assets/dc02a463-7156-409c-ae94-416c3b6eb75b" />

</br>
</br>
</br>
</br>
</br>

### 실습 3
- Variat 실습
- 실습 2에서 이어서 진행
</br>

**1) `TOP` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV_TOP
*&---------------------------------------------------------------------*

DATA: gs_variant TYPE disvariant.
PARAMETERS: pa_va TYPE disvariant-variant.
```
</br>
</br>

**2) `PBO` 의 `create_and_transfer` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV_O01
*&---------------------------------------------------------------------*

gs_variant-report = sy-cprog.
gs_variant-variant = pa_va.

CALL METHOD go_alv_grid->set_table_for_first_display
  EXPORTING
    i_structure_name              = 'sflight'
    is_variant = gs_variant
    i_save = 'A'
  CHANGING
    it_outtab                     = gt_flight
  EXCEPTIONS
    invalid_parameter_combination = 1
    program_error                 = 2
    too_many_lines                = 3
    others                        = 4.
IF sy-subrc <> 0.
  MESSAGE A012(BC405_408).
ENDIF.
```
</br>
</br>

**3) 결과 확인**

<img width="492" height="282" alt="image" src="https://github.com/user-attachments/assets/5ae999f6-b27a-4a39-9a9c-f1a4094975ea" />

</br>
</br>

# 12/29
</br>
</br>

## <  핵심 개념 >
</br>

- **1) ALV 데이터 갱신 (refresh_table_display, stable)**
- **2) ALV 레이아웃 설정 (IS_LAYOUT)**
- **3) ALV 임계값(Threshold) 아이콘 표시 – Exception Display (특정 조건에 따라 빨강/노랑/초록 아이콘 자동 표시)**
- **4) ALV 초기 정렬 기준 설정 (lvc_s_sort)**
- **5) ALV 초기 필터 조건 설정 (LVC_S_FILT)**
- **6) ALV Line Color (행 색상 제어)**
- **7) ALV Cell Color (셀 단위 색상 제어)**
</br>

- **SELECT-OPTIONS는 `Selection Screen` 에서만 가능**
- **`TYPE-POOLS COL.` 로 색상 코드 확인 가능 (필수)**

</br>
</br>

---

</br>

## < ABAP 객체 생성 기본 문법 >
</br>

### 1) ALV 데이터 갱신
- 이미 생성된 ALV Grid가 있을 때 ALV를 다시 생성하지 않고 데이터만 화면에 반영
- `REFRESH_TABLE_DISPLAY` → ALV Grid 데이터를 다시 그리되 스크롤·선택 상태를 유지한 채 화면만 갱신하는 메서드
- 보통 PBO에서 호출
```abap
CALL METHOD <alv_ref>->refresh_table_display
  EXPORTING
    is_stable = <ls_stable>.
```
</br>

- `LVC_S_STBL` 은 ALV 새로고침 시 스크롤·선택 위치가 초기화되지 않도록 화면을 고정하는 옵션
- `row = 'X'` → 행(스크롤) 위치 유지
- `col = 'X'` → 열(커서) 위치 유지
```abap
DATA ls_stable TYPE lvc_s_stbl.

ls_stable-row = 'X'. " 행 위치 유지
ls_stable-col = 'X'. " 열 위치 유지
```
</br>

- `i_soft_refresh` = 'X' : 정렬·필터·레이아웃을 유지한 채 데이터만 갱신
- `i_soft_refresh` = space : ALV를 전체 재계산하여 정렬·필터까지 다시 적용
```abap
REPORT ZPROGB03_0029.

********* TOP *********
DATA gs_stable TYPE LVC_S_STBL.   

********* PBO *********
gs_stable-row = 'X'.
gs_stable-col = 'X'.

CALL METHOD go_alv->refresh_table_display
  EXPORTING
    is_stable      = gs_stable
    i_soft_refresh = ''  " X : 정렬, 필터, 그외 기능들 유지
                         " _ : 전체 리프레쉬 (기본)
  EXCEPTIONS
    finished       = 1
    OTHERS         = 2.
```
</br>
</br>
</br>

### 2) ALV 레이아웃 설정 (IS_LAYOUT)
- ALV Grid의 화면 모양(제목, 줄무늬, 컬럼 폭 등)을 설정
- 데이터 내용은 안 바뀌고 표시 방식만 제어
- `SET_TABLE_FOR_FIRST_DISPLAY` 에서 최초 출력 시만 적용
- **`Ctrl + Space`** - `gs_layout-` 뒤에서 누르면 구조체 필드 목록 자동 표시
</br>

- `LVC_S_LAYO` : ALV 화면의 모양(레이아웃) 을 제어하는 구조체
```abap
DATA <ls_layout> TYPE lvc_s_layo.

<ls_layout>-grid_title = 'Booking List'.
<ls_layout>-zebra      = 'X'.
<ls_layout>-cwidth_opt = 'X'.
<ls_layout>-totals_bef = 'X'.
<ls_layout>-sel_mode   = 'A'.

CALL METHOD <alv_ref>->set_table_for_first_display
  EXPORTING
    i_structure_name = '<DDIC>'
    is_layout        = <ls_layout>
  CHANGING
    it_outtab        = <itab>.
```
```abap
REPORT ZPROGB03_0029.

********* TOP *********
DATA gs_layout TYPE lvc_s_layo.

********* F01 *********
FORM set_layout.
  gs_layout-grid_title = 'Booking List'.   " ALV 제목
  gs_layout-zebra      = 'X'.               " 행 줄무늬
  gs_layout-cwidth_opt = 'X'.               " 컬럼 너비 자동
  gs_layout-totals_bef = 'X'.               " 합계 상단
  gs_layout-sel_mode   = 'A'.               " 선택 모드 (_,A,B,C,D)
ENDFORM.

********* PBO *********
CALL METHOD go_alv->set_table_for_first_display
  EXPORTING
    i_structure_name = 'SBOOK'
    is_layout        = gs_layout
  CHANGING
    it_outtab        = gt_data.
```
</br>
</br>

**< LVC_S_LAYO (ALV Layout Structure 주요 필드 정리) >**
  
| Field Name     | Description |
|---------------|-------------|
| `grid_title`  | ALV 상단에 표시되는 제목 텍스트 (최대 70자) |
| `zebra`       | `'X'` 설정 시 행을 교차 색상(Zebra 패턴)으로 표시 |
| `no_headers`  | `'X'` 설정 시 컬럼 헤더 숨김 |
| `sel_mode`    | 행 / 셀 / 컬럼 선택 모드 설정 |
| `cwidth_opt`  | `'X'` 설정 시 컬럼 폭 자동 최적화 |
| `no_toolbar`  | `'X'` 설정 시 ALV 툴바 숨김 |
| `totals_bef`  | `'X'` 설정 시 합계 행을 데이터 맨 위에 표시 |
| `no_hgridln`  | `'X'` 설정 시 가로(Grid) 라인 숨김 |
| `no_vgridln`  | `'X'` 설정 시 세로(Grid) 라인 숨김 |
| `info_fname`  | **행(Row) 색상 정보**를 담고 있는 내부 테이블 필드명 |
| `ctab_fname`  | **셀(Cell) 색상 정보**를 담고 있는 내부 테이블 필드명 |

</br>

**< ALV Selection Mode (lvc_s_layo-sel_mode) >**

| 값(Value) | 선택 가능 범위 (Possible Selections) | 선택 컬럼 표시 (Selection Column) |
|-----------|--------------------------------------|-----------------------------------|
| space     | B와 동일                              | No                                |
| A         | 다중 행 선택<br>다중 컬럼 선택        | Yes                               |
| B         | 단일 행 선택<br>다중 컬럼 선택        | No                                |
| C         | 다중 행 선택<br>다중 컬럼 선택        | No                                |
| D         | 다중 행 선택<br>다중 컬럼 선택<br>셀 단위 선택 가능 | Yes |

</br>
</br>
</br>

### 3) ALV 임계값(Threshold) 아이콘 표시 – Exception Display
- 특정 조건에 따라 빨강/노랑/초록 아이콘 자동 표시
- `excp_fname` : 예외(아이콘) 값을 담고 있는 컬럼 이름을 ALV에 알려줌
- `excp_led` : 해당 컬럼 값을 신호등(LED) 아이콘으로 표시하도록 설정
- ALV Exception 컬럼은 `1 = 빨강` , `2 = 노랑` , `3 = 초록`
```abap
LOOP AT <itab> INTO <wa>.
  IF <조건1>.
    <wa>-<excp_field> = '1'.
  ELSEIF <조건2>.
    <wa>-<excp_field> = '2'.
  ELSE.
    <wa>-<excp_field> = '3'.
  ENDIF.

  MODIFY <itab> FROM <wa> TRANSPORTING <excp_field>.
ENDLOOP.

*&---------------------------------------------------------------------*

gs_layout-excp_fname = '<예외컬럼명>'.
gs_layout-excp_led   = 'X'.

*&---------------------------------------------------------------------*

CALL METHOD <alv_ref>->set_table_for_first_display
  EXPORTING
    is_layout = gs_layout
  CHANGING
    it_outtab = <itab>.
```
```abap
REPORT ZPROGB03_0029.

********* TOP *********
DATA: BEGIN OF gs_data.
        INCLUDE TYPE sbook.
DATA: excp_fld        TYPE char1,          " 예외(신호등) 값
      phone           TYPE scustom-telephone,
     END OF gs_data.
DATA gt_data LIKE TABLE OF gs_data.

********* F01 *********
LOOP AT gt_data INTO gs_data.

  IF gs_data-loccuram < 500.
    gs_data-excp_fld = '1'.   " 🔴 빨강
  ELSEIF gs_data-loccuram <= 800.
    gs_data-excp_fld = '2'.   " 🟡 노랑
  ELSE.
    gs_data-excp_fld = '3'.   " 🟢 초록
  ENDIF.

  MODIFY gt_data FROM gs_data
    TRANSPORTING excp_fld.    " 예외 컬럼만 반영

  CLEAR gs_data.
ENDLOOP.

********* F01 (LAYOUT) *********
gs_layout-excp_fname = 'EXCP_FLD'.   " 예외 아이콘 컬럼명
gs_layout-excp_led   = 'X'.          " LED(신호등) 아이콘

********* PBO *********
CALL METHOD go_alv->set_table_for_first_display
  EXPORTING
    is_layout = gs_layout
  CHANGING
    it_outtab = gt_data.
```
</br>
</br>
</br>

### 4) ALV 초기 정렬 기준 설정 (lvc_s_sort)
- ALV 최초 출력 시 정렬 기준을 지정
- **`set_sorter_criteria` 는 이미 생성된 ALV Grid에 정렬 기준만 새로 적용하는 메서드**
</br>

- `lvc_s_sort` : 정렬 기준 1개, `lvc_t_sort` : 정렬 기준 여러 개를 담는 테이블
- `spos` : 정렬 우선순위 (1, 2, 3 …)
- `up = 'X'` : 오름차순, `down = 'X'` : 내림차순
- `SUBTOT = 'X'` : 해당 정렬 필드 기준으로 소계 라인 출력하며, DO_SUM = 'X' 로 지정된 합계 필드가 있어야 소계 값이 계산·표시됨
```abap
DATA: gt_sort TYPE lvc_t_sort,
      gs_sort TYPE lvc_s_sort.

gs_sort-fieldname = '<FIELD_NAME>'.
gs_sort-spos      = <순번>.
gs_sort-up        = 'X'.   " 또는 gs_sort-down = 'X'
APPEND gs_sort TO gt_sort.
CLEAR gs_sort.

CALL METHOD <alv_ref>->set_table_for_first_display
  EXPORTING
    i_structure_name = '<DDIC>'
  CHANGING
    it_outtab = <itab>
    it_sort   = gt_sort.
```
```abap
REPORT ZPROGB03_0029.

********* TOP *********
DATA: gt_sorter TYPE lvc_t_sort,    " 정렬 기준 테이블
      gs_sorter TYPE lvc_s_sort.    " 정렬 기준 구조

********* F01 *********
FORM set_sorter.
  IF gt_sorter IS INITIAL.
    gs_sorter-fieldname = 'ORDER_DATE'. " 1순위 정렬 필드
    gs_sorter-spos      = 1.            " 정렬 우선순위
    gs_sorter-up        = 'X'.          " 오름차순
    gs_sorter-subtot    = 'X'.          " 소계 표시
    APPEND gs_sorter TO gt_sorter.
    CLEAR gs_sorter.

    gs_sorter-fieldname = 'LOCCURAM'.   " 2순위 정렬 필드
    gs_sorter-spos      = 2.            " 정렬 우선순위
    gs_sorter-down      = 'X'.          " 내림차순
    APPEND gs_sorter TO gt_sorter.
  ENDIF.
ENDFORM.

********* PBO *********
CALL METHOD go_alv->set_table_for_first_display
  EXPORTING
    i_structure_name = 'SBOOK'
  CHANGING
    it_outtab        = gt_data
    it_sort          = gt_sorter.
```
</br>
</br>
</br>

### 5) ALV 초기 필터 조건 설정 (LVC_S_FILT)
- ALV 최초 출력 시 특정 조건으로 데이터 필터링
- **`set_filter_criteria` 는 이미 생성된 ALV Grid에 필터 조건만 새로 적용하는 메서드**
- `SY-REPID` 시스템 변수 → 현재 실행 중인 프로그램의 리포트(프로그램) ID를 담고 있는 시스템 필드
</br>

- `lvc_s_filt` : 필터 조건 1개
- `lvc_t_filt` : 필터 조건 여러 개를 담는 테이블
- `fieldname` 는 ALV에서 필터를 적용할 컬럼명을 의미
- `sign` 은 조건을 포함(I)할지 제외(E)할지를 결정
- `option` 은 비교 방식으로 EQ(같음), BT(범위), GE/LE(이상·이하) 등을 지정
- `low` 는 비교에 사용되는 기준 값이며, BT 사용 시 시작값. `high` 는 BT 옵션 사용 시 범위의 종료값.
```abap
DATA: gt_filter TYPE lvc_t_filt,
      gs_filter TYPE lvc_s_filt.

gs_filter-fieldname = '<FIELD_NAME>'.
gs_filter-sign      = 'I'.
gs_filter-option    = 'EQ'.
gs_filter-low       = <VALUE>.
APPEND gs_filter TO gt_filter.
CLEAR gs_filter.

CALL METHOD <alv_ref>->set_table_for_first_display
  EXPORTING
    i_structure_name = '<DDIC>'
  CHANGING
    it_outtab = <itab>
    it_filter = gt_filter.
```
```abap
REPORT ZPROGB03_0029.

********* TOP *********
DATA: gt_filter TYPE lvc_t_filt,    " ALV 필터 조건 테이블
      gs_filter TYPE lvc_s_filt.    " ALV 필터 조건 구조

SELECTION-SCREEN BEGIN OF SCREEN 1100 AS SUBSCREEN.
  SELECT-OPTIONS: so_car2 FOR SDYN_CONN-CARRID DEFAULT 'DL', " 항공사 필터
                  so_con2 FOR SDYN_CONN-CONNID.              " 노선 필터
SELECTION-SCREEN END OF SCREEN 1100.

********* START-OF-SELECTION *********
START-OF-SELECTION.
  PERFORM get_data.                 " 최초 데이터 조회
  CALL SCREEN 100.                  " 메인 화면 호출

********* (SCREEN 100) PROCESS BEFORE OUTPUT *********
PROCESS BEFORE OUTPUT.
  MODULE status_0100.                            " 상태바
  CALL SUBSCREEN SUB01 INCLUDING sy-repid '1100'. " 필터 입력
  MODULE init_alv.                               " ALV 출력

********* (SCREEN 100) PROCESS AFTER INPUT *********
PROCESS AFTER INPUT.
  MODULE exit AT EXIT-COMMAND.                   " 종료 처리
  CALL SUBSCREEN SUB01.                          " 필터 입력 반영
  MODULE user_command_0100.                      " SEARCH 처리

********* PAI *********
MODULE user_command_0100 INPUT.
  CASE ok_code.
    WHEN 'SEARCH'.
      PERFORM set_filter.           " 필터 재적용
    WHEN 'BACK'.
      LEAVE TO SCREEN 0.
  ENDCASE.
ENDMODULE.

********* F01 *********
FORM set_filter.
  CLEAR: gt_filter, gs_filter.

  IF so_car2 IS NOT INITIAL.
    LOOP AT so_car2.
      gs_filter-fieldname = 'CARRID'.        " 필터 컬럼
      gs_filter-sign      = so_car2-sign.    " 포함/제외
      gs_filter-option    = so_car2-option.  " EQ / BT
      gs_filter-low       = so_car2-low.     " 기준값
      gs_filter-high      = so_car2-high.    " 종료값
      APPEND gs_filter TO gt_filter.
    ENDLOOP.
  ENDIF.

  IF so_con2 IS NOT INITIAL.
    CLEAR gs_filter.
    LOOP AT so_con2.
      gs_filter-fieldname = 'CONNID'.        " 필터 컬럼
      gs_filter-sign      = so_con2-sign.
      gs_filter-option    = so_con2-option.
      gs_filter-low       = so_con2-low.
      gs_filter-high      = so_con2-high.
      APPEND gs_filter TO gt_filter.
    ENDLOOP.
  ENDIF.

  CALL METHOD go_alv->set_filter_criteria
    EXPORTING
      it_filter = gt_filter.

ENDFORM.

********* PBO (INIT_ALV 내부) *********
CALL METHOD go_alv->set_table_for_first_display
  EXPORTING
    i_structure_name = 'SBOOK'
  CHANGING
    it_outtab = gt_data
    it_filter = gt_filter.
```
</br>
</br>
</br>

### 6) ALV Line Color (행 색상 제어)
- ALV 행(Line)에 색상을 적용하는 기능
- `INFO_FNAME` : ALV에게 “행 색상(Line Color) 정보가 들어있는 필드명”을 알려주는 설정
- `TYPE-POOLS COL.` 로 색상 코드 확인 가능 (필수)
```abap
TYPE-POOLS COL.
'C' && <color_constant> && <intensified> && <inverse>
```
- `C` : 색상 사용 표시
- `<color_constant>` : 색상 번호 (0~7)
- `<intensified>` : 진하게 표시 (1) / 기본 (0)
- `<inverse>` : 글자색 ↔ 배경색 반전 (1) / 기본 (0)
```abap
REPORT ZPROGB03_0029.

********* TOP *********
TYPE-POOLS col.

DATA: BEGIN OF gs_data.
        INCLUDE TYPE sbook.
DATA: col_fld TYPE char4, "예시)'C310'
     END OF gs_data.
DATA gt_data LIKE TABLE OF gs_data.
DATA gs_layout TYPE lvc_s_layo.

********* F01 *********
FORM get_data.
    LOOP AT gt_data INTO gs_data.
      IF gs_data-smoker = 'X'.
        gs_data-col_fld = 'C' && col_negative && '10'.
      ENDIF.
      MODIFY gt_data FROM gs_data.
      CLEAR: gs_data.
    ENDLOOP.
  ENDIF.
ENDFORM.

********* F01 *********
FORM set_layout.
  gs_layout-info_fname = 'COL_FLD'. 
ENDFORM.

********* PBO *********
CALL METHOD go_alv->set_table_for_first_display
  EXPORTING
    is_layout                     = gs_layout
  CHANGING
    it_outtab                     = gt_data
```
</br>
</br>
</br>

### 7) ALV Cell Color (셀 단위 색상 제어)
- ALV에서 특정 셀만 색상 변경하는 기능
- 행 색상과 달리 셀 색상용 내부테이블 사용
- 각 행마다 `lvc_t_scol` 타입 내부테이블을 가짐
- 색상 적용 후 `CTAB_FNAME` 으로 ALV에 전달해야 표시됨
- `CTAB_FNAME` : ALV에게 “셀 색상(Cell Color) 정보가 들어있는 필드명”을 알려주는 설정
</br>

- `lt_scol` : 이 행에서 색칠할 셀 목록 (`lvc_t_scol`)
- `ls_scol` : 셀 하나 색상 정보 (`lvc_s_scol`)
- `<ls_scol>-fname` : 색상을 적용할 컬럼(필드) 이름을 지정함.
- `<ls_scol>-color-col` : 해당 셀에 적용할 색상을 지정함.
- `<ls_scol>-color-int` : 색상을 진하게 표시할지 여부를 지정함.
- `<ls_scol>-color-inv` : 글자색과 배경색을 서로 바꿀지 여부를 지정함.
```abap
LVC_S_SCOL
 ├─ FNAME        "색칠할 컬럼명
 └─ COLOR        "색상 정보 구조체
     ├─ COL
     ├─ INT
     └─ INV
```
```abap
" 1. 출력 구조
DATA: BEGIN OF <gs_data>.
        INCLUDE TYPE <structure>.
DATA: <excp_fld> TYPE char1,
      <col_fld>  TYPE char4,        " Line Color
      <lt_scol>  TYPE lvc_t_scol,   " Cell Color
     END OF <gs_data>.
DATA <gt_data> LIKE TABLE OF <gs_data>.
DATA <ls_scol> TYPE lvc_s_scol.

" 2. 셀 색상 처리
LOOP AT <gt_data> INTO <gs_data>.
  IF <조건>.
    <ls_scol>-fname      = '<FIELDNAME>'.
    <ls_scol>-color-col  = <COLOR>.
    <ls_scol>-color-int  = '1'.
    <ls_scol>-color-inv  = '0'.
    APPEND <ls_scol> TO <gs_data>-<lt_scol>.
  ENDIF.
  MODIFY <gt_data> FROM <gs_data>
    TRANSPORTING <lt_scol>.
ENDLOOP.

" 3. Layout 연결
gs_layout-ctab_fname = '<lt_scol 필드명>'.

" 4. ALV 출력
CALL METHOD go_alv_grid->set_table_for_first_display
  EXPORTING
    is_layout = gs_layout
  CHANGING
    it_outtab = <gt_data>.
```
```abap
REPORT ZPROGB03_0029.

********* TOP *********
TYPE-POOLS col.

DATA: BEGIN OF gs_data.
        INCLUDE TYPE sbook.
DATA: lt_scol TYPE lvc_t_scol,   " 셀 색상 정보 (행 단위)
     END OF gs_data.
DATA gt_data LIKE TABLE OF gs_data.
DATA ls_scol TYPE lvc_s_scol.    " 셀 1개 색상 구조
DATA gs_layout TYPE lvc_s_layo.

********* F01 *********
FORM get_data.
  LOOP AT gt_data INTO gs_data.
    IF gs_data-smoker = 'X'.
      CLEAR ls_scol.
      ls_scol-fname = 'SMOKER'.      " 색칠할 컬럼
      ls_scol-color-col = '3'.       " 색상 번호
      ls_scol-color-int = '1'.       " 진하게
      ls_scol-color-inv = '0'.       " 반전 없음
      APPEND ls_scol TO gs_data-lt_scol.
    ENDIF.
    MODIFY gt_data FROM gs_data.
    CLEAR gs_data.
  ENDLOOP.
ENDFORM.

FORM set_layout.
  gs_layout-ctab_fname = 'LT_SCOL'.  
ENDFORM.

********* PBO *********
PERFORM set_layout.

CALL METHOD go_alv->set_table_for_first_display
  EXPORTING
    is_layout = gs_layout
  CHANGING
    it_outtab = gt_data.
```
</br>
</br>
</br>

### 8) 결과 확인

<img width="536" height="370" alt="image" src="https://github.com/user-attachments/assets/e036f5f4-8676-4972-9727-f6f3954d72af" />

</br>
</br>
</br>
</br>
</br>

---

</br>

## < 실습 코드 >
- layout 실습
</br>

### 실습 1
</br>

- 문제

<img width="497" height="276" alt="image" src="https://github.com/user-attachments/assets/3d4d776c-d9ab-4b3a-ae11-d5e9062edb65" />
</br>
</br>
</br>
</br>

**1) `TOP` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV_TOP
*&---------------------------------------------------------------------*

DATA: OK_CODE TYPE sy-ucomm,
      go_container TYPE REF TO cl_gui_custom_container,
      go_alv_grid TYPE REF TO cl_gui_alv_grid.
DATA: gs_layout TYPE LVC_S_LAYO.

DATA: BEGIN OF gs_flight.
        INCLUDE TYPE sflight.
DATA: excp TYPE CHAR1,
      END OF gs_flight.
DATA: gt_flight LIKE TABLE OF gs_flight.

START-OF-SELECTION.
  PERFORM get_data.
```
</br>
</br>

**2) `F01` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV_F01
*&---------------------------------------------------------------------*

FORM get_data.
  SELECT * FROM sflight
    INTO TABLE gt_flight
    WHERE carrid IN so_car
      AND connid IN so_con.
  IF sy-subrc <> 0.
    MESSAGE '데이터가 존재하지 않습니다.' TYPE 'E'.
  ELSE.
    LOOP AT gt_flight INTO gs_flight.
      IF gs_flight-seatsocc < 50.
        gs_flight-excp = '1'.
      ELSEIF gs_flight-seatsocc >= 50 AND gs_flight-seatsocc <= 200.
        gs_flight-excp = '2'.
      ELSE.
        gs_flight-excp = '3'.
      ENDIF.

      MODIFY gt_flight FROM gs_flight TRANSPORTING excp.
      CLEAR gs_flight.
    ENDLOOP.
  ENDIF.
ENDFORM.

*&---------------------------------------------------------------------*

FORM set_layout.
  gs_layout-grid_title = 'Flight List'.
  gs_layout-zebra = 'X'.
  gs_layout-sel_mode = 'C'.
  gs_layout-excp_fname = 'EXCP'.
ENDFORM.
```
</br>
</br>

**3) `PBO` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV_O01
*&---------------------------------------------------------------------*

PERFORM set_layout.
  CALL METHOD go_alv_grid->set_table_for_first_display
    EXPORTING
      i_structure_name              = 'sflight'
      is_layout                     = gs_layout
    CHANGING
      it_outtab                     = gt_flight
    EXCEPTIONS
      invalid_parameter_combination = 1
      program_error                 = 2
      too_many_lines                = 3
      others                        = 4.
ENDMODULE.
```
</br>
</br>

**4) 결과 확인**

<img width="499" height="384" alt="image" src="https://github.com/user-attachments/assets/ac3e549d-a76c-48cd-b8b3-da963ca38b9a" />
</br>
</br>
</br>
</br>
</br>
</br>

### 실습 2
</br>

- 문제

<img width="474" height="283" alt="image" src="https://github.com/user-attachments/assets/c6b45c6d-2851-41f2-97a9-1a145c147234" />

</br>
</br>
</br>
</br>

**1) `TOP` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV_TOP
*&---------------------------------------------------------------------*

DATA: gs_layout TYPE LVC_S_LAYO.

DATA: BEGIN OF gs_flight.
        INCLUDE TYPE sflight.
DATA: excp TYPE CHAR1,
      color TYPE C LENGTH 4,
      lt_col TYPE LVC_T_SCOL,
      END OF gs_flight.
DATA: gt_flight LIKE TABLE OF gs_flight.
DATA: ls_col TYPE LVC_S_SCOL.
```
</br>
</br>

**2) `F01` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV_F01
*&---------------------------------------------------------------------*

FORM get_data.
  SELECT * FROM sflight
    INTO CORRESPONDING FIELDS OF TABLE gt_flight
    WHERE carrid IN so_car
      AND connid IN so_con.
  IF sy-subrc <> 0.
    MESSAGE '데이터가 존재하지 않습니다.' TYPE 'E'.
  ELSE.
    LOOP AT gt_flight INTO gs_flight.
      IF gs_flight-seatsocc < 50.
        gs_flight-excp = '1'.
      ELSEIF gs_flight-seatsocc >= 50 AND gs_flight-seatsocc <= 200.
        gs_flight-excp = '2'.
      ELSE.
        gs_flight-excp = '3'.
      ENDIF.

      IF gs_flight-fldate+0(4) = sy-datum+0(4).
        gs_flight-color = 'C' && col_positive && 10.
      ENDIF.

      IF gs_flight-seatsmax - gs_flight-seatsocc  < 10.
        ls_col-fname = 'SEATSMAX'.
        ls_col-color-col = '6'.
        ls_col-color-int = '0'.
        ls_col-color-inv = '1'.
        APPEND ls_col TO gs_flight-lt_col.
        CLEAR ls_col.

        ls_col-fname = 'SEATSOCC'.
        ls_col-color-col = '6'.
        ls_col-color-int = '0'.
        ls_col-color-inv = '1'.

        APPEND ls_col TO gs_flight-lt_col.
      ENDIF.

      MODIFY gt_flight FROM gs_flight TRANSPORTING excp color lt_col.
      CLEAR gs_flight.
    ENDLOOP.
  ENDIF.
ENDFORM.

*&---------------------------------------------------------------------*

FORM set_layout .
  gs_layout-grid_title = 'Flight List'.
  gs_layout-zebra = 'X'.
  gs_layout-sel_mode = 'C'.
  gs_layout-excp_fname = 'EXCP'.
  gs_layout-info_fname = 'COLOR'.
  gs_layout-ctab_fname = 'LT_COL'.
ENDFORM.
```
</br>
</br>

**3) `PBO` 모듈**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV_O01
*&---------------------------------------------------------------------*

PERFORM set_layout.
    CALL METHOD go_alv_grid->set_table_for_first_display
      EXPORTING
        i_structure_name              = 'sflight'
        is_variant                    = gs_variant
        i_save                        = 'A'
        is_layout                     = gs_layout
      CHANGING
        it_outtab                     = gt_flight
      EXCEPTIONS
        invalid_parameter_combination = 1
        program_error                 = 2
        too_many_lines                = 3
        others                        = 4.
    IF sy-subrc <> 0.
      MESSAGE A012(BC405_408).
    ENDIF.
```
</br>
</br>

**4) 결과 확인**

<img width="399" height="308" alt="image" src="https://github.com/user-attachments/assets/fd86219f-6de5-48d8-8e4b-006378b0b7a9" />

</br>
</br>

# 12/30
</br>
</br>

## <  핵심 개념 >
</br>

- **1) ALV 표준 툴바 버튼 제어**
- **2) ALV Field Catalog**
</br>

- **SELECT-OPTIONS는 `Selection Screen` 에서만 가능**

</br>
</br>

---

</br>

## < ABAP 객체 생성 기본 문법 >
</br>


### 1) ALV 표준 툴바 버튼 제어
- ALV Grid에서 기본 제공되는 표준 버튼(필터, 합계 등)을 화면에서 숨김 → 기능은 유지되고 화면에서만 제거
</br>

- `CL_GUI_ALV_GRID` → ALV Grid 화면을 생성·제어하는 표준 클래스
- `UI_FUNCTIONS` → 숨길 Function Code들을 담는 내부테이블 타입
- `IT_TOOLBAR_EXCLUDING` → ALV에서 제외할 툴바 기능 전달 파라미터
- `GS_LAYOUT-NO_TOOLBAR` → ALV 툴바 영역 자체를 통째로 숨김 (툴바 자체 제거)
</br>

- `MC_FC_*` → ALV 개별 버튼 1개를 의미하는 Function Code
- `MC_MB_*` → 여러 기능이 묶인 메뉴 버튼 Function Code
- `MC_FC_EXCL_ALL` → ALV 툴바 전체 버튼을 숨기는 Function Code (버튼만 숨김)
```abap
********* TOP *********
DATA: <gt_excluded> TYPE ui_functions.

********* F01 *********
APPEND cl_gui_alv_grid=><function_code> TO <gt_excluded>.

********* PBO *********
go_alv_grid->set_table_for_first_display(
  EXPORTING
    i_structure_name     = '<DDIC 구조>'
    it_toolbar_excluding = <gt_excluded>
  CHANGING
    it_outtab            = <itab>
).
```
```abap
REPORT ZPROGB03_0029.

********* TOP *********
DATA gt_uifunc TYPE ui_functions.      " ALV 툴바 제외 기능 목록

********* F01 *********
APPEND cl_gui_alv_grid=>mc_fc_filter TO gt_uifunc.    " 필터(Filter) 버튼 숨김
APPEND cl_gui_alv_grid=>mc_mb_sum TO gt_uifunc.       " 합계/소계 메뉴 전체 숨김
APPEND cl_gui_alv_grid=>mc_fc_excl_all TO gt_uifunc.  " 모든 표준 툴바 버튼 숨김

********* PBO *********
CALL METHOD go_alv->set_table_for_first_display
  EXPORTING
    i_structure_name     = 'SBOOK'
    it_toolbar_excluding = gt_uifunc
  CHANGING
    it_outtab            = gt_data.
```
</br>
</br>

### 2) ALV Field Catalog
- ALV 컬럼의 제목, 순서, 숨김, 아이콘·단위 등 화면 표시 방식을 제어하는 설정
- 구조에 없는 컬럼을 추가하거나, 기존 컬럼의 출력 형태를 변경하기 위해 사용
- `LVC_T_FCAT` → Field Catalog 전체를 담는 내부테이블
- `LVC_S_FCAT` → 컬럼 1개에 대한 속성 구조
</br>
</br>

**1) 기본 컬럼 정의 / DDIC 참조**
- `FIELDNAME` → 내부테이블의 컬럼명
- `REF_FIELD` → DDIC에서 참조할 필드명
- `REF_TABLE` → DDIC에서 참조할 테이블/구조명

**2) 컬럼 표시 방식 제어**
- `ICON` → `X` 면 아이콘으로 표시, 공백이면 일반 값
- `CHECKBOX` → `X` 면 값을 읽기 전용 체크박스로 표시하고, 공백이면 일반 값으로 표시
- `NO_OUT` → `X` 면 컬럼을 ALV 화면에서 숨김, 공백이면 정상 표시
- `TECH` → `X` 면 기술용 컬럼으로 처리하고, 공백이면 일반 사용자 컬럼으로 표시

**3) 컬럼 제목 / 위치 / 크기**
- `COLTEXT` → 컬럼 헤더에 표시될 제목 문자열, 미지정 시 DDIC 텍스트 사용
- `TOOLTIP` → 컬럼 헤더에 마우스를 올렸을 때 표시되는 설명 문구
- `COL_POS` → 컬럼의 출력 위치 번호, 숫자가 작을수록 왼쪽에 표시
- `OUTPUTLEN` → 컬럼 출력 폭(너비)

**4) 금액(Currency) / 수량(Unit) 포맷 설정**
- `CFIELDNAME` → 금액 컬럼에 대해 행별 통화 필드 지정
- `CURRENCY` → 금액 컬럼 전체에 고정 통화 코드 적용
- `QFIELDNAME` → 수량 컬럼에 대해 행별 단위 필드 지정
- `QUANTITY` → 수량 컬럼 전체에 고정 단위 적용

**5) 집계 / 키 / 인터랙션**
- `DO_SUM` → `X` 면 합계 라인을 생성하고, 공백이면 합계 계산 안 함
- `NO_SUM` → `X` 면 합계 기능을 비활성화하고, 공백이면 합계 가능
- `KEY` → `X` 면 키 컬럼으로 고정 표시되고, 공백이면 일반 컬럼
- `HOTSPOT` → `X` 면 클릭 이벤트가 발생하고, 공백이면 일반 텍스트 컬럼

**6) 강조 / 값 표시 포맷**
- `EMPHASIZE` → 컬럼 값을 색상·강조·반전 효과로 표시
- `DECIMALS_O` → 표시할 소수점 자릿수 지정
- `DECMLFIELD` → 소수점 자릿수를 행별 필드로 제어
- `ROUND` → `X` 면 반올림 처리하고, 공백이면 반올림 안 함
- `ROUNDFIELD` → 반올림 자릿수를 행별 필드로 제어
- `EDIT_MASK` → 출력 시 편집 마스크 적용
- `JUST` → 값 정렬 방식(L/R/C) 지정
- `LZERO` → `X` 면 앞의 0을 표시하고, 공백이면 0 제거
- `NO_ZERO` → `X` 면 값이 0일 때 표시하지 않고, 공백이면 0 표시
- `NO_SIGN` → `X` 면 부호(+/–)를 숨기고, 공백이면 부호 표시
  
</br>
</br>
</br>

**1) 전역 구조(DDIC) 필드 그대로 사용하는 경우**
- `FIELDNAME` 만 지정
- `REF_FIELD` / `REF_TABLE` 자동
  
**2) 전역 구조 필드 + 속성 조정하는 경우**
- `FIELDNAME` + `REF_FIELD` + `REF_TABLE` 지정
- 길이·텍스트 등만 추가 설정
  
**3) 로컬 타입(내부 정의 타입) 사용하는 경우**
- `FIELDNAME` 만 사용
- `REF_FIELD` / `REF_TABLE` 사용 ❌
- 컬럼 속성 전부 직접 정의
</br>
</br>

```abap
********* TOP *********
TYPE-POOLS: icon.

TYPES: BEGIN OF <gs_type>.
  INCLUDE TYPE <DDIC_STRUCTURE>.
  <add_field_1> TYPE <ddic_type_1>.
  <add_field_2> TYPE <ddic_type_2>.
END OF <gs_type>.
DATA: <gt_outtab> TYPE TABLE OF <gs_type>.

" Field Catalog 선언
DATA: <gt_fcat> TYPE lvc_t_fcat,
      <gs_fcat> TYPE lvc_s_fcat.

********* F01 *********
<gs_fcat>-fieldname = '<ADD_FIELD_1>'.      " 추가 컬럼 1
<gs_fcat>-ref_field = '<REF_FIELD>'.
<gs_fcat>-ref_table = '<REF_TABLE>'.
<gs_fcat>-col_pos   = <N>.
APPEND <gs_fcat> TO <gt_fcat>.
CLEAR <gs_fcat>.

<gs_fcat>-fieldname = '<ADD_FIELD_2>'.      " 추가 컬럼 2 (아이콘 등 표현 변경)
<gs_fcat>-icon      = 'X'.
<gs_fcat>-coltext   = '<TEXT>'.
APPEND <gs_fcat> TO <gt_fcat>.
CLEAR <gs_fcat>.

<gs_fcat>-fieldname = '<ORIGINAL_FIELD>'.   " 기존 컬럼 숨김
<gs_fcat>-no_out    = 'X'.
APPEND <gs_fcat> TO <gt_fcat>.
CLEAR <gs_fcat>.

********* PBO *********
<go_alv>->set_table_for_first_display(
  EXPORTING
    i_structure_name = '<DDIC_STRUCTURE>'
  CHANGING
    it_outtab        = <gt_outtab>
    it_fieldcatalog  = <gt_fcat>
).
```
```abap
REPORT ZPROGB03_0029.

********* TOP *********
TYPE-POOLS: icon.

DATA: BEGIN OF gs_data.
        INCLUDE TYPE sbook.
DATA:   cancelled_icon TYPE icon-id,           " 취소 아이콘
        phone          TYPE scustom-telephone,  " 전화번호
      END OF gs_data.
DATA gt_data LIKE TABLE OF gs_data.

DATA: BEGIN OF ls_custom.
        id        TYPE s_customer,
        telephone TYPE s_phoneno,
      END OF ls_custom.
DATA lt_custom LIKE TABLE OF ls_custom.

DATA: gt_fcat TYPE lvc_t_fcat,                 " Field Catalog itab
      gs_fcat TYPE lvc_s_fcat.                 " Field Catalog str

********* F01 (데이터 조회) *********
SELECT *
  FROM sbook
  INTO CORRESPONDING FIELDS OF TABLE gt_data.

SELECT id telephone
  FROM scustom
  INTO TABLE lt_custom
  FOR ALL ENTRIES IN gt_data
  WHERE id = gt_data-customid
    AND telephone <> space.

********* F01 (데이터 가공) *********
LOOP AT gt_data INTO gs_data.

  IF gs_data-cancelled = 'X'.                  " 취소 여부 아이콘
    gs_data-cancelled_icon = icon_cancel.
  ENDIF.

  READ TABLE lt_custom INTO ls_custom           " 전화번호 매핑
       WITH KEY id = gs_data-customid.
  IF sy-subrc = 0.
    gs_data-phone = ls_custom-telephone.
  ENDIF.

  MODIFY gt_data FROM gs_data
    TRANSPORTING cancelled_icon phone.

  CLEAR gs_data.
ENDLOOP.

********* F01 (Field Catalog 설정) *********
CLEAR gs_fcat.
gs_fcat-fieldname = 'CANCELLED_ICON'.   " 취소 아이콘 표시
gs_fcat-icon      = 'X'.
gs_fcat-coltext   = 'Cancelled'.
APPEND gs_fcat TO gt_fcat.

CLEAR gs_fcat.
gs_fcat-fieldname = 'CANCELLED'.        " 기존 취소 컬럼 숨김
gs_fcat-no_out    = 'X'.
APPEND gs_fcat TO gt_fcat.

CLEAR gs_fcat.
gs_fcat-fieldname = 'PASSFORM'.         " 여권 형식 숨김
gs_fcat-no_out    = 'X'.
APPEND gs_fcat TO gt_fcat.

CLEAR gs_fcat.
gs_fcat-fieldname = 'PASSBIRTH'.        " 여권 생년월일 숨김
gs_fcat-no_out    = 'X'.
APPEND gs_fcat TO gt_fcat.

CLEAR gs_fcat.
gs_fcat-fieldname = 'PHONE'.            " 전화번호 표시
gs_fcat-ref_field = 'TELEPHONE'.
gs_fcat-ref_table = 'SCUSTOM'.
gs_fcat-col_pos   = 4.
APPEND gs_fcat TO gt_fcat.

CLEAR gs_fcat.
gs_fcat-fieldname = 'SMOKER'.           " 체크박스
gs_fcat-checkbox = 'X'.
APPEND gs_fcat TO gt_fcat.

CLEAR gs_fcat.
gs_fcat-fieldname = 'INVOICE'.          " 체크박스
gs_fcat-checkbox = 'X'.
APPEND gs_fcat TO gt_fcat.

CLEAR gs_fcat.
gs_fcat-fieldname = 'CLASS'.            " 컬럼 강조 표시
gs_fcat-emphasize = 'C510'.
APPEND gs_fcat TO gt_fcat.

CLEAR gs_fcat.
gs_fcat-fieldname = 'LOCCURAM'.          " 합계 적용
gs_fcat-do_sum    = 'X'.
APPEND gs_fcat TO gt_fcat.

********* PBO *********
CALL METHOD go_alv_grid->set_table_for_first_display
  EXPORTING
    i_structure_name = 'SBOOK'
  CHANGING
    it_outtab        = gt_data
    it_fieldcatalog  = gt_fcat.
```

- 결과출력
  
<img width="626" height="343" alt="image" src="https://github.com/user-attachments/assets/3918147c-8030-496b-8685-9a8cb5eca11b" />

</br>
</br>
</br>
</br>

---

</br>

## < 실습 코드 >
</br>

### 실습 1
- layout 실습
</br>
</br>

**1) `TOP` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV2_TOP
*&---------------------------------------------------------------------*

DATA: OK_CODE TYPE sy-ucomm,
      go_container TYPE REF TO cl_gui_custom_container,
      go_alv_grid TYPE REF TO cl_gui_alv_grid.
DATA: gs_layout TYPE LVC_S_LAYO.

DATA: BEGIN OF gs_flight.
        INCLUDE TYPE sflight.
DATA: color TYPE C LENGTH 4,
      lt_field_colors TYPE LVC_T_SCOL,
      END OF gs_flight.
DATA: gt_flight LIKE TABLE OF gs_flight.
DATA: ls_field_colors TYPE LVC_S_SCOL.

START-OF-SELECTION.
  PERFORM get_data.
  CALL SCREEN 100.
```
</br>

**2) `F01` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV2_F01
*&---------------------------------------------------------------------*

TYPE-POOLS COL.

FORM get_data.
  SELECT * FROM sflight
    INTO CORRESPONDING FIELDS OF TABLE gt_flight
    WHERE carrid IN so_car
      AND connid IN so_con.
  IF sy-subrc <> 0.
    MESSAGE '데이터가 존재하지 않습니다.' TYPE 'E'.
  ELSE.
    LOOP AT gt_flight INTO gs_flight.
      IF gs_flight-fldate+4(2) = sy-datum+4(2).
        gs_flight-color = 'C' && col_negative && 10.
      ENDIF.

      IF gs_flight-PLANETYPE = '747-400'.
        ls_field_colors-fname = 'PLANETYPE'.
        ls_field_colors-color-col = col_positive.
        ls_field_colors-color-int = '1'.
        ls_field_colors-color-inv = '0'.
        APPEND ls_field_colors TO gs_flight-lt_field_colors.
      ENDIF.

      MODIFY gt_flight FROM gs_flight TRANSPORTING excp color lt_field_colors.
      CLEAR gs_flight.
    ENDLOOP.
  ENDIF.
ENDFORM.

*&---------------------------------------------------------------------*

FORM set_layout .
  gs_layout-info_fname = 'COLOR'.
  gs_layout-ctab_fname = 'LT_FIELD_COLORS'.
  gs_layout-no_hgridln = 'X'.
  gs_layout-no_vgridln = 'X'.
ENDFORM.
```
</br>

**3) `PBO` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV2_O01
*&---------------------------------------------------------------------*

PERFORM set_layout.
  CALL METHOD go_alv_grid->set_table_for_first_display
    EXPORTING
      i_structure_name              = 'sflight'
      is_layout                     = gs_layout
    CHANGING
      it_outtab                     = gt_flight
    EXCEPTIONS
      invalid_parameter_combination = 1
      program_error                 = 2
      too_many_lines                = 3
      others                        = 4.
ENDMODULE.
```
</br>

**4) `PAI` 모듈**
```abap
MODULE user_command_0100 INPUT.
  CASE OK_CODE.
    WHEN 'BACK'.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE exit INPUT.
  CASE OK_CODE.
    WHEN 'EXIT'.
      LEAVE PROGRAM.
      PERFORM free_alv.
    WHEN 'CANCEL'.
      PERFORM free_alv.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```

</br>

**5) 결과 출력**

<img width="433" height="332" alt="image" src="https://github.com/user-attachments/assets/738970ec-5c0c-419b-955d-116a19b81e09" />
</br>
</br>
</br>
</br>
</br>
</br>

### 실습 2
- Field Catalog 실습
- 위 코드 이어서 작성
</br>
</br>

**1) `TOP` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV2_TOP
*&---------------------------------------------------------------------*

DATA: gt_fcat TYPE LVC_T_FCAT,
      gs_fcat TYPE LVC_S_FCAT.

DATA: BEGIN OF gs_flight.
        INCLUDE TYPE sflight.
DATA: excp TYPE CHAR1,
      color TYPE C LENGTH 4,
      lt_field_colors TYPE LVC_T_SCOL,
      changes_possible TYPE icon-id,
      END OF gs_flight.
DATA: gt_flight LIKE TABLE OF gs_flight.
```
</br>

**2) `F01` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV2_F01
*&---------------------------------------------------------------------*

TYPE-POOLS: COL, ICON.

FORM get_data.
  SELECT * FROM sflight
    INTO CORRESPONDING FIELDS OF TABLE gt_flight
    WHERE carrid IN so_car
      AND connid IN so_con.
  IF sy-subrc <> 0.
    MESSAGE '데이터가 존재하지 않습니다.' TYPE 'E'.
  ELSE.
    LOOP AT gt_flight INTO gs_flight.
      IF gs_flight-seatsocc = 0.
        gs_flight-excp = '1'.
      ELSEIF gs_flight-seatsocc < 50.
        gs_flight-excp = '2'.
      ELSE.
        gs_flight-excp = '3'.
      ENDIF.

      IF gs_flight-fldate+4(2) = sy-datum+4(2).
        gs_flight-color = 'C' && col_negative && 10.
      ENDIF.

      IF gs_flight-fldate < sy-datum.
        gs_flight-changes_possible = ICON_SPACE.
      ELSE.
        gs_flight-changes_possible = ICON_OKAY.
      ENDIF.

      IF gs_flight-PLANETYPE = '747-400'.
        ls_field_colors-fname = 'PLANETYPE'.
        ls_field_colors-color-col = col_positive.
        ls_field_colors-color-int = '1'.
        ls_field_colors-color-inv = '0'.
        APPEND ls_field_colors TO gs_flight-lt_field_colors.
      ENDIF.

      MODIFY gt_flight FROM gs_flight
        TRANSPORTING excp color lt_field_colors changes_possible.
      CLEAR gs_flight.
    ENDLOOP.
  ENDIF.
ENDFORM.

*&---------------------------------------------------------------------*

FORM set_fcat.
  CLEAR gs_fcat.
  gs_fcat-fieldname = 'SEATSOCC'.
  gs_fcat-do_sum = 'X'.
  APPEND gs_fcat TO gt_fcat.

  CLEAR gs_fcat.
  gs_fcat-fieldname = 'PAYMENTSUM'.
  gs_fcat-no_out = 'X'.
  APPEND gs_fcat TO gt_fcat.

  CLEAR gs_fcat.
  gs_fcat-fieldname = 'CHANGES_POSSIBLE'.
  gs_fcat-icon = 'X'.
  gs_fcat-coltext = 'Changes Possible'.
  gs_fcat-tooltip = 'Are changes still possible?'.
  gs_fcat-col_pos = 5.
  APPEND gs_fcat TO gt_fcat.

  CLEAR gs_fcat.
  gs_fcat-fieldname = 'EXCP'.
  gs_fcat-coltext = 'traffic light'.
  APPEND gs_fcat TO gt_fcat.
ENDFORM.
```
</br>

**3) `PBO` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV2_O01
*&---------------------------------------------------------------------*

PERFORM set_layout.
PERFORM set_fcat.
CALL METHOD go_alv_grid->set_table_for_first_display
  EXPORTING
    i_structure_name              = 'SFLIGHT'
    is_variant                    = gs_variant
    i_save                        = 'A'
    is_layout                     = gs_layout
  CHANGING
    it_outtab                     = gt_flight
    IT_FIELDCATALOG               = gt_fcat
  EXCEPTIONS
    invalid_parameter_combination = 1
    program_error                 = 2
    too_many_lines                = 3
    others                        = 4.
IF sy-subrc <> 0.
  MESSAGE A012(BC405_408).
ENDIF.
```
</br>

**4) 결과 출력**

<img width="530" height="403" alt="image" src="https://github.com/user-attachments/assets/fee92021-0c8d-45a3-8159-d042cbf869df" />

</br>
</br>
</br>
</br>
</br>
</br>

### 실습 3
</br>

- 문제

<img width="485" height="288" alt="image" src="https://github.com/user-attachments/assets/b550caff-ae1b-44b1-b987-1829e83d7599" />
</br>
</br>
</br>

**1) `Program` 코드 생성**
```abap
INCLUDE ZBC400_B03_PRACTICE7_TOP.
INCLUDE ZBC400_B03_PRACTICE7_F01.
INCLUDE ZBC400_B03_PRACTICE7_O01.
INCLUDE ZBC400_B03_PRACTICE7_I01.

AT SELECTION-SCREEN ON BLOCK blk1.
  IF so_car IS INITIAL AND so_con IS INITIAL AND so_fdt IS INITIAL.
    MESSAGE '전부 입력하지 않았습니다.' TYPE 'E'.
  ENDIF.

START-OF-SELECTION.
  PERFORM set_data.
  CALL SCREEN 100.
```
</br>

**2) `TOP` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_B03_PRACTICE7_TOP
*&---------------------------------------------------------------------*

DATA: OK_CODE TYPE sy-ucomm.

DATA: go_cont TYPE REF TO cl_gui_custom_container,
      go_alv TYPE REF TO cl_gui_alv_grid.

DATA: BEGIN OF gs_data.
        INCLUDE TYPE ZSCARRFLIGHT_B03.
DATA: seatsrem TYPE INT4,
      class TYPE sbook-CLASS,
      END OF gs_data.
DATA: gt_data LIKE TABLE OF gs_data,
      gt_sflight TYPE TABLE OF sflight,
      gt_scarr TYPE TABLE OF scarr,
      gs_scarr LIKE LINE OF gt_scarr,
      gt_sbook TYPE TABLE OF sbook,
      gs_sbook LIKE LINE OF gt_sbook.

DATA: gt_fcat TYPE LVC_T_FCAT,
      gs_fcat TYPE LVC_S_FCAT,
      gt_sort TYPE LVC_T_SORT,
      gs_sort TYPE LVC_S_SORT.

SELECTION-SCREEN BEGIN OF BLOCK blk1 WITH FRAME.
  SELECT-OPTIONS: so_car FOR gs_data-carrid,
                  so_con FOR gs_data-connid,
                  so_fdt FOR gs_data-fldate.
SELECTION-SCREEN END OF BLOCK blk1.
```
</br>

**3) `F01` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_B03_PRACTICE7_F01
*&---------------------------------------------------------------------*

FORM set_data.
  SELECT *
    FROM sflight
    INTO CORRESPONDING FIELDS OF TABLE gt_data
    WHERE carrid IN so_car
      AND connid IN so_con
      AND fldate IN so_fdt.

  SELECT *
    FROM scarr
    INTO CORRESPONDING FIELDS OF TABLE gt_scarr
    FOR ALL ENTRIES IN gt_data
    WHERE carrid = gt_data-carrid.

  SELECT *
    FROM sbook
    INTO CORRESPONDING FIELDS OF TABLE gt_sbook
    FOR ALL ENTRIES IN gt_data
    WHERE carrid = gt_data-carrid
      AND connid = gt_data-connid
      AND fldate = gt_data-fldate.
  SORT gt_sbook.  " 첫번째 인덱스의 class를 가져오므로

  LOOP AT gt_data INTO gs_data.
    READ TABLE gt_scarr INTO gs_scarr WITH KEY carrid = gs_data-carrid
      TRANSPORTING carrname currcode.
    READ TABLE gt_sbook INTO gs_sbook
      WITH KEY carrid = gs_data-carrid
               connid = gs_data-connid
               fldate = gs_data-fldate
      TRANSPORTING class.
    gs_data-class = gs_sbook-class.
    gs_data-carrname = gs_scarr-carrname.
    gs_data-currcode = gs_scarr-currcode.
    gs_data-seatsrem = gs_data-seatsmax - gs_data-seatsocc.
    MODIFY gt_data FROM gs_data TRANSPORTING carrname currcode seatsrem class.
    CLEAR gs_data.
  ENDLOOP.
ENDFORM.

*&---------------------------------------------------------------------*

FORM set_fcat.
  CLEAR gs_fcat.
  gs_fcat-fieldname = 'SEATSREM'.
  gs_fcat-coltext = 'Seats Remain'.
  gs_fcat-col_pos = 3.
  APPEND gs_fcat TO gt_fcat.

  CLEAR gs_fcat.
  gs_fcat-fieldname = 'CLASS'.
  gs_fcat-ref_field = 'CLASS'.
  gs_fcat-ref_table = 'SBOOK'.
  gs_fcat-col_pos = 2.
  APPEND gs_fcat TO gt_fcat.

  CLEAR gs_fcat.
  gs_fcat-fieldname = 'PRICE'.
  gs_fcat-do_sum = 'X'.
  APPEND gs_fcat TO gt_fcat.
ENDFORM.

*&---------------------------------------------------------------------*

FORM set_sort.
  CLEAR gs_sort.
  gs_sort-fieldname = 'CLASS'.
  gs_sort-spos = 1.
  gs_sort-up = 'X'.
  gs_sort-subtot = 'X'.
  APPEND gs_sort TO gt_sort.
ENDFORM.
```
</br>

**4) `PBO` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_B03_PRACTICE7_O01
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.
 SET PF-STATUS 'S100'.
* SET TITLEBAR 'xxx'.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE init_alv OUTPUT.
  IF go_cont IS INITIAL.
    CREATE OBJECT go_cont
      EXPORTING
        container_name              = 'AREA'
      EXCEPTIONS
        cntl_error                  = 1
        cntl_system_error           = 2
        create_error                = 3
        lifetime_error              = 4
        lifetime_dynpro_dynpro_link = 5
        others                      = 6.
    IF sy-subrc <> 0.
    ENDIF.

    CREATE OBJECT go_alv
      EXPORTING
        i_parent          = go_cont
      EXCEPTIONS
        error_cntl_create = 1
        error_cntl_init   = 2
        error_cntl_link   = 3
        error_dp_create   = 4
        others            = 5.
    IF sy-subrc <> 0.
    ENDIF.

    PERFORM set_fcat.
    PERFORM set_sort.
    CALL METHOD go_alv->set_table_for_first_display
      EXPORTING
        i_structure_name              = 'ZSCARRFLIGHT_B03'
      CHANGING
        it_outtab                     = gt_data
        it_fieldcatalog               = gt_fcat
        it_sort                       = gt_sort.
    IF sy-subrc <> 0.
    ENDIF.

  ENDIF.
ENDMODULE.
```
</br>

**5) `PAI` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_B03_PRACTICE7_I01
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.
  CASE OK_CODE.
    WHEN 'BACK'.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE exit INPUT.
  CASE OK_CODE.
    WHEN 'CANCEL'.
      LEAVE TO SCREEN 0.
    WHEN 'EXIT'.
      LEAVE PROGRAM.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```
</br>

**6) 결과 확인**

<img width="500" height="146" alt="image" src="https://github.com/user-attachments/assets/326940de-3a7a-4697-9af2-cb232651886c" />
</br>

<img width="515" height="357" alt="image" src="https://github.com/user-attachments/assets/765b20d2-30a5-4a6a-a180-8d5741bd635e" />

</br>
</br>

# 12/31
</br>
</br>

## < 핵심 개념 >
</br>

- **1) ALV Grid 이벤트 처리 정리 (`CLASS-METHODS`)**
- **2) ALV Hotspot 이벤트 처리**
</br>

- **ALV 핫스팟 클릭은 OKCODE가 없어서 PAI를 안 탐**
- **`i_structure_name` 는 DDIC(Dictionary)에 정의된 구조만 가능**
</br>
</br>

---

</br>

## < ABAP 객체 생성 기본 문법 >
</br>

### 1) ALV Grid 이벤트 처리 정리
- ALV 화면에서 발생하는 사용자 동작을 처리
- `CL_GUI_ALV_GRID` : ALV Grid 이벤트를 제공하는 클래스
</br>

- `Instance Attribute` → 객체마다 메모리 가지는 속성 (DATA)
- `Instance Method` → 객체마다 호출되는 메서드 (METHODS)
- `Static Attribute` → 클래스마다 하나만 존재하는 속성 (CLASS-DATA)
- `Static Method` → 클래스마다 하나만 존재하는 메서드 (CLASS-METHODS)
- `Constants` → 값 변경 불가한 고정값 (CONSTANTS)
</br>
</br>

**< ALV Grid 이벤트 / 파라미터 >**
- 이벤트: 언제 발생했는가
- 파라미터: 발생했을 때 어떤 정보가 넘어오는가

| 이벤트 | 설명 |
|--------|------|
| `DOUBLE_CLICK` | 셀을 더블클릭했을 때 발생 |
| `PRINT_TOP_OF_PAGE` | 출력 시 페이지 상단 처리 |
| `USER_COMMAND` | ALV 버튼 클릭 시 발생 |
| `TOOLBAR` | ALV 툴바 생성 시 발생 |
  
| 파라미터 | 설명 |
|----------|------|
| `ES_ROW_NO` | 화면 기준 행 번호 (정렬/필터 적용 후 기준) |
| `E_ROW_ID` | 내부 테이블 기준 행 인덱스 |
| `E_COLUMN` | 더블클릭한 컬럼 정보 (`fieldname`) |
| `E_COLUMN_ID` | 핫스팟 클릭한 컬럼명 |
| `E_UCOMM` | 눌린 버튼의 Function Code |
| `E_OBJECT` | 툴바 버튼 추가/제어 객체 |
| `E_INTERACTIVE` | 인터랙티브 ALV 여부 |
| `SENDER` | 이벤트를 발생시킨 ALV 객체 |
| `ER_DATA_CHANGED` | 변경된 셀 정보 객체 |
| `E_MODIFIED` | 데이터 변경 발생 여부 |
| `E_FIELDNAME` | F4 도움말이 호출된 필드명 |
| `E_FIELDVALUE` | F4 호출 시 필드의 현재 값 |
| `ER_EVENT_DATA` | 이벤트 제어 객체 (F4 처리 등) |
| `E_ONF4` | F4 도움말 호출 여부 |
| `E_ONF4_BEFORE` | F4 호출 이전 시점 |
| `E_ONF4_AFTER` | F4 호출 이후 시점 |

</br>
</br>

**1) CLASS-METHODS (정적 메서드)**
- 객체 생성 없이 클래스명으로 바로 호출
- 공통 로직, 이벤트 핸들러에 자주 사용
- 인스턴스 속성 사용 불가

**2) METHODS (인스턴스 메서드)**
- 객체 생성(CREATE OBJECT) 후에만 호출
- 객체별 인스턴스 속성 사용 가능
- 객체 상태(속성)를 사용하는 로직에 사용
</br>
</br>

- `CLASS-METHODS` : 정적(static) 메서드,  `METHODS` : 인스턴스 메서드
- `<handler_class>` : 이벤트 핸들러 클래스명
- `<handler_method>` : 이벤트 처리 메소드명
- `<event_name>` : 발생 이벤트명
- `<event_class>` : 이벤트를 가진 클래스
- `<param_1>, <param_2>` : 이벤트 파라미터
```abap
*************** C01 ****************
CLASS <handler_class> DEFINITION.
  [PUBLIC | PROTECTED | PRIVATE] SECTION.
    [CLASS-]METHODS <handler_method>
      FOR EVENT <event_name> OF <event_class>
      IMPORTING
        <param_1>
        <param_2>
        sender.
ENDCLASS.

CLASS <handler_class> IMPLEMENTATION.
  METHOD <handler_method>.
  ENDMETHOD.
ENDCLASS.

*************** PBO ****************
SET HANDLER <handler_class>=><handler_method> FOR <event_object>.

CALL METHOD <event_object>->set_table_for_first_display
  EXPORTING
    i_structure_name = '<DDIC 구조>'
  CHANGING
    it_outtab        = <itab>
```
- `SENDER` → 이벤트를 발생시킨 객체(오브젝트) 참조
```abap
REPORT ZPROGB03_0029.

*************** C01 ****************
CLASS lcl_event_handler DEFINITION.
  PUBLIC SECTION.
  CLASS-METHODS: ON_DOUBLE_CLICK
    FOR EVENT DOUBLE_CLICK OF CL_GUI_ALV_GRID
    IMPORTING ES_ROW_NO E_COLUMN SENDER.
  " CL_GUI_ALV_GRID 클래스의 더블클릭 이벤트가 발생하면
  " ON_DOUBLE_CLICK 이라는 메서드를 실행하겠다
ENDCLASS.

CLASS lcl_event_handler IMPLEMENTATION.
  "더블클릭 이벤트의 메서드 구현
  METHOD ON_DOUBLE_CLICK.
    IF SENDER = GO_ALV.
      MESSAGE I004(ZMCB03) WITH ES_ROW_NO-row_id        " 더블클릭된 ALV 행 번호
                                E_COLUMN-fieldname.     " 더블클릭된 ALV 컬럼명
    ENDIF.
  ENDMETHOD.
ENDCLASS.

*************** PBO ****************
SET HANDLER lcl_event_handler=>on_double_click FOR go_alv.

CALL METHOD go_alv->set_table_for_first_display
  EXPORTING
    i_structure_name     = 'SBOOK'
  CHANGING
    it_outtab            = gt_data
```
</br>
</br>

### 2) ALV Hotspot 이벤트 처리
- ALV 컬럼을 클릭 가능한 링크(밑줄)로 표시하는 기능
- 필드카탈로그 생성 시(PBO) `gs_fcat-hotspot = 'X'` 로 적용
```abap
*************** F01 ****************
CLEAR gs_fcat.
gs_fcat-fieldname = '<HOTSPOT_FIELD>'.
gs_fcat-hotspot   = 'X'.      " 클릭 가능한 링크(밑줄) 처리
APPEND gs_fcat TO gt_fcat.

*************** C01 ****************
CLASS <handler_class> DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS <handler_method>
      FOR EVENT hotspot_click OF cl_gui_alv_grid
      IMPORTING e_row_id e_column_id sender.
ENDCLASS.

CLASS <handler_class> IMPLEMENTATION.
  METHOD <handler_method>.
    " e_row_id-row_id        : 클릭된 행 번호
    " e_column_id-fieldname : 클릭된 컬럼명
  ENDMETHOD.
ENDCLASS.

*************** PBO ****************
SET HANDLER <handler_class>=><handler_method> FOR go_alv.

CALL METHOD go_alv->set_table_for_first_display
  EXPORTING
    i_structure_name = '<DDIC>'
  CHANGING
    it_outtab        = <itab>
    it_fieldcatalog  = gt_fcat.
```
```abap
REPORT ZPROGB03_0029.

*************** F01 ****************
CLEAR gs_fcat.
gs_fcat-fieldname = 'PHONE'.   " 핫스팟 적용 컬럼
gs_fcat-hotspot   = 'X'.       " 핫스팟(링크) 활성화
APPEND gs_fcat TO gt_fcat.

*************** C01 ****************
CLASS lcl_event_handler DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS on_hotspot_click
      FOR EVENT hotspot_click OF cl_gui_alv_grid
      IMPORTING
        es_row_no     " 클릭된 행 정보 (row_id)
        e_column_id  " 클릭된 컬럼 정보 (fieldname)
        sender.
ENDCLASS.

CLASS lcl_event_handler IMPLEMENTATION.
  METHOD on_hotspot_click.
    IF sender = go_alv.
      MESSAGE I004(ZMCB03)
        WITH es_row_no-row_id        " 클릭된 행 번호
             e_column_id-fieldname. " 클릭된 컬럼명
    ENDIF.
  ENDMETHOD.
ENDCLASS.

*************** PBO ****************
SET HANDLER lcl_event_handler=>on_hotspot_click FOR go_alv.
```
</br>
</br>

---

</br>

## < 실습 코드 >
</br>

### 실습 1
</br>
</br>

- 문제
- 전 exercise 코드에서 추가
- CLASS-METHODS, Hotspot 실습
<img width="374" height="208" alt="image" src="https://github.com/user-attachments/assets/90e9c079-c318-4291-9848-07923ecc223d" />
</br>
</br>

**1) `F01` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV3_F01
*&---------------------------------------------------------------------*

FORM set_fcat.
  CLEAR gs_fcat.
  gs_fcat-fieldname = 'SEATSOCC'.
  gs_fcat-do_sum = 'X'.
  gs_fcat-hotspot = 'X'.    " 핫스팟 추가
  APPEND gs_fcat TO gt_fcat.
ENDFORM.
```
</br>

**2) `C01` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV3_C01_3
*&---------------------------------------------------------------------*

CLASS lcl_event_handler DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: on_double_click
      FOR EVENT double_click OF cl_gui_alv_grid
      IMPORTING es_row_no sender.

    CLASS-METHODS: on_hotspot_click
      FOR EVENT hotspot_click OF cl_gui_alv_grid
      IMPORTING es_row_no sender.
ENDCLASS.

CLASS lcl_event_handler IMPLEMENTATION.
  METHOD on_double_click.
    IF sender = go_alv_grid.
      DATA: total_seat TYPE int4.

      READ TABLE gt_flight INTO gs_flight INDEX es_row_no-row_id.
      IF sy-subrc <> 0.
        MESSAGE i075(bc405_408).
        EXIT.
      ENDIF.

      total_seat = gs_flight-seatsocc + gs_flight-seatsocc_b + gs_flight-seatsocc_f.
      MESSAGE 'Total:' && total_seat TYPE 'I'.
    ENDIF.
  ENDMETHOD.

  METHOD on_hotspot_click.
    IF sender = go_alv_grid.
      READ TABLE gt_flight INTO gs_flight INDEX es_row_no-row_id.
      IF gs_flight-excp = '1'.
        MESSAGE '빨간색 입니다.' TYPE 'I'.
      ELSEIF gs_flight-excp = '2'.
        MESSAGE '노란색 입니다.' TYPE 'I'.
      ELSE.
        MESSAGE '초록색 입니다.' TYPE 'I'.
      ENDIF.
    ENDIF.
  ENDMETHOD.
endclass.
```
</br>

**3) `PBO` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV3_O01
*&---------------------------------------------------------------------*

MODULE create_and_transfer OUTPUT.
    SET HANDLER lcl_event_handler=>on_double_click FOR go_alv_grid.
    SET HANDLER lcl_event_handler=>on_hotspot_click FOR go_alv_grid.

    CALL METHOD go_alv_grid->set_table_for_first_display
      EXPORTING
        i_structure_name              = 'SFLIGHT'
      CHANGING
        it_outtab                     = gt_flight
        IT_FIELDCATALOG               = gt_fcat
ENDMODULE.
```
</br>

**4) 결과 확인**
- 더블클릭시 이벤트
<img width="513" height="394" alt="image" src="https://github.com/user-attachments/assets/5e605617-f7f0-43bf-b979-bc7aaa143583" />
</br>

- 핫스팟 설정
<img width="515" height="394" alt="image" src="https://github.com/user-attachments/assets/1e321642-c072-4eb0-a2e1-7458d965dd97" />

</br>
</br>

# 01/02
</br>
</br>

## <  핵심 개념 >
</br>

- **1) ALV 표준 툴바 확장 (TOOLBAR 이벤트)**
- **2) ALV 셀 버튼(Button) 동적 생성 및 클릭 이벤트 처리**
- **3) ALV USER_COMMAND 실행 전 제어 (before_user_command)**
- **4) ALV Control 주요 메소드 (get_current_cell, set_user_command, get_selected_rows)**

</br>
</br>

---

</br>

## < ALV 이벤트 정리 >
</br>

### 1) ALV 표준 툴바 확장 (TOOLBAR 이벤트)
- `TOOLBAR` : 툴바에 버튼을 추가/구성
- `USER_COMMAND` : 버튼 클릭 시 동작 처리
  
| 값 | 의미 |
|----|------|
| `0` | 일반 버튼 |
| `1` | 메뉴 + 표준 버튼 |
| `2` | 메뉴 |
| `3` | 구분선 (Separator) |
| `4` | 선택 버튼 |
| `5` | 체크박스 버튼 |
| `6` | 메뉴 엔트리 |

- `e_object` = ALV 툴바 자체를 담고 있는 객체 (여기에 버튼을 추가/삭제함)
- `e_interactive` = 툴바 이벤트가 사용자 조작으로 발생했는지 알려주는 플래그
- `e_object->mt_toolbar` = ALV 툴바에 표시될 버튼 목록 테이블
```abap
*************** C01 ****************
CLASS lcl_event_handler DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS on_toolbar
      FOR EVENT toolbar OF cl_gui_alv_grid
      IMPORTING e_object e_interactive sender.

    CLASS-METHODS on_user_command
      FOR EVENT user_command OF cl_gui_alv_grid
      IMPORTING e_ucomm sender.
ENDCLASS.


CLASS lcl_event_handler IMPLEMENTATION.
  METHOD on_toolbar.
    DATA ls_button TYPE stb_button.

    CLEAR ls_button.
    ls_button-function  = '<FUNC_CODE>'.
    ls_button-icon      = <ICON>.
    ls_button-text      = '<TEXT>'.
    ls_button-quickinfo = '<QUICKINFO>'.
    ls_button-butn_type = '0'.

    INSERT ls_button INTO TABLE e_object->mt_toolbar.
  ENDMETHOD.


  METHOD on_user_command.
    CASE e_ucomm.
      WHEN '<FUNC_CODE>'.
        " 버튼 클릭 시 처리 로직
      WHEN OTHERS.
    ENDCASE.
  ENDMETHOD.
ENDCLASS.

*************** PBO ****************
SET HANDLER lcl_event_handler=>on_toolbar      FOR go_alv.
SET HANDLER lcl_event_handler=>on_user_command FOR go_alv.

CALL METHOD go_alv->set_table_for_first_display
  EXPORTING
    i_structure_name = '<DDIC 구조>'
  CHANGING
    it_outtab        = <itab>.

```
```abap
REPORT ZPROGB03_0029.

*************** C01 ****************
CLASS lcl_event_handler DEFINITION.
  PUBLIC SECTION.
  CLASS-METHODS: ON_TOOLBAR FOR EVENT TOOLBAR
    OF CL_GUI_ALV_GRID IMPORTING E_OBJECT,
      ON_USER_COMMAND FOR EVENT USER_COMMAND
    OF CL_GUI_ALV_GRID IMPORTING E_UCOMM.
ENDCLASS.

CLASS lcl_event_handler IMPLEMENTATION.
  METHOD ON_TOOLBAR.
    DATA ls_button TYPE STB_BUTTON.
    ls_button-butn_type = 3.
    INSERT ls_button INTO TABLE e_object->mt_toolbar.

    CLEAR ls_button.
    ls_button-function = 'CUSTOM_TB'.
    ls_button-icon = ICON_FLIGHT.
    ls_button-quickinfo = 'This is tooltip~~'.
    ls_button-butn_type = 0.
    ls_button-text = 'flight'.
    INSERT ls_button INTO TABLE e_object->mt_toolbar.
  ENDMETHOD.

  METHOD ON_USER_COMMAND.
    CASE E_UCOMM.
      WHEN 'CUSTOM_TB'.
        MESSAGE 'flight' TYPE 'I'.
      WHEN OTHERS.
    ENDCASE.
  ENDMETHOD.
ENDCLASS.

*************** PBO ****************
SET HANDLER lcl_event_handler=>on_toolbar FOR go_alv.
SET HANDLER lcl_event_handler=>on_user_command FOR go_alv.

CALL METHOD go_alv->set_table_for_first_display
  EXPORTING
    i_structure_name              = 'SBOOK'
  CHANGING
    it_outtab                     = gt_data
```
</br>
</br>
</br>

### 2) ALV 셀 버튼(Button) 동적 생성 및 클릭 이벤트 처리
- 조건에 따라 ALV 특정 셀을 버튼으로 표시하고, 버튼 클릭 시 해당 행 데이터를 기준으로 동작을 처리
- `LVC_S_STYL` → ALV 셀 단위 스타일(버튼/입력불가 등) 정의 구조
- `LVC_T_STYL` → 셀 스타일을 여러 개 담는 내부테이블(행·컬럼별 적용용)
</br>

- ALV에서 셀 단위로 버튼/비활성 등 UI 스타일을 다르게 적용하기 위해 사용하는 방식
- `cl_gui_alv_grid=>mc_style_button` → ALV 셀을 “클릭 가능한 버튼 형태” 로 표시하는 스타일 상수
- `gs_cell_style-fieldname` → 버튼/스타일을 적용할 ALV 컬럼(필드)명 지정
- `gs_cell_style-style` → 해당 컬럼 셀에 적용할 UI 스타일(버튼, 비활성 등) 지정
- `gs_layout-stylefname` → ALV 데이터 구조에서 셀 스타일 정보를 담고 있는 필드명 연결
</br>

<img width="464" height="222" alt="image" src="https://github.com/user-attachments/assets/ceb7e53e-2aa1-451a-a292-50d109b49cc8" />
</br>
</br>

```abap
*************** TOP ****************
DATA: BEGIN OF gs_data.
        INCLUDE TYPE <DB_STRUCTURE>.
DATA: <BUTTON_FIELD> TYPE c LENGTH 10,
      <STYLE_FIELD>  TYPE lvc_t_styl,
     END OF gs_data.

DATA: gt_data       TYPE STANDARD TABLE OF gs_data,
      gs_cell_style TYPE lvc_s_styl.


*************** C01 ****************
CLASS lcl_event_handler DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS on_button_click
      FOR EVENT button_click OF cl_gui_alv_grid
      IMPORTING es_row_no es_col_id.
ENDCLASS.

CLASS lcl_event_handler IMPLEMENTATION.
  METHOD on_button_click.
    IF es_col_id-fieldname = '<BUTTON_FIELD>'.
    ENDIF.
  ENDMETHOD.
ENDCLASS.


*************** F01 ****************
FORM set_button.
  LOOP AT gt_data INTO gs_data.
    gs_cell_style-fieldname = '<BUTTON_FIELD>'.
    gs_cell_style-style     = cl_gui_alv_grid=>mc_style_button.
    APPEND gs_cell_style TO gs_data-<STYLE_FIELD>.
    gs_data-<BUTTON_FIELD> = '<BUTTON_TEXT>'.
    MODIFY gt_data FROM gs_data.
  ENDLOOP.
ENDFORM.


*************** PBO ****************
SET HANDLER lcl_event_handler=>on_button_click FOR <ALV_OBJECT>.
gs_layout-stylefname = '<STYLE_FIELD>'.

CALL METHOD <ALV_OBJECT>->set_table_for_first_display
  CHANGING it_outtab = gt_data.
```
```abap
REPORT ZPROGB03_0029.

*************** TOP ****************
DATA: BEGIN OF gs_data.
        INCLUDE TYPE sbook.
DATA: display_bookings TYPE c LENGTH 10,   " 버튼 텍스트
      it_cell_style    TYPE LVC_T_STYL,     " 셀 스타일
     END OF gs_data.
DATA gs_cell_style TYPE LVC_S_STYL.

*************** C01 ****************
CLASS lcl_event_handler DEFINITION.
  PUBLIC SECTION.
  CLASS-METHODS: on_button_click
    FOR EVENT button_click OF CL_GUI_ALV_GRID
    IMPORTING ES_ROW_NO ES_COL_ID.
ENDCLASS.

CLASS lcl_event_handler IMPLEMENTATION.
  METHOD on_button_click.
    IF ES_COL_ID-fieldname = 'DISPLAY_BOOKINGS'.
      READ TABLE gt_data INTO gs_data INDEX es_row_no-row_id.
      MESSAGE gs_data-class TYPE 'I'.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

*************** F01 ****************
FORM get_data.
  SELECT * FROM sbook
    INTO CORRESPONDING FIELDS OF TABLE gt_data.

  LOOP AT gt_data INTO gs_data.
    IF gs_data-loccuram >= 800.
      " excp_fld 초록일 때, 버튼도 표시하도록 함
      gs_cell_style-fieldname = 'DISPLAY_BOOKINGS'.
      gs_cell_Style-style = cl_gui_alv_grid=>MC_STYLE_BUTTON.
      APPEND gs_cell_style TO gs_data-it_cell_style.
      gs_data-display_bookings = 'Detail'. " 버튼Text
    ENDIF.

    MODIFY gt_data FROM gs_data.
    CLEAR: gs_data, gs_cell_style.
  ENDLOOP.
ENDFORM.


FORM set_layout.
  gs_layout-stylefname = 'IT_CELL_STYLE'.
ENDFORM.


FORM set_fieldcat.
  CLEAR gs_fcat.
  gs_fcat-fieldname = 'DISPLAY_BOOKINGS'.
  gs_fcat-col_pos = 3.
  gs_fcat-coltext = 'Display Detail'.
  APPEND gs_fcat TO gt_fcat.
ENDFORM.

*************** PBO ****************
SET HANDLER lcl_event_handler=>on_button_click FOR go_alv.

CALL METHOD go_alv->set_table_for_first_display
  EXPORTING
    is_layout        = gs_layout
  CHANGING
    it_outtab        = gt_data
    it_fieldcatalog  = gt_fcat.
```
</br>
</br>
</br>

### 3) ALV USER_COMMAND 실행 전 제어 (before_user_command)
- UUSER_COMMAND보다 먼저 동일한 UCOMM을 받아 실행 여부를 제어하는 이벤트
- `before_user_command` → ALV에서 사용자 액션이 발생했을 때, USER_COMMAND가 처리되기 직전에 먼저 호출되는 이벤트
- `e_ucomm` → 클릭된 버튼의 Function Code
```abap
*************** C01 ****************
CLASS lcl_event_handler DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS on_before_user_command
      FOR EVENT before_user_command OF cl_gui_alv_grid
      IMPORTING e_ucomm.
ENDCLASS.

CLASS lcl_event_handler IMPLEMENTATION.
  METHOD on_before_user_command.
    CASE e_ucomm.
      WHEN <FUNCTION_CODE>.
        MESSAGE '실행 전 제어' TYPE 'I'.
      WHEN OTHERS.
    ENDCASE.
  ENDMETHOD.
ENDCLASS.

*************** PBO ****************
SET HANDLER lcl_event_handler=>on_before_user_command FOR go_alv.
```
</br>
</br>

---

</br>

## < ALV Control 주요 메소드 >
</br>

- 메서드 = 객체의 상태를 조회하거나 동작을 수행하는 클래스 내부 함수

| Method | 설명 |
|------|------|
| **get_current_cell** | 현재 커서가 위치한 셀의 좌표와 값 반환 |
| **get_selected_cells** | 사용자가 선택한 셀들의 좌표와 값 반환 |
| **get_selected_columns** | 선택된 컬럼 이름 목록 반환 |
| **get_selected_rows** | 선택된 행 번호(Row Index) 반환 |
| **get_subtotals** | ALV Grid에 설정된 현재 소계(Subtotal) 정보 반환 |
| **set_toolbar_interactive** | ALV 툴바 이벤트를 강제로 발생시킴 |
| **set_user_command** | 현재 USER-COMMAND 값을 강제로 덮어씀 |
</br>
</br>

### 1) get_current_cell
- 현재 커서가 위치한 ALV 셀의 행·컬럼 인덱스를 가져오는 메서드
```abap
*************** C01 ****************
CALL METHOD <alv_grid>->get_current_cell
  IMPORTING
    e_row = <row_index>
    e_col = <col_index>.
```
- 커스텀 툴바 버튼(`CUSTOM_TB`) 클릭 시 현재 커서가 있는 ALV 셀의 행·컬럼을 조회
```abap
REPORT ZPROGB03_0029.

*************** C01 ****************
CLASS-METHODS on_user_command
  FOR EVENT user_command OF cl_gui_alv_grid
  IMPORTING e_ucomm.

METHOD on_user_command.
  DATA: lv_row TYPE i,   " 현재 행 번호
        lv_col TYPE i.   " 현재 컬럼 번호

  CASE e_ucomm.
    WHEN 'CUSTOM_TB'.   " 툴바 버튼 클릭 시
      CALL METHOD go_alv->get_current_cell
        IMPORTING
          e_row = lv_row
          e_col = lv_col.
      MESSAGE 'Row: ' && lv_row && ', Col: ' && lv_col TYPE 'I'.
    WHEN OTHERS.
  ENDCASE.
ENDMETHOD.
```
</br>
</br>
</br>

### 2) set_user_command
- USER_COMMAND 값을 강제로 세팅하여 해당 USER_COMMAND 이벤트를 실행시키는 메서드

<img width="34" height="29" alt="image" src="https://github.com/user-attachments/assets/232a14e6-7938-429f-9d88-57338d1bd4d0" />
</br>

```abap
*************** C01 ****************
CALL METHOD <alv_grid>->set_user_command
  EXPORTING
    i_ucomm = <FUNCTION_CODE>.
```
```abap
REPORT ZPROGB03_0029.

*************** C01 ****************
CLASS-METHODS on_before_user_command
  FOR EVENT before_user_command OF cl_gui_alv_grid
  IMPORTING e_ucomm.
CLASS-METHODS on_user_command
  FOR EVENT user_command OF cl_gui_alv_grid
  IMPORTING e_ucomm.

METHOD on_before_user_command.
  CASE e_ucomm.
    WHEN go_alv->mc_fc_detail.   " ALV 표준 Detail 버튼 클릭 시
      CALL METHOD go_alv->set_user_command
        EXPORTING
          i_ucomm = 'SHOW_BOOK'.  " USER_COMMAND 강제 세팅
    WHEN OTHERS.
  ENDCASE.
ENDMETHOD.
METHOD on_user_command.
  CASE e_ucomm.
    WHEN 'SHOW_BOOK'.            " set_user_command로 유도된 명령
      MESSAGE 'Show-book 클릭되었습니다' TYPE 'I'.
    WHEN OTHERS.
  ENDCASE.
ENDMETHOD.
```
</br>
</br>
</br>

### 3) get_selected_rows
- ALV에서 사용자가 선택(체크/드래그)한 행들의 인덱스 목록을 가져오는 메서드
```abap
*************** C01 ****************
CALL METHOD <alv_grid>->get_selected_rows
  IMPORTING
    et_index_rows = <selected_rows>.
```
```abap
REPORT ZPROGB03_0029.

*************** PAI ****************
MODULE user_command_0100 INPUT.
  CASE OK_CODE.
    WHEN 'SELECT'.
      DATA: lt_select_data TYPE LVC_T_ROW,
            ls_select_data TYPE LVC_S_ROW.
      DATA: lt_data LIKE gt_data,
            ls_data LIKE gs_data.

      CALL METHOD go_alv->get_selected_rows
        IMPORTING
          et_index_rows = lt_select_data.

      IF lt_select_data IS NOT INITIAL.
        LOOP AT lt_select_data INTO ls_select_data.
          READ TABLE gt_data INTO ls_data
          INDEX ls_select_data-index.
          IF sy-subrc = 0.
            APPEND ls_data TO lt_data.
          ENDIF.
        ENDLOOP.
        cl_demo_output=>display( lt_data ).
      ELSE.
        MESSAGE 'Please select record' TYPE 'E'.
      ENDIF.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```
</br>
</br>

</br>
</br>

---

</br>

## < 실습 코드 >
</br>

### 실습 1
</br>

- 새로 구성하는 실습
- alv 2개, hotspot 실습
  
<img width="384" height="223" alt="image" src="https://github.com/user-attachments/assets/e891f22d-5304-45f1-b709-97a0ac023e6f" />
</br>
</br>
</br>

**1) `Report program` 에서 `Include` 파일 생성**
```abap
*&---------------------------------------------------------------------*
*& Report ZALV_SPFLI_B03
*&---------------------------------------------------------------------*

INCLUDE ZALV_SPFLI_B03_TOP.
INCLUDE ZALV_SPFLI_B03_C01.
INCLUDE ZALV_SPFLI_B03_O01.
INCLUDE ZALV_SPFLI_B03_I01.
INCLUDE ZALV_SPFLI_B03_F01.

START-OF-SELECTION.
  PERFORM get_data.
  CALL SCREEN 100.
```
</br>

**2) `TOP` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZALV_SPFLI_B03_TOP
*&---------------------------------------------------------------------*

DATA: OK_CODE TYPE sy-ucomm.
DATA: go_cont TYPE REF TO cl_gui_custom_container,
      go_alv TYPE REF TO cl_gui_alv_grid,
      go_cont2 TYPE REF TO cl_gui_custom_container,
      go_alv2 TYPE REF TO cl_gui_alv_grid,
      gt_fcat TYPE LVC_T_FCAT,
      gs_fcat TYPE LVC_S_FCAT.

DATA: gs_sflight TYPE sflight,
      gt_sflight TYPE TABLE OF sflight,
      gv_index TYPE I.

DATA: BEGIN OF gs_data,
        carrid TYPE spfli-carrid,
        carrname TYPE scarr-carrname,
        connid TYPE spfli-connid,
        cityfrom TYPE spfli-cityfrom,
        cityto TYPE spfli-cityto,
        airpfrom TYPE spfli-airpfrom,
        airpto TYPE spfli-airpto,
      END OF gs_data.
DATA: gt_data LIKE TABLE OF gs_data.

PARAMETERS: pa_carr TYPE spfli-carrid DEFAULT 'AZ'.
SELECT-OPTIONS: so_con FOR gs_data-connid.
```
</br>

**3) `F01` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZALV_SPFLI_B03_F01
*&---------------------------------------------------------------------*

FORM get_data.
  DATA: gt_scarr TYPE TABLE OF scarr,
        gs_scarr TYPE scarr.

  SELECT carrid connid cityfrom cityto airpfrom airpto FROM spfli
    INTO CORRESPONDING FIELDS OF TABLE gt_data
    WHERE carrid = pa_carr
      AND connid IN so_con.
  SELECT carrid carrname FROM scarr
    INTO CORRESPONDING FIELDS OF TABLE gt_scarr
    FOR ALL ENTRIES IN gt_data
    WHERE carrid = gt_data-carrid.

  LOOP AT gt_data INTO gs_data.
    READ TABLE gt_scarr INTO gs_scarr WITH KEY carrid = gs_data-carrid
      TRANSPORTING carrname.
    gs_data-carrname = gs_scarr-carrname.
    MODIFY gt_data FROM gs_data TRANSPORTING carrname.
  ENDLOOP.

ENDFORM.

*&---------------------------------------------------------------------*

FORM get_sflight.
  READ TABLE gt_data INTO gs_data INDEX gv_index.
  SELECT * FROM sflight
    INTO CORRESPONDING FIELDS OF TABLE gt_sflight
    WHERE carrid = gs_data-carrid
      AND connid = gs_data-connid.
ENDFORM.

*&---------------------------------------------------------------------*

FORM set_fcat.
  CLEAR gs_fcat.
  gs_fcat-fieldname = 'CARRID'.
  gs_fcat-ref_field = 'CARRID'.
  gs_fcat-ref_table = 'SPFLI'.
  gs_fcat-hotspot = 'X'.
  APPEND gs_fcat TO gt_fcat.

  CLEAR gs_fcat.
  gs_fcat-fieldname = 'CARRNAME'.
  gs_fcat-ref_field = 'CARRNAME'.
  gs_fcat-ref_table = 'SCARR'.
  APPEND gs_fcat TO gt_fcat.

  CLEAR gs_fcat.
  gs_fcat-fieldname = 'CONNID'.
  gs_fcat-ref_field = 'CONNID'.
  gs_fcat-ref_table = 'SPFLI'.
  APPEND gs_fcat TO gt_fcat.

  CLEAR gs_fcat.
  gs_fcat-fieldname = 'CITYFROM'.
  gs_fcat-ref_field = 'CITYFROM'.
  gs_fcat-ref_table = 'SPFLI'.
  APPEND gs_fcat TO gt_fcat.

  CLEAR gs_fcat.
  gs_fcat-fieldname = 'CITYTO'.
  gs_fcat-ref_field = 'CITYTO'.
  gs_fcat-ref_table = 'SPFLI'.
  APPEND gs_fcat TO gt_fcat.

  CLEAR gs_fcat.
  gs_fcat-fieldname = 'AIRPFROM'.
  gs_fcat-ref_field = 'AIRPFROM'.
  gs_fcat-ref_table = 'SPFLI'.
  APPEND gs_fcat TO gt_fcat.

    CLEAR gs_fcat.
  gs_fcat-fieldname = 'AIRPTO'.
  gs_fcat-ref_field = 'AIRPTO'.
  gs_fcat-ref_table = 'SPFLI'.
  APPEND gs_fcat TO gt_fcat.

ENDFORM.

*&---------------------------------------------------------------------*

FORM free_alv.
  IF GO_ALV2 IS NOT INITIAL.
    GO_ALV2->FREE( ).
  ENDIF.
  IF GO_CONT2 IS NOT INITIAL.
    GO_CONT2->FREE( ).
  ENDIF.
  FREE: GO_ALV2, GO_CONT2.
ENDFORM.
```
</br>

**4) `C01` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZALV_SPFLI_B03_C01
*&---------------------------------------------------------------------*

CLASS lcl_event_handler DEFINITION.
  PUBLIC SECTION.
  CLASS-METHODS: ON_HOTSPOT_CLICK
    FOR EVENT HOTSPOT_CLICK OF CL_GUI_ALV_GRID
    IMPORTING E_ROW_ID SENDER.
ENDCLASS.


CLASS lcl_event_handler IMPLEMENTATION.
  METHOD ON_HOTSPOT_CLICK.
    IF SENDER = GO_ALV.
      gv_index = E_ROW_ID-index.
      PERFORM get_sflight.
      CALL SCREEN 110.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
```
</br>

**5) `PBO` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZALV_SPFLI_B03_O01
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.
  SET PF-STATUS 'S100'.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE init_alv OUTPUT.
  IF go_cont IS INITIAL.
    CREATE OBJECT go_cont
      EXPORTING
        container_name              = 'AREA'
      EXCEPTIONS
        cntl_error                  = 1
        cntl_system_error           = 2
        create_error                = 3
        lifetime_error              = 4
        lifetime_dynpro_dynpro_link = 5
        OTHERS                      = 6.
    IF sy-subrc <> 0.
    ENDIF.

    CREATE OBJECT go_alv
      EXPORTING
        i_parent          = go_cont
      EXCEPTIONS
        error_cntl_create = 1
        error_cntl_init   = 2
        error_cntl_link   = 3
        error_dp_create   = 4
        others            = 5.
    IF sy-subrc <> 0.
    ENDIF.

    PERFORM set_fcat.
    SET HANDLER lcl_event_handler=>on_hotspot_click FOR go_alv.
    CALL METHOD go_alv->set_table_for_first_display
      CHANGING
        it_outtab                     = gt_data
        it_fieldcatalog               = gt_fcat
      EXCEPTIONS
        invalid_parameter_combination = 1
        program_error                 = 2
        too_many_lines                = 3
        others                        = 4.
    IF sy-subrc <> 0.
    ENDIF.
  ENDIF.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE status_0110 OUTPUT.
 SET PF-STATUS 'S110'.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE init_alv2 OUTPUT.
  IF go_cont2 IS INITIAL.
    CREATE OBJECT go_cont2
      EXPORTING
        container_name              = 'AREA2'
      EXCEPTIONS
        cntl_error                  = 1
        cntl_system_error           = 2
        create_error                = 3
        lifetime_error              = 4
        lifetime_dynpro_dynpro_link = 5
        others                      = 6.
    IF sy-subrc <> 0.
    ENDIF.

    CREATE OBJECT go_alv2
      EXPORTING
        i_parent          = go_cont2
      EXCEPTIONS
        error_cntl_create = 1
        error_cntl_init   = 2
        error_cntl_link   = 3
        error_dp_create   = 4
        others            = 5.
    IF sy-subrc <> 0.
    ENDIF.

    CALL METHOD go_alv2->set_table_for_first_display
      EXPORTING
        i_structure_name              = 'SFLIGHT'
      CHANGING
        it_outtab                     = gt_sflight
      EXCEPTIONS
        invalid_parameter_combination = 1
        program_error                 = 2
        too_many_lines                = 3
        others                        = 4.
    IF sy-subrc <> 0.
    ENDIF.

  ENDIF.
ENDMODULE.
```
</br>

**6) `PAI` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZALV_SPFLI_B03_I01
*&---------------------------------------------------------------------*

MODULE exit INPUT.
  CASE OK_CODE.
    WHEN 'EXIT'.
      LEAVE PROGRAM.
    WHEN 'CANCEL'.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.
  CASE OK_CODE.
    WHEN 'BACK'.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE user_command_0110 INPUT.
  CASE OK_CODE.
    WHEN 'BACK'.
      PERFORM free_alv.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```
</br>

**7) 결과 확인**

<img width="423" height="102" alt="image" src="https://github.com/user-attachments/assets/0336d2c5-97f0-46db-9709-17cb3433a6b6" />
</br>

<img width="470" height="164" alt="image" src="https://github.com/user-attachments/assets/4c4c5b8d-8711-428a-b928-30b01aa655cd" />
</br>

<img width="472" height="193" alt="image" src="https://github.com/user-attachments/assets/69b1f9a6-1e38-40b3-b325-dd25f24d2f93" />
</br>
</br>
</br>
</br>

### 실습 2
- 전 exercise 코드에서 이어서 진행
</br>
</br>

**1) `C01` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV4_C01_3
*&---------------------------------------------------------------------*

CLASS lcl_event_handler DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: on_toolbar FOR EVENT toolbar
      OF cl_gui_alv_grid IMPORTING e_object,
        on_user_command FOR EVENT user_command
      OF cl_gui_alv_grid IMPORTING e_ucomm.
ENDCLASS.

CLASS lcl_event_handler IMPLEMENTATION.
  METHOD on_toolbar.
    DATA ls_button TYPE STB_BUTTON.
    ls_button-butn_type = 3.
    INSERT ls_button INTO TABLE e_object->mt_toolbar.

    CLEAR ls_button.
    ls_button-function = 'PERCENTAGE'.
    ls_button-text = '% total'.
    ls_button-quickinfo = 'Total economy utilization'.
    ls_button-butn_type = 0.
    INSERT ls_button INTO TABLE e_object->mt_toolbar.

    CLEAR ls_button.
    ls_button-function = 'PERCENTAGE_MARKED'.
    ls_button-text = '% marked'.
    ls_button-quickinfo = 'Economy utilization (marked flights)'.
    ls_button-butn_type = 0.
    INSERT ls_button INTO TABLE e_object->mt_toolbar.
  ENDMETHOD.

  METHOD on_user_command.
    DATA: gv_seatsocc TYPE I VALUE IS INITIAL,
          gv_seatsmax TYPE I VALUE IS INITIAL,
          gv_percentage TYPE P LENGTH 8 DECIMALS 2 VALUE IS INITIAL.
    DATA: lt_select_data TYPE LVC_T_ROW,
          ls_select_data TYPE LVC_S_ROW,
          gs_select_flight LIKE gs_flight.
    CASE E_UCOMM.
      WHEN 'PERCENTAGE'.
        LOOP AT gt_flight INTO gs_flight.
          gv_seatsocc = gv_seatsocc + gs_flight-seatsocc.
          gv_seatsmax = gv_seatsmax + gs_flight-seatsmax.
        ENDLOOP.
        gv_percentage = ( gv_seatsocc / gv_seatsmax ) * 100.
        MESSAGE '총 좌석: ' && gv_percentage TYPE 'I'.
      WHEN 'PERCENTAGE_MARKED'.
        CALL METHOD go_alv_grid->get_selected_rows
          IMPORTING et_index_rows = lt_select_data.
        IF lt_select_data IS NOT INITIAL.
          LOOP AT lt_select_data INTO ls_select_data.
            READ TABLE gt_flight INTO gs_select_flight
            INDEX ls_select_data-index.
            gv_seatsocc = gv_seatsocc + gs_select_flight-seatsocc.
            gv_seatsmax = gv_seatsmax + gs_select_flight-seatsmax.
          ENDLOOP.
          gv_percentage = ( gv_seatsocc / gv_seatsmax ) * 100.
          MESSAGE '총 좌석: ' && gv_percentage TYPE 'I'.
        ELSE.
          MESSAGE 'Please select record' TYPE 'E'.
        ENDIF.
      WHEN OTHERS.
    ENDCASE.
  ENDMETHOD.
ENDCLASS.
```
</br>

**2) `PBO` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC405_03_ALV4_O01
*&---------------------------------------------------------------------*

SET HANDLER lcl_event_handler=>on_toolbar FOR go_alv_grid.
SET HANDLER lcl_event_handler=>on_user_command FOR go_alv_grid.
CALL METHOD go_alv_grid->set_table_for_first_display
  EXPORTING
    i_structure_name              = 'SFLIGHT'
  CHANGING
    it_outtab                     = gt_flight
  EXCEPTIONS
    invalid_parameter_combination = 1
    program_error                 = 2
    too_many_lines                = 3
    others                        = 4.
```
</br>

**3) 결과 확인**

<img width="510" height="349" alt="image" src="https://github.com/user-attachments/assets/2673cb36-cefa-4576-952e-98928d7e6b08" />
</br>

<img width="510" height="353" alt="image" src="https://github.com/user-attachments/assets/8ce97d02-ede4-4a4a-aa23-2f7286e3deb5" />

</br>
</br>

# 01/05
</br>
</br>

## <  핵심 개념 >
</br>

- **1) Docking Container 기반 ALV 화면 구성**
- **2) Splitter Container 기반 다중 ALV 구성**
- **3) SUBMIT 호출 방식**
- **4) 트랜잭션 호출 방식**
- **5) 프로그램 간 데이터 전달 (`SUBMIT ~ WITH`)**
- **6) EXPORT / IMPORT를 이용한 ABAP Memory 데이터 공유 (ABAP Memory)**
- **7) MEMORY ID를 이용한 조회조건 자동 유지 (SAP Memory)**
</br>

- **C01에서 더블클릭 이벤트 발생해도 자동으로 PAI/PBO 안 탐**
- **더블클릭 이후 로직은 기본적으로 C01에서만 처리**
</br>
</br>

---

</br>

## < ALV Docking Container >
</br>

### 1) Docking Container 기반 ALV 화면 구성

- `Docking Container` : 선택화면을 유지한 채 화면 가장자리에 ALV를 고정 표시하기 위한 컨테이너
- `side` : 도킹 위치 (TOP / BOTTOM / LEFT / RIGHT)
- `extension` : 도킹 영역 크기
- Docking Container 사용 시 → 별도의 AREA(스크린 영역) 필요 없음.

```abap
*************** TOP ****************
DATA: <DOCKING_CONTAINER> TYPE REF TO cl_gui_docking_container,
      <ALV_GRID>          TYPE REF TO cl_gui_alv_grid.

DATA: <ITAB> TYPE TABLE OF <DDIC_STRUCTURE>.

*************** Docking Container ****************
IF <DOCKING_CONTAINER> IS INITIAL.
  CREATE OBJECT <DOCKING_CONTAINER>
    EXPORTING
      side      = <DOCK_POSITION>
      extension = <SIZE>
      repid     = <PROGRAM_ID>
      dynnr     = <SCREEN_NO>.

  CREATE OBJECT <ALV_GRID>
    EXPORTING
      i_parent = <DOCKING_CONTAINER>.
ENDIF.

*************** Docking ALV 최초 출력 ****************
CALL METHOD <ALV_GRID>->set_table_for_first_display
  EXPORTING
    i_structure_name = <DDIC_STRUCTURE>
  CHANGING
    it_outtab        = <ITAB>.
```
- `UP TO <ROW_COUNT> ROWS` : 조회 결과 중 최대 N건까지만 내부테이블에 담음 (성능/미리보기용)
```abap
SELECT *
  FROM <DB_TABLE>
  INTO TABLE <ITAB>
  UP TO <ROW_COUNT> ROWS
  WHERE <CONDITION>.
```
```abap
REPORT zprogb03_0030.

*************** REPORT PROGRAM ****************
PARAMETERS: pa_car TYPE s_carr_id DEFAULT 'AA'.

DATA: go_docking TYPE REF TO cl_gui_docking_container,
      go_alv TYPE REF TO cl_gui_alv_grid.
DATA: gt_data TYPE TABLE OF sflight.

***********************************************
AT SELECTION-SCREEN OUTPUT.
  IF go_docking IS INITIAL.
    SELECT * FROM sflight INTO TABLE gt_data
      UP TO 20 ROWS
      WHERE carrid = pa_car.

    CHECK sy-subrc = 0. " 참이면 아래 로직 실행
    " Docking Container 생성
    CREATE OBJECT go_docking
      EXPORTING
        side      = cl_gui_docking_container=>dock_at_bottom
        extension = 300
        repid     = sy-repid
        dynnr     = sy-dynnr.
    " Docking Container에 ALV 생성
    CREATE OBJECT go_alv EXPORTING i_parent = go_docking.

    CALL METHOD go_alv->set_table_for_first_display
      EXPORTING
        i_structure_name              = 'SFLIGHT'
      CHANGING
        it_outtab                     = gt_data
      EXCEPTIONS
        invalid_parameter_combination = 1
        program_error                 = 2
        too_many_lines                = 3
        others                        = 4.
    IF sy-subrc <> 0.
      MESSAGE '데이터 조회 중 오류 발생' TYPE 'E'.
    ENDIF.
  ENDIF.

START-OF-SELECTION.
  SELECT * FROM sflight INTO TABLE gt_data
    UP TO 20 ROWS
    WHERE carrid = pa_car.

  IF sy-subrc = 0.
    CALL METHOD go_alv->refresh_table_display
      EXCEPTIONS
        finished       = 1
        others         = 2.
    IF sy-subrc <> 0.
      MESSAGE 'Refresh 작업 중 오류 발생' TYPE 'E'.
    ENDIF.
  ENDIF.
```
</br>
</br>
</br>

### 2) Splitter Container 기반 다중 ALV 구성
- 하나의 화면(또는 Docking 영역)을 여러 영역으로 나눠, 각 영역에 서로 다른 ALV를 동시에 보여주기 위해 사용
- `cl_gui_splitter_container` : 하나의 컨테이너를 행·열로 분할해 여러 영역을 동시에 사용할 수 있게 해주는 컨테이너 클래스
- `->get_container` : Splitter로 나뉜 특정 행·열 위치의 하위 컨테이너를 가져오는 메서드
```abap
*************** TOP ****************
DATA: <DOCKING_CONTAINER>  TYPE REF TO cl_gui_docking_container,
      <SPLITTER_CONTAINER> TYPE REF TO cl_gui_splitter_container,
      <LEFT_CONTAINER>     TYPE REF TO cl_gui_container,
      <RIGHT_CONTAINER>    TYPE REF TO cl_gui_container,
      <ALV_LEFT>           TYPE REF TO cl_gui_alv_grid,
      <ALV_RIGHT>          TYPE REF TO cl_gui_alv_grid.

*************** Docking Container ****************
CREATE OBJECT <DOCKING_CONTAINER>
    EXPORTING
      side      = <DOCK_POSITION>
      extension = <SIZE>
      repid     = <PROGRAM_ID>
      dynnr     = <SCREEN_NO>.

*************** Splitter Container ****************
CREATE OBJECT <SPLITTER_CONTAINER>
  EXPORTING
    parent  = <PARENT_CONTAINER>
    rows    = <ROW_COUNT>
    columns = <COLUMN_COUNT>.

*************** Split 영역 Container 획득 ****************
CALL METHOD <SPLITTER_CONTAINER>->get_container      " 왼쪽
  EXPORTING
    row    = <ROW_NO>
    column = <COL_NO_LEFT>
  RECEIVING
    container = <LEFT_CONTAINER>.
CALL METHOD <SPLITTER_CONTAINER>->get_container      " 오른쪽
  EXPORTING
    row    = <ROW_NO>
    column = <COL_NO_RIGHT>
  RECEIVING
    container = <RIGHT_CONTAINER>.

*************** Split 영역에 ALV 생성 ****************
CREATE OBJECT <ALV_LEFT>      " 왼쪽
  EXPORTING
    i_parent = <LEFT_CONTAINER>.
CREATE OBJECT <ALV_RIGHT>      " 오른쪾
  EXPORTING
    i_parent = <RIGHT_CONTAINER>.
```
```abap
REPORT zprogb03_0030.

*************** TOP ****************
DATA: go_docking TYPE REF TO cl_gui_docking_container,
      go_splitter TYPE REF TO cl_gui_splitter_container,
      go_cont_l   TYPE REF TO cl_gui_container,
      go_cont_r   TYPE REF TO cl_gui_container,
      go_alv_l    TYPE REF TO cl_gui_alv_grid,
      go_alv_r    TYPE REF TO cl_gui_alv_grid.

*************** Docking Container ****************
CREATE OBJECT go_dock
      EXPORTING
        repid                       = sy-repid
        dynnr                       = sy-dynnr
        side                        = cl_gui_docking_container=>dock_at_bottom
        extension                   = 300.

*************** Splitter Container ****************
CREATE OBJECT go_splitter            " Container 영역 분할 (1행 2열로)
EXPORTING parent  = go_docking
        rows    = 1
        columns = 2.

*************** Split 영역 Container 획득 ****************
CALL METHOD go_splitter->get_container      " 왼쪽 영역 컨테이너
EXPORTING row    = 1
          column = 1
RECEIVING container = go_cont_l.
CALL METHOD go_splitter->get_container      " 오른쪽 영역 컨테이너
EXPORTING row    = 1
          column = 2
RECEIVING container = go_cont_r.

*************** Split 영역에 ALV 생성 ****************
CREATE OBJECT go_alv_l
EXPORTING i_parent = go_cont_l.
CREATE OBJECT go_alv_r
EXPORTING i_parent = go_cont_r.
```
</br>
</br>
</br>

---

</br>

## < ABAP 프로그램·트랜잭션 호출 방식 정리 >
- **ABAP Memory** : 같은 사용자 세션(SAP GUI 창) 안에서만 공유되는 메모리
- **SAP Memory** : 세션을 넘어 다른 창·트랜잭션에서도 공유 가능한 메모리
- **`SUBMIT / CALL TRANSACTION`** → ABAP Memory 사용 가능
- **`LEAVE TO TRANSACTION`** → SAP Memory만 사용 가능
- 서로 다른 External Session(SAP GUI 창) 간에는 ABAP Memory 공유 불가 → 데이터 전달이 필요한 경우 SAP Memory 사용
- SAP Memory는 사용자 로그아웃 시 초기화됨
</br>

### 1) SUBMIT 호출 방식
- 다른 프로그램을 잠깐 실행했다가 돌아오는 방식 → 같은 메모리(ABAP Memory) 그대로 사용
</br>

- 다른 프로그램 실행만 하고 자동으로 돌아오지 않음
```abap
SUBMIT prog_name_2.
```
- 다른 프로그램 실행 후 끝나면 원래 프로그램으로 돌아옴
```abap
SUBMIT prog_name_2 AND RETURN.
```
- 실행 전 조회조건 화면을 보여주고, 끝나면 원래 프로그램으로 돌아옴
```abap
SUBMIT prog_name_2 VIA SELECTION-SCREEN AND RETURN.
```
</br>
</br>

**1) SUBMIT ZPROGB03_CALLED.**

- `ZPROGB03_CALLED` 만 실행되고 “CALL 프로그램으로 돌아왔어요!”는 안 찍힘
  
**2) SUBMIT ZPROGB03_CALLED AND RETURN.**

- `PROGB03_CALLED` 실행 후 돌아와서 “CALL 프로그램으로 돌아왔어요!”가 찍힘
  
**3) SUBMIT ZPROGB03_CALLED VIA SELECTION-SCREEN AND RETURN.**

- `ZPROGB03_CALLED` 의 조회조건 화면을 먼저 보여준 뒤 실행하고, 끝나면 돌아와서 “CALL 프로그램으로 돌아왔어요!”가 찍힘

```abap
*************** CALL ****************
REPORT ZPROGB03_CALL.

PARAMETERS: pa_car TYPE s_carr_id.
SELECT-OPTIONS: so_con FOR gs_sflight-connid.

START-OF-SELECTION.

SUBMIT ZPROGB03_CALLED
VIA SELECTION-SCREEN
AND RETURN
WITH pa_car2 = pa_car
WITH so_con2 IN so_con.
SUBMIT ZPROGB03_CALLED.
SUBMIT ZPROGB03_CALLED AND RETURN.
SUBMIT ZPROGB03_CALLED VIA SELECTION-SCREEN AND RETURN.

*SUBMIT ZPROGB03_CALLED.
*SUBMIT ZPROGB03_CALLED AND RETURN.
*SUBMIT ZPROGB03_CALLED VIA SELECTION-SCREEN AND RETURN.

WRITE: 'CALL 프로그램으로 돌아왔어요!'.

*************** CALLED ****************
REPORT ZPROGB03_CALLED.

PARAMETERS: pa_car TYPE s_carr_id.
SELECT-OPTIONS: so_con FOR gs_sflight-connid.

IF sy-subrc = 0.
  LOOP AT gt_sflight INTO gs_sflight.
    WRITE:/ gs_sflight-carrid,
            gs_sflight-connid,
            gs_sflight-fldate,
            gs_sflight-seatsmax,
            gs_sflight-seatsocc.
    CLEAR: gs_sflight.
  ENDLOOP.
ELSE.
  WRITE:/ 'No data'.
ENDIF.
```
</br>
</br>
</br>

### 2) 트랜잭션 호출 방식
- 현재 프로그램 종료 후 트랜잭션으로 이동 (복귀 ❌)
- 내부 세션이 종료되어 ABAP Memory는 리셋됨
- 새로운 세션으로 트랜잭션이 시작되며 SAP Memory만 유지됨
```abap
LEAVE TO TRANSACTION 'T_CODE'
```
- 트랜잭션의 첫 화면을 건너뛰고 바로 실행
```abap
LEAVE TO TRANSACTION 'T_CODE' AND SKIP FIRST SCREEN
```
- 트랜잭션 실행 후 종료 시 원래 프로그램으로 복귀 ⭕
- 트랜잭션 화면을 열었다가 끝나면 돌아옴 → 메모리 유지됨
```abap
CALL TRANSACTION 'T_CODE'
```
</br>
</br>

**1) LEAVE TO TRANSACTION 'ZTCODEB03_CALLED'**

- ZTCODEB03_CALLED로 넘어가서 실행되고 CALL 프로그램으로 돌아오지 않아 "CALL 프로그램으로 돌아왔어요!"는 안 찍힘

**2) LEAVE TO TRANSACTION 'ZTCODEB03_CALLED' AND SKIP FIRST SCREEN**

- ZTCODEB03_CALLED를 조회조건 화면 없이 바로 실행하고, CALL 프로그램으로 돌아오지 않음

**3) CALL TRANSACTION 'ZTCODEB03_CALLED'**

- ZTCODEB03_CALLED를 실행한 뒤 돌아와서 "CALL 프로그램으로 돌아왔어요!"가 찍힘

```abap
*************** CALL ****************
REPORT ZPROGB03_CALL.

PARAMETERS: pa_car TYPE s_carr_id.
SELECT-OPTIONS: so_con FOR gs_sflight-connid.

SELECTION-SCREEN BEGIN OF BLOCK blk1 WITH FRAME.
  SELECTION-SCREEN BEGIN OF LINE.
    SELECTION-SCREEN COMMENT pos_low(20) TEXT-001 FOR FIELD pa_rad1.
    PARAMETERS: pa_rad1 RADIOBUTTON GROUP RAD.
    SELECTION-SCREEN COMMENT pos_high(20) TEXT-002 FOR FIELD pa_rad2.
    PARAMETERS: pa_rad2 RADIOBUTTON GROUP RAD DEFAULT 'X'.
  SELECTION-SCREEN END OF LINE.
SELECTION-SCREEN END OF BLOCK blk1.

START-OF-SELECTION.
CASE 'X'.
  WHEN pa_rad1.
*    LEAVE TO TRANSACTION 'ZTCODEB03_CALLED'
    LEAVE TO TRANSACTION 'ZTCODEB03_CALLED'
    AND SKIP FIRST SCREEN.
  WHEN pa_rad2.
    CALL TRANSACTION 'ZTCODEB03_CALLED'.
  WHEN OTHERS.
ENDCASE.

WRITE: 'CALL 프로그램으로 돌아왔어요!'.
```
</br>
</br>
</br>

### 3) 프로그램 간 데이터 전달
- 앞 프로그램에서 입력한 값을 다음 프로그램으로 그대로 넘길 때 사용
```abap
SUBMIT <CALLED_PROGRAM>
  VIA SELECTION-SCREEN AND RETURN
  WITH <CALLED_PARM> = <CALL_PARM>
  WITH <CALLED_SO>   IN <CALL_SO>.
```
```abap
*************** CALL ****************
PARAMETERS: pa_car TYPE s_carr_id.
SELECT-OPTIONS: so_con FOR gs_sflight-connid.

START-OF-SELECTION.

SUBMIT ZPROGB03_CALLED
VIA SELECTION-SCREEN
AND RETURN
WITH pa_car2 = pa_car
WITH so_con2 IN so_con.

*************** CALLED ****************
PARAMETERS: pa_car2 TYPE s_carr_id.
SELECT-OPTIONS: so_con2 FOR gs_sflight-connid.
```

</br>
</br>
</br>

### 4) EXPORT / IMPORT를 이용한 ABAP Memory 데이터 공유 (ABAP Memory)
- 프로그램을 이동해도 이전에 입력한 값을 다시 쓰기 위해 ABAP Memory를 사용함
- `LEAVE TO TRANSACTION` 은 세션을 종료하므로 ABAP Memory(EXPORT/IMPORT)는 사용 불가
- `CALL` 프로그램에서 저장한 값을 같은 창에서 `CALLED` 프로그램을 실행하면 정상적으로 가져옴
- 새 창(New Session)에서 `CALLED` 프로그램을 실행하면 ABAP Memory를 못 가져와 `No data` 발생
```abap
" ABAP Memory에 값 저장
EXPORT
  <MEM_PARM> FROM <CALL_PARM>
  <MEM_SO>   FROM <CALL_SO>
  TO MEMORY ID '<MEMORY_ID>'.

" ABAP Memory에서 값 불러오기
IMPORT
  <MEM_PARM> TO <CALLED_PARM>
  <MEM_SO>   TO <CALLED_SO>
  FROM MEMORY ID '<MEMORY_ID>'.

" ABAP Memory 초기화
FREE MEMORY ID '<MEMORY_ID>'.
```
```abap
*************** CALL ****************
PARAMETERS: pa_car TYPE s_carr_id.
SELECT-OPTIONS: so_con FOR gs_sflight-connid.

FREE MEMORY ID 'CARCON'.

EXPORT
  p1 FROM pa_car
  s1 FROM so_con
  TO MEMORY ID 'CARCON'.

*************** CALLED ****************
PARAMETERS: pa_car2 TYPE s_carr_id.
SELECT-OPTIONS: so_con2 FOR gs_sflight-connid.

IMPORT
  p1 TO pa_car2
  s1 TO so_con2
  FROM MEMORY ID 'CARCON'.

FREE MEMORY ID 'CARCON'.
```
</br>
</br>
</br>

### 5) MEMORY ID를 이용한 조회조건 자동 유지 (SAP Memory, SET / GET PARAMETER ID)
- 한 번 입력한 조회조건을 SAP이 기억해두었다가, 다음 실행 때 자동으로 다시 채워줌
```abap
PARAMETERS: <PARAM> TYPE <TYPE> MEMORY ID '<MEM_ID>'.
SELECT-OPTIONS: <SO> FOR <FIELD> MEMORY ID '<MEM_ID>'.

" SAP Memory 초기화
SET PARAMETER ID '<MEM_ID>' FIELD SPACE.
```
```abap
*************** CALL ****************
PARAMETERS: pa_car TYPE s_carr_id MEMORY ID CAR1.
SELECT-OPTIONS: so_con FOR gs_sflight-connid MEMORY ID CON1.

SET PARAMETER ID 'CAR1' FIELD SPACE. " SAP Memory 초기화

*************** CALLED ****************
PARAMETERS: pa_car2 TYPE s_carr_id MEMORY ID CAR1.
SELECT-OPTIONS: so_con2 FOR gs_sflight-connid MEMORY ID CON1.
```
- SAP Memory에 값을 저장하고 같은 세션의 다른 프로그램·화면에서 그 값을 자동으로 전달·조회하는 기능
```abap
*************** SET ****************
SET PARAMETER ID '<MEM_ID>' FIELD <FIELD>.

*************** GET ****************
GET PARAMETER ID '<MEM_ID>' FIELD <FIELD>.
```
```abap
*************** SET ****************
SET PARAMETER ID 'CAR1' FIELD pa_car.     
SET PARAMETER ID 'CON1' FIELD pa_conn.   

*************** GET ****************
GET PARAMETER ID 'CAR1' FIELD pa_car2.    
GET PARAMETER ID 'CON1' FIELD pa_conn2.   
```
</br>
</br>
</br>

---

</br>

## < 실습 코드 >
</br>

### 실습 1
</br>

- 문제
<img width="356" height="196" alt="image" src="https://github.com/user-attachments/assets/4888e9dc-6d7b-43c1-ac54-52f8f3c76a29" />
</br>
</br>
</br>
</br>

**1) Report 프로그램에서 모듈 생성**
```abap
REPORT ZPROGB03_0031.

INCLUDE ZPROGB03_0031_TOP.
INCLUDE ZPROGB03_0031_O01.
INCLUDE ZPROGB03_0031_I01.
INCLUDE ZPROGB03_0031_F01.

START-OF-SELECTION.
  PERFORM get_data.
  CALL SCREEN 100.
```
</br>

**2) `TOP` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZPROGB03_0031_TOP
*&---------------------------------------------------------------------*

DATA: OK_CODE TYPE sy-ucomm,
      go_dock TYPE REF TO cl_gui_docking_container,
      go_alv TYPE REF TO cl_gui_alv_grid.
DATA: gt_sflight TYPE TABLE OF sflight.

PARAMETERS: pa_car TYPE sflight-carrid DEFAULT 'AZ'.
```
</br>

**3) `PBO` 및 `F01` 모듈 생성**
```abap
*************** F01 ****************
FORM get_data.
  SELECT * FROM SFLIGHT
    INTO TABLE gt_sflight
    UP TO 30 ROWS
    WHERE carrid = pa_car.
ENDFORM.

*************** PBO ****************
MODULE status_0100 OUTPUT.
 SET PF-STATUS 'S100'.
ENDMODULE.

MODULE init_alv OUTPUT.
  IF go_dock IS INITIAL.
    CREATE OBJECT go_dock
      EXPORTING
        repid                       = sy-repid
        dynnr                       = sy-dynnr
        side                        = cl_gui_docking_container=>dock_at_bottom
        extension                   = 300.

    CREATE OBJECT go_alv
      EXPORTING
        i_parent          = go_dock.

    CALL METHOD go_alv->set_table_for_first_display
      EXPORTING
        i_structure_name              = 'SFLIGHT'
      CHANGING
        it_outtab                     = gt_sflight
      EXCEPTIONS
        invalid_parameter_combination = 1
        program_error                 = 2
        too_many_lines                = 3
        others                        = 4.
    IF sy-subrc <> 0.
      MESSAGE '데이터 조회 중 오류 발생' TYPE 'E'.
    ENDIF.
  ELSE.
    IF sy-subrc = 0.
      CALL METHOD go_alv->refresh_table_display
        EXCEPTIONS
          finished       = 1
          others         = 2.
      IF sy-subrc <> 0.
        MESSAGE 'Refresh 작업 중 오류 발생' TYPE 'E'.
      ENDIF.
    ENDIF.
  ENDIF.
ENDMODULE.
```
</br>

**4) `PAI` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZPROGB03_0031_I01
*&---------------------------------------------------------------------*

MODULE exit INPUT.
  CASE OK_CODE.
    WHEN 'EXIT'.
      LEAVE PROGRAM.
    WHEN 'CANCEL'.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.

*----------------------------------------------------------------------*

MODULE user_command_0100 INPUT.
  CASE OK_CODE.
    WHEN 'BACK'.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```
</br>

**5) 결과 확인**

<img width="284" height="96" alt="image" src="https://github.com/user-attachments/assets/386d3fff-0177-4a29-b0ea-08e209effe26" />
</br>

<img width="454" height="258" alt="image" src="https://github.com/user-attachments/assets/2aa8ec00-46bf-4df0-b667-80620cbd6164" />
</br>
</br>
</br>
</br>
</br>
</br>

### 실습 2
</br>

- 문제
<img width="330" height="183" alt="image" src="https://github.com/user-attachments/assets/254b894d-5b6d-443b-8bf2-5ab47bb16ce7" />

</br>
</br>
</br>

**1) Report 프로그램에서 모듈 수정**
```abap
REPORT ZPROGB03_0031.

INCLUDE ZPROGB03_0031_TOP.
INCLUDE ZPROGB03_0031_C01.
INCLUDE ZPROGB03_0031_O01.
INCLUDE ZPROGB03_0031_I01.
INCLUDE ZPROGB03_0031_F01.

START-OF-SELECTION.
  PERFORM get_data2.
  CALL SCREEN 100.
```
</br>

**2) `TOP` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Include          ZPROGB03_0031_TOP
*&---------------------------------------------------------------------*

DATA: OK_CODE TYPE sy-ucomm,
      go_dock TYPE REF TO cl_gui_docking_container,
      go_splitter TYPE REF TO cl_gui_splitter_container,
      go_cont_l TYPE REF TO cl_gui_container,
      go_cont_r TYPE REF TO cl_gui_container,
      go_alv_l TYPE REF TO cl_gui_alv_grid,
      go_alv_r TYPE REF TO cl_gui_alv_grid.
```
</br>

**3) `F01` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Include          ZPROGB03_0031_F01
*&---------------------------------------------------------------------*

*************** SFLIGHT 데이터ㅗ ****************
FORM get_data.
  READ TABLE gt_spfli INTO gs_spfli INDEX gv_index.

  SELECT * FROM SFLIGHT
    INTO TABLE gt_sflight
    UP TO 30 ROWS
    WHERE carrid = gs_spfli-carrid
      AND connid = gs_spfli-connid.
ENDFORM.

*************** SPFLI 데이터 ****************
FORM get_data2.
  SELECT * FROM SPFLI
    INTO TABLE gt_spfli
    UP TO 30 ROWS
    WHERE carrid = pa_car.
ENDFORM.

*************** REFRESH ****************
FORM set_refresh.
  CALL METHOD go_alv_r->refresh_table_display
    EXCEPTIONS
      finished       = 1
      others         = 2.
  IF sy-subrc <> 0.
    MESSAGE 'Refresh 작업 중 오류 발생' TYPE 'E'.
  ENDIF.
ENDFORM.
```
</br>

**4) `C01` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZPROGB03_0031_C01
*&---------------------------------------------------------------------*

CLASS lcl_event_handler DEFINITION.
  PUBLIC SECTION.
  CLASS-METHODS: ON_DOUBLE_CLICK
    FOR EVENT DOUBLE_CLICK OF CL_GUI_ALV_GRID
    IMPORTING ES_ROW_NO SENDER.
ENDCLASS.

CLASS lcl_event_handler IMPLEMENTATION.
  METHOD ON_DOUBLE_CLICK.
    IF SENDER = GO_ALV_L.
      gv_index = ES_ROW_NO-row_id.
      PERFORM get_data.
      PERFORM set_refresh.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
```
</br>

**5) `PBO` 모듈 수정**
```abap
*&---------------------------------------------------------------------*
*& Include          ZPROGB03_0031_O01
*&---------------------------------------------------------------------*

MODULE init_alv OUTPUT.
  IF go_dock IS INITIAL.

*************** Docking Container 생성 ****************
    CREATE OBJECT go_dock
      EXPORTING
        repid                       = sy-repid
        dynnr                       = sy-dynnr
        side                        = cl_gui_docking_container=>dock_at_bottom
        extension                   = 300.

*************** Splitter 생성 (1행 2열) ****************
    CREATE OBJECT go_splitter
    EXPORTING parent = go_dock
              rows = 1
              columns = 2.

*************** Split 영역 Container 획득 ****************
    CALL METHOD go_splitter->get_container
    EXPORTING row = 1
              column = 1
    RECEIVING container = go_cont_l.
    CALL METHOD go_splitter->get_container
    EXPORTING row = 1
              column = 2
    RECEIVING container = go_cont_r.

*************** Split 영역에 ALV 생성 ****************
    CREATE OBJECT go_alv_l
    EXPORTING i_parent = go_cont_l.
    CREATE OBJECT go_alv_r
    EXPORTING i_parent = go_cont_r.

*************** 데이터 조회 ****************
    SET HANDLER lcl_event_handler=>on_double_click FOR go_alv_l.

    CALL METHOD go_alv_r->set_table_for_first_display
      EXPORTING
        i_structure_name              = 'SFLIGHT'
      CHANGING
        it_outtab                     = gt_sflight
      EXCEPTIONS
        invalid_parameter_combination = 1
        program_error                 = 2
        too_many_lines                = 3
        others                        = 4.
    IF sy-subrc <> 0.
      MESSAGE '데이터 조회 중 오류 발생' TYPE 'E'.
    ENDIF.

    PERFORM get_data.
    CALL METHOD go_alv_l->set_table_for_first_display
      EXPORTING
        i_structure_name              = 'SPFLI'
      CHANGING
        it_outtab                     = gt_spfli
      EXCEPTIONS
        invalid_parameter_combination = 1
        program_error                 = 2
        too_many_lines                = 3
        others                        = 4.
    IF sy-subrc <> 0.
      MESSAGE '데이터 조회 중 오류 발생' TYPE 'E'.
    ENDIF.
  ENDIF.
ENDMODULE.
```
</br>

**6) 결과 확인**

- 더블클릭 시 데이터 출력
<img width="535" height="240" alt="image" src="https://github.com/user-attachments/assets/0faf79a3-c470-4a4f-9e7a-d27efd122f58" />

</br>
</br>
</br>
</br>
</br>
</br>

</br>
</br>

# 01/06
</br>
</br>

## <  핵심 개념 >
</br>

- **1) BDC (Batch Data Creation)**
- **2) SAP Job(백그라운드 잡) - SM36, SM37**
- **3) CLIENT(MANDT) 지정 방식 – 구문법 vs 신문법**
- **4)  Open SQL INSERT 구문**
- **5) Open SQL UPDATE 구문**
</br>

- **`UPDATE` 는 기존 레코드만 수정하고, `MODIFY` 는 있으면 수정·없으면 INSERT까지 수행**
</br>
</br>

---

</br>

## < SAP 자동 실행 처리 기법 >
</br>

### 1) BDC (Batch Data Creation)
- 실제 트랜잭션 화면 입력 과정을 BDCDATA에 기록해 프로그램으로 자동 실행하는 방식
</br>

**< CALL TRANSACTION - MODE 옵션 >**

| MODE | 설명 |
|------|------|
| A | 모든 화면 표시 / 진행 중 수정 가능 |
| E | 정상 흐름은 숨기고 오류 화면만 표시 |
| N | 화면 없이 백그라운드 처리 (사용자는 못 봄) |
| P | 오류 발생 시 화면 일시정지 |

**< CALL TRANSACTION - UPDATE 옵션 >**

| UPDATE | 설명 |
|--------|------|
| S | 동기 처리 (작업 완료 후 프로그램 복귀) |
| A | 비동기 처리 (즉시 복귀, 작업은 백그라운드 진행) |

</br>

```abap
*************** BDC Dynpro 시작 ****************
PERFORM set_bdcdata USING 'X' <PROGRAM> <SCREEN>.
* <PROGRAM> : Dynpro 프로그램명
* <SCREEN>  : Dynpro 번호


*************** BDC 화면 필드 입력 ****************
PERFORM set_bdcdata USING ' ' <FIELDNAME> <VALUE>.
* <FIELDNAME> : 화면 필드명 (예: BDC_OKCODE, PA_CAR2)
* <VALUE>     : 입력값


*************** BDC DATA 공통 FORM ****************
FORM set_bdcdata USING pv_dynbegin   " Dynpro 시작 여부 ('X' / ' ')
                       pv_fname      " 프로그램명 or 필드명
                       pv_fval.      " 화면번호 or 입력값

  CLEAR gs_bdcdata.
  IF pv_dynbegin EQ abap_true.        " Dynpro 시작
    gs_bdcdata-dynbegin = abap_true.
    gs_bdcdata-program  = pv_fname.
    gs_bdcdata-dynpro   = pv_fval.
  ELSE.                              " 화면 필드 입력
    gs_bdcdata-fnam = pv_fname.
    gs_bdcdata-fval = pv_fval.
  ENDIF.
  APPEND gs_bdcdata TO gt_bdcdata.    " BDCDATA 한 줄 적재
ENDFORM.
```
```abap
REPORT ZPROGB03_CALL.

*************** BDC DATA 선언부 ****************
DATA: gs_bdcdata      TYPE bdcdata,             " BDCDATA 단건 구조
      gt_bdcdata      TYPE STANDARD TABLE OF bdcdata,
      lt_bdc_message  TYPE STANDARD TABLE OF bdcmsgcoll.


*************** BDC DATA 적재 (CALL 쪽) ****************
PERFORM set_bdcdata USING:
* STARTID   PROGRAM / FIELDNAME    SCREEN / VALUE
  'X'       'ZPROGB03_CALLED'      '1000',      " Dynpro 시작
  ' '       'BDC_CURSOR'           'SO_CON2-HIGH',
  ' '       'BDC_OKCODE'           '=ONLI',
  ' '       'PA_CAR2'              'AA',
  ' '       'SO_CON2-LOW'          '17',
  ' '       'SO_CON2-HIGH'         '64',
  'X'       'SAPMSSY0'              '0120',     " 팝업 Dynpro
  ' '       'BDC_OKCODE'           '=BACK',
  'X'       'ZPROGB03_CALLED'      '1000',      " 원화면
  ' '       'BDC_OKCODE'           '/EE',
  ' '       'BDC_CURSOR'           'PA_CAR2'.

*************** BDC CALL TRANSACTION ****************
CALL TRANSACTION 'ZTCODEB03_CALLED'
  USING gt_bdcdata
  MODE 'A'
  UPDATE 'S'
  MESSAGES INTO lt_bdc_message.

*************** BDC DATA 함수 ****************
FORM set_bdcdata  USING    pv_dynbegin
                           pv_fname
                           pv_fval.
  CLEAR gs_bdcdata.
  IF pv_dynbegin EQ abap_true. " pv_dynbegin = 'X'
    gs_bdcdata-dynbegin = abap_true.
    gs_bdcdata-program = pv_fname.
    gs_bdcdata-dynpro = pv_fval.
  ELSE.
    gs_bdcdata-fnam = pv_fname.
    gs_bdcdata-fval = pv_fval.
  ENDIF.
  APPEND gs_bdcdata TO gt_bdcdata.
ENDFORM.
```
</br>

- system -> services -> batch input -> recorder 클릭
<img width="498" height="258" alt="image" src="https://github.com/user-attachments/assets/70fb2045-a16b-4189-a43b-6dc7289f1fb0" />
</br>
</br>

- new recording 누르고 start recording 클릭
<img width="441" height="413" alt="image" src="https://github.com/user-attachments/assets/2f12a82d-cd6e-4f78-804f-6c51306bbd57" />
</br>
</br>

- 녹화 후 Process 클릭하여 실행
<img width="471" height="379" alt="image" src="https://github.com/user-attachments/assets/25131805-f01f-4c9f-a0d4-f34736a3188c" />
</br>
</br>

- 만든 레코드 확인 가능
<img width="501" height="150" alt="image" src="https://github.com/user-attachments/assets/b56b127f-f634-4c8b-833d-1325e1f61d4d" />
</br>
</br>
</br>
</br>
</br>

### 2) SAP Job(백그라운드 잡) - SM36, SM37
- Job = 사람이 안 눌러도 정해진 조건/시간에 ABAP 프로그램을 자동 실행하는 작업
- **SM36** → 잡(Job) 생성
- **SM37** → 생성된 잡(Job) 조회 / 상태 확인
</br>

- 백그라운드 잡에서는 ALV 사용 불가 (화면 인스턴스 생성 불가)
- 시스템 변수 `sy-batch = 'X'` → 현재 백그라운드 실행 중
- 이 경우 ALV 대신 WRITE, 스풀, 파일 출력 등으로 처리
```abap
REPORT ZPROGB03_0032.

DATA: gt_data TYPE TABLE OF ZDBWORK_B03,
      gs_data LIKE LINE OF gt_data.

SELECT * FROM ZDBWORK_B03
  INTO TABLE gt_data
  ORDER BY WORKNO DESCENDING." 내림차순

CHECK sy-subrc = 0.

READ TABLE gt_DATA INTO GS_DATA INDEX 1.
ADD 1 TO gs_data-workno.

*********** 처음 넣은 데이터 ***********
gs_data-workno = 1.
gs_data-workdesc = 'hello work~~'.
gs_data-ernam = sy-uname. " 유저이름
gs_data-erdat = sy-datum. " 현재 일자
gs_data-erzet = sy-uzeit. " 현재 시간
***************************************

gs_data-workdesc = 'hello work~~'.
gs_data-ernam = sy-uname. " 유저이름
gs_data-erdat = sy-datum. " 현재 일자
gs_data-erzet = sy-uzeit. " 현재 시간

INSERT ZDBWORK_B02 FROM gs_data.
IF sy-subrc = 0.
  SELECT * FROM ZDBWORK_B03
    INTO TABLE gt_data
    ORDER BY workno DESCENDING.
  cl_demo_output=>display( gt_data ).
ENDIF.
```
</br>

- `SM36` 로 JOB 생성하기
- 프로그램 이름 지정
<img width="448" height="279" alt="image" src="https://github.com/user-attachments/assets/b2b681d2-7fc4-4bf3-bc4f-9779b6f4eea4" />
</br>
</br>

- JOB 시작 조건을 주기적 실행으로 설정해 20분마다 백그라운드 JOB을 자동 실행하도록 설정
- `No Start After` : 종료일이 아님. 시작일의 유효기간. 종료일은 빈칸으로 둬야 함.
<img width="459" height="369" alt="image" src="https://github.com/user-attachments/assets/da67cc6f-53a4-4032-9a56-7644a4695deb" />
</br>
</br>

- `SM37` 에서 생성된 JOB 확인 가능
<img width="458" height="328" alt="image" src="https://github.com/user-attachments/assets/81eb3a77-eb99-4185-aabb-f116a08e790b" />
</br>
</br>
</br>
</br>

---

</br>

## < ABAP Open SQL 핵심 문법 정리 >
</br>

### 1) CLIENT(MANDT) 지정 방식 – 구문법 vs 신문법
- Open SQL에서 특정 클라이언트(MANDT)의 데이터를 직접 지정해 조회
```abap
*************** Open SQL CLIENT 지정 – 구문법 (형식) ****************
SELECT <FIELDS>
  INTO TABLE <ITAB>
  FROM <DB_TABLE>
  CLIENT SPECIFIED
  WHERE mandt = <CLIENT>.


*************** Open SQL CLIENT 지정 – 신문법 (형식) ****************
SELECT <FIELDS>
  INTO TABLE @<ITAB>
  FROM <DB_TABLE>
  USING CLIENT <CLIENT>.
```
```abap
REPORT ZPROGB03_0033.

*************** Open SQL – CLIENT 지정 (구문법) ****************
SELECT * INTO TABLE gt_scarr
  FROM scarr
  CLIENT SPECIFIED
  WHERE mandt = '100'.   
* WHERE MANDT BETWEEN '000' AND '900'.

*************** Open SQL – CLIENT 지정 (신문법) ****************
SELECT * INTO TABLE @gt_scarr
  FROM scarr
  USING CLIENT '000'.    
```
</br>
</br>

### 2) Open SQL INSERT 구문
- 워크에어리어로 단건, 내부테이블로 여러 건 데이터를 DB에 저장
- `ACCEPTING DUPLICATE KEYS` 를 사용하면 중복 키는 건너뛰고 나머지 데이터만 INSERT됨
- 중복 키 상태에서 INSERT를 실행하면 → 덤프 발생
- **`sy-dbcnt`** 로 실제 INSERT된 결과를 확인
```abap
*************** 단건 INSERT ****************
INSERT INTO <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  VALUES <WORK_AREA>.        " 워크에어리어 1건 INSERT

INSERT <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  FROM <WORK_AREA>.          " VALUES와 동일 의미

*************** 다중 INSERT ****************
INSERT <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  FROM TABLE <ITAB>
  [ACCEPTING DUPLICATE KEYS]. " 내부테이블 여러 건 INSERT
```
```abap
REPORT ZPROGB03_0033.

DATA: gt_scustom TYPE TABLE OF ZTSCUSTOM_B03,
      gs_scustom TYPE ZTSCUSTOM_B03.
* DELETE FROM ZTSCUSTOM_B03. => ACCEPTING DUPLICATE KEYS 안하면 써야함

*************** 단건 INSERT (Work Area) ****************
SELECT SINGLE *
  FROM SCUSTOM
  INTO gs_scustom
  WHERE ID = 1.

INSERT INTO ZTSCUSTOM_B03 VALUES gs_scustom.
INSERT ZTSCUSTOM_B03 FROM gs_scustom.

*************** 다중 INSERT (Internal Table) ****************
SELECT * FROM scustom
  INTO TABLE gt_scustom
  WHERE ID BETWEEN 1 AND 50.

INSERT ZTSCUSTOM_B03 FROM TABLE gt_scustom
  ACCEPTING DUPLICATE KEYS.
```
</br>
</br>

### 3) Open SQL UPDATE 구문
- 기존 DB 레코드를 PK 기준으로 1건 수정하거나, 조건(WHERE)에 맞는 여러 건을 한 번에 수정할 수 있음
- 수정된 레코드 수는 **`sy-dbcnt`** 로 확인 가능 (0이면 대상 없음)
- UPDATE는 기존 레코드만 수정하고, MODIFY는 있으면 수정·없으면 INSERT까지 수행
```abap
*************** 단건 UPDATE (Work Area) ****************
UPDATE <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  FROM <WORK_AREA>.          " PK 기준 1건 수정

*************** 단건 / 다중 UPDATE (SET / WHERE) ****************
UPDATE <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  SET <FIELD1> = <VALUE1>,
      <FIELD2> = <VALUE2>
  WHERE <FULL_QUALIFIED_KEY>. " 조건에 맞는 필드만 단건/다중 수정

*************** 다중 UPDATE (Internal Table 방식) ****************
UPDATE <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  FROM TABLE <ITAB>.          " 내부테이블 기준 여러 건 수정
```
```abap
REPORT ZPROGB03_0033.

*************** 단건 UPDATE (Work Area) ****************
gs_scustom-id = 1.
gs_scustom-name = 'change name'.
UPDATE ZTSCUSTOM_B03 FROM gs_scustom.

*************** 단건 / 다중 UPDATE (SET / WHERE) ****************
gs_scustom-id = 2.
gs_scustom-name = 'second change'.      " 단건 변경
UPDATE ZTSCUSTOM_B03
   SET name = gs_scustom-name
       street = 'hihi'
   WHERE ID = gs_scustom-id.

UPDATE ZTSCUSTOM_B03
  SET form = 'My form'                  " 여러건 변경
      city = 'Walldorf'
      country = 'DE'
  WHERE id BETWEEN 10 AND 20.

*************** 다중 UPDATE (Internal Table 방식) ****************
SELECT * FROM scustom
  INTO TABLE gt_scustom
  WHERE id BETWEEN 10 AND 20.

LOOP AT gt_scustom INTO gs_scustom.
  gs_scustom-form = 'My form'.
  gs_scustom-city = 'Walldorf'.
  gs_scustom-country = 'DE'.
  MODIFY gt_scustom FROM gs_scustom.
ENDLOOP.
UPDATE ZTSCUSTOM_B03 FROM TABLE gt_scustom.
```
</br>
</br>

### 4) Open SQL MODIFY 구문
- PK 기준으로 데이터가 있으면 UPDATE, 없으면 INSERT 수행
- **`sy-dbcnt`** 로 실제 반영된 수정 결과를 확인
- `APPENDING TABLE` : 기존 내부테이블을 비우지 않고 SELECT 결과를 뒤에 계속 추가하는 방식
```abap
*************** 단건 MODIFY (Work Area) ****************
MODIFY <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  FROM <WORK_AREA>.          " 있으면 UPDATE, 없으면 INSERT

*************** 다중 MODIFY (Internal Table 방식) ****************
MODIFY <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  FROM TABLE <ITAB>.          " 여러 건 UPSERT 처리
```
```abap
REPORT ZPROGB03_0033.

*************** 단건 MODIFY (Work Area) ****************
gs_scustom-id = 500.
gs_scustom-form = '변경~~'.
gs_scustom-name = 'MODIFY 변경~~'.
MODIFY ZTSCUSTOM_B03 FROM gs_scustom.

*************** 다중 MODIFY (Internal Table 방식) ****************
gs_scustom-name = 'modify name'.
MODIFY gt_scustom FROM gs_scustom
TRANSPORTING name WHERE id <> space.

SELECT *
  APPENDING TABLE gt_scustom
  FROM scustom
  WHERE ID IN ( 193, 195, 197 ).
" 완성된 itab을 db tab에 modify
MODIFY ZTSCUSTOM_B03 FROM TABLE gt_scustom.
```
</br>
</br>

### 5) Open SQL DELETE 구문
- PK 기준으로 단건 삭제하거나 조건(WHERE)에 맞는 여러 건 삭제 가능
- 삭제된 레코드 수는 **`sy-dbcnt`** 로 확인
- 조건이 맞는 데이터가 없으면 아무 것도 삭제되지 않음
```abap
*************** 단건 DELETE (Work Area) ****************
DELETE <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  FROM <WORK_AREA>.          " PK 기준 1건 삭제

*************** 단건 / 다중 DELETE (WHERE) ****************
DELETE FROM <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  WHERE <FULL_QUALIFIED_KEY>. " 조건에 맞는 단건/다중 삭제

*************** 다중 DELETE (Internal Table 방식) ****************
DELETE <DB_TABLE>
  [CLIENT SPECIFIED | USING CLIENT <CLIENT>]
  FROM TABLE <ITAB>.          " 내부테이블의 PK 기준으로 여러 건 삭제
```
```abap
REPORT ZPROGB03_0033.

*************** 단건 DELETE (Work Area) ****************
gs_scustom-id = 1.
DELETE ZTSCUSTOM_B03 FROM gs_scustom.

*************** 단건 / 다중 DELETE (WHERE) ****************
DELETE FROM ZTSCUSTOM_B03 WHERE ID = 2.    " 단건 삭제

DELETE FROM ZTSCUSTOM_B03
  WHERE ID BETWEEN 55 AND 60.              " 여러건 삭제

*************** 다중 DELETE (Internal Table 방식) ****************
" DELETE FROM ZTSCUSTOM_B03 " (주의) 전체 삭제

SELECT * FROM ZTSCUSTOM_B03
  INTO TABLE gt_scustom
  WHERE ID <= 50.
DELETE ZTSCUSTOM_B03 FROM TABLE gt_scustom.
```

</br>
</br>

# 01/07
</br>
</br>

## <  핵심 개념 >
</br>

- **서브스크린 생성시 LAYOUT에 서브스크린 지정 필수**
- **`MEMORY ID` 는 PARAMETERS, SELECT-OPTIONS에서만 선언 가능 (DATA는 불가능)**
</br>
</br>

---

</br>

## < 실습 코드 >
</br>

### 실습 1
</br>

- 문제
- ALV에 DB 테이블 데이터 삽입, 수정, 삭제 실습
<img width="357" height="426" alt="image" src="https://github.com/user-attachments/assets/74c4ba9f-a621-4675-9072-30952ea8c91b" />
</br>
</br>
</br>

**1) Report program 코드 생성**
```abap
REPORT ZBC400_PRACTICE1_B03.

INCLUDE ZBC400_PRACTICE1_B03_TOP.
INCLUDE ZBC400_PRACTICE1_B03_C01.
INCLUDE ZBC400_PRACTICE1_B03_O01.
INCLUDE ZBC400_PRACTICE1_B03_I01.
INCLUDE ZBC400_PRACTICE1_B03_F01.

START-OF-SELECTION.
PERFORM set_data.
CALL SCREEN 100.
```
</br>

**2) `TOP` 모듈 생성**
- 서브스크린 생성시 LAYOUT에 서브스크린 지정 필수
```abap
DATA: OK_CODE TYPE sy-ucomm.

DATA: go_docking TYPE REF TO cl_gui_docking_container,
      go_alv TYPE REF TO cl_gui_alv_grid.

DATA: gs_data TYPE ZTMYCARRIER_B03,
      gt_data TYPE TABLE OF ZTMYCARRIER_B03,
      gt_sflight TYPE TABLE OF ZREADSFLIGHT_B03.

DATA gs_layout TYPE lvc_s_layo.

SELECTION-SCREEN BEGIN OF SCREEN 110 AS SUBSCREEN.
  PARAMETERS: pa_car TYPE ZTMYCARRIER_B03-carrid,
              pa_con TYPE ZTMYCARRIER_B03-connid,
              pa_name TYPE ZTMYCARRIER_B03-carrname,
              pa_cityf TYPE ZTMYCARRIER_B03-cityfrom,
              pa_airpf TYPE ZTMYCARRIER_B03-airpfrom,
              pa_cityt TYPE ZTMYCARRIER_B03-cityto,
              pa_airpt TYPE ZTMYCARRIER_B03-airpto.
SELECTION-SCREEN END OF SCREEN 110.
```
</br>

**3) `C01` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_PRACTICE1_B03_C01
*&---------------------------------------------------------------------*

CLASS lcl_event_handler DEFINITION.
  PUBLIC SECTION.
  CLASS-METHODS: on_toolbar FOR EVENT toolbar
    OF cl_gui_alv_grid IMPORTING e_object,
      on_user_command FOR EVENT user_command
    OF cl_gui_alv_grid IMPORTING e_ucomm.
  CLASS-METHODS: on_double_click FOR EVENT double_click
    OF cl_gui_alv_grid IMPORTING ES_ROW_NO.
ENDCLASS.

CLASS lcl_event_handler IMPLEMENTATION.
  METHOD on_toolbar.
    DATA ls_button TYPE STB_BUTTON.
    ls_button-butn_type = 3.
    INSERT ls_button INTO TABLE e_object->mt_toolbar.

    CLEAR ls_button.
    ls_button-function = 'INSERT'.
    ls_button-icon = ICON_EXPAND.
    ls_button-butn_type = 0.
    ls_button-text = 'INSERT'.
    INSERT ls_button INTO TABLE e_object->mt_toolbar.

    CLEAR ls_button.
    ls_button-function = 'UPDATE'.
    ls_button-icon = ICON_INTENSIFY.
    ls_button-butn_type = 0.
    ls_button-text = 'UPDATE'.
    INSERT ls_button INTO TABLE e_object->mt_toolbar.

    CLEAR ls_button.
    ls_button-function = 'DELETE'.
    ls_button-icon = ICON_COLLAPSE.
    ls_button-butn_type = 0.
    ls_button-text = 'DELETE'.
    INSERT ls_button INTO TABLE e_object->mt_toolbar.
  ENDMETHOD.

  METHOD ON_USER_COMMAND.
    CASE E_UCOMM.
      WHEN 'INSERT'.
        PERFORM insert_data.
      WHEN 'UPDATE'.
        PERFORM update_data.
      WHEN 'DELETE'.
        DATA: lt_select_data TYPE LVC_T_ROW,
              ls_select_data TYPE LVC_S_ROW.

        CALL METHOD go_alv->get_selected_rows
          IMPORTING
            et_index_rows = lt_select_data.

        PERFORM delete_data USING lt_select_data ls_select_data.
      WHEN OTHERS.
    ENDCASE.
    PERFORM refresh_data.
  ENDMETHOD.

  METHOD on_double_click.
    CLEAR: gs_data, gt_sflight.
    READ TABLE gt_data INTO gs_data INDEX es_row_no-row_id.
    SELECT * FROM sflight
      INTO TABLE gt_sflight
      WHERE carrid = gs_data-carrid
        AND connid = gs_data-connid.

    IF sy-subrc = 0.
      DATA: gv_car TYPE sflight-carrid,
      gv_con TYPE sflight-connid.
      gv_car = gs_data-carrid.
      gv_con = gs_data-connid.
      SET PARAMETER ID 'CARID' FIELD gv_car.
      SET PARAMETER ID 'CONID' FIELD gv_con.

      LEAVE TO TRANSACTION 'ZTPRACTICE1_CALLED'
      AND SKIP FIRST SCREEN.
    ELSE.
      MESSAGE '해당하는 sflight 정보가 없습니다.' TYPE 'E'.
    ENDIF.
  ENDMETHOD.
ENDCLASS.
```
</br>

**4) `F01` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_PRACTICE1_B03_F01
*&---------------------------------------------------------------------*

FORM insert_data .
  CLEAR gs_data.
  gs_data-carrid = pa_car.
  gs_data-connid = pa_con.
  gs_data-carrname = pa_name.
  gs_data-cityfrom = pa_cityf.
  gs_data-airpfrom = pa_airpf.
  gs_data-cityto = pa_cityt.
  gs_data-airpto = pa_airpt.
  gs_data-ernam = sy-uname.
  gs_data-erdat = sy-datum.
  gs_data-erzet = sy-uzeit.

  INSERT ZTMYCARRIER_B03 FROM gs_data.
  IF sy-subrc = 0.
    PERFORM set_data.
  ELSE.
    MESSAGE 'INSERT 실패' TYPE 'E'.
  ENDIF.
ENDFORM.

*&---------------------------------------------------------------------*

FORM update_data .
  CLEAR gs_data.
  SELECT SINGLE * FROM ZTMYCARRIER_B03
    INTO gs_data WHERE carrid = pa_car.
  gs_data-carrid = pa_car.
  gs_data-connid = pa_con.
  gs_data-carrname = pa_name.
  gs_data-cityfrom = pa_cityf.
  gs_data-airpfrom = pa_airpf.
  gs_data-cityto = pa_cityt.
  gs_data-airpto = pa_airpt.
  gs_data-aenam = sy-uname.
  gs_data-aedat = sy-datum.
  gs_data-aezet = sy-uzeit.

  UPDATE ZTMYCARRIER_B03 FROM gs_data.
  IF sy-subrc = 0.
    PERFORM set_data.
  ELSE.
    MESSAGE 'UPDATE 실패' TYPE 'E'.
  ENDIF.
ENDFORM.

*&---------------------------------------------------------------------*

FORM delete_data USING lt_select_data TYPE LVC_T_ROW
                       ls_select_data TYPE LVC_S_ROW.
  CLEAR gs_data.
  LOOP AT lt_select_data INTO ls_select_data.
    READ TABLE gt_data INTO gs_data INDEX ls_select_data-index.
    DELETE ZTMYCARRIER_B03 FROM gs_data.
  ENDLOOP.
  IF sy-subrc = 0.
    PERFORM set_data.
  ELSE.
    MESSAGE 'DELETE 실패' TYPE 'E'.
  ENDIF.
ENDFORM.

*&---------------------------------------------------------------------*

FORM set_data .
  SELECT * FROM ZTMYCARRIER_B03
    INTO TABLE gt_data.
  SORT gt_data BY carrid.
ENDFORM.

*&---------------------------------------------------------------------*

FORM refresh_data .
  CALL METHOD go_alv->refresh_table_display
    EXCEPTIONS
      finished       = 1
      others         = 2.
ENDFORM.
```
</br>

**5) `PBO` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_PRACTICE1_B03_O01
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.
 SET PF-STATUS 'S100'.
 SET TITLEBAR 'T100'.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE init_alv OUTPUT.
  IF go_docking IS INITIAL.
    CREATE OBJECT go_docking
      EXPORTING
        side      = cl_gui_docking_container=>dock_at_bottom
        extension = 200
        repid     = sy-repid
        dynnr     = sy-dynnr.

    CREATE OBJECT go_alv EXPORTING i_parent = go_docking.

    gs_layout-sel_mode = 'A'.
    SET HANDLER lcl_event_handler=>on_toolbar FOR go_alv.
    SET HANDLER lcl_event_handler=>on_user_command FOR go_alv.
    SET HANDLER lcl_event_handler=>on_double_click FOR go_alv.

    CALL METHOD go_alv->set_table_for_first_display
      EXPORTING
        i_structure_name              = 'ZTMYCARRIER_B03'
        is_layout                     = gs_layout
      CHANGING
        it_outtab                     = gt_data
      EXCEPTIONS
        invalid_parameter_combination = 1
        program_error                 = 2
        too_many_lines                = 3
        others                        = 4.
    IF sy-subrc <> 0.
      MESSAGE '데이터 조회 중 오류 발생' TYPE 'E'.
    ENDIF.
  ENDIF.

ENDMODULE.
```
</br>

**6) `PAI` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_PRACTICE1_B03_I01
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.
  CASE OK_CODE.
    WHEN 'BACK'.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE exit INPUT.
  CASE OK_CODE.
    WHEN 'CANCEL'.
      LEAVE TO SCREEN 0.
    WHEN 'EXIT'.
      LEAVE PROGRAM.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```
</br>

**7) 결과 확인**

<img width="690" height="272" alt="image" src="https://github.com/user-attachments/assets/4f210c04-e441-4318-aafc-3097d6a80df8" />

</br>
</br>
</br>
</br>
</br>

### 실습 2
</br>

- 문제
- 티코드로 프로그램 이동 실습
<img width="534" height="244" alt="image" src="https://github.com/user-attachments/assets/b3fe975d-1d3a-4a66-af5a-f1ff20ae632b" />
</br>
</br>
</br>

**1) Report program 코드 생성**
```abap
REPORT ZBC400_PRACTICE1_CALLED_B03.

INCLUDE ZBC400_PRACTICE1_CALLED_TOP.
INCLUDE ZBC400_PRACTICE1_CALLED_O01.
INCLUDE ZBC400_PRACTICE1_CALLED_I01.

START-OF-SELECTION.
  CALL SCREEN 100.
```
</br>

**2) `TOP` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_PRACTICE1_CALLED_TOP
*&---------------------------------------------------------------------*

DATA: OK_CODE TYPE sy-ucomm.
DATA: ZREADSFLIGHT_B03 TYPE TABLE OF sflight.

PARAMETERS: pa_car TYPE sflight-carrid,
            pa_con TYPE sflight-connid.

GET PARAMETER ID 'CARID' FIELD pa_car.
GET PARAMETER ID 'CONID' FIELD pa_con.

DATA: go_docking TYPE REF TO cl_gui_docking_container,
      go_alv TYPE REF TO cl_gui_alv_grid.
```
</br>

**3) `PBO` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_PRACTICE1_CALLED_O01
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.
 SET PF-STATUS 'S100'.
 SET TITLEBAR 'T100'.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE init_alv OUTPUT.
  IF go_docking IS INITIAL.
    SELECT * FROM sflight
      INTO TABLE ZREADSFLIGHT_B03
      WHERE carrid = pa_car
        AND connid = pa_con.

    CREATE OBJECT go_docking
      EXPORTING
        side      = cl_gui_docking_container=>dock_at_bottom
        extension = 300
        repid     = sy-repid
        dynnr     = sy-dynnr.
    CREATE OBJECT go_alv EXPORTING i_parent = go_docking.

    CALL METHOD go_alv->set_table_for_first_display
      EXPORTING
        i_structure_name              = 'SFLIGHT'
      CHANGING
        it_outtab                     = ZREADSFLIGHT_B03
      EXCEPTIONS
        invalid_parameter_combination = 1
        program_error                 = 2
        too_many_lines                = 3
        others                        = 4.
    IF sy-subrc <> 0.
      MESSAGE '데이터 조회 중 오류 발생' TYPE 'E'.
    ENDIF.
  ENDIF.
ENDMODULE.
```
</br>

**4) `PAI` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZBC400_PRACTICE1_CALLED_I01
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.
  CASE OK_CODE.
    WHEN 'BACK'.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE exit INPUT.
  CASE OK_CODE.
    WHEN 'CANCEL'.
      LEAVE TO SCREEN 0.
    WHEN 'EXIT'.
      LEAVE PROGRAM.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```
</br>

**5) 결과 확인**

<img width="690" height="281" alt="image" src="https://github.com/user-attachments/assets/9bde7d50-2da6-4698-b117-8cdd08c60e7c" />


</br>
</br>
</br>
</br>

# 01/08
</br>
</br>

## <  핵심 개념 >
- **1) 암묵적 / 명시적 COMMIT / ROLLBACK**
- **2) PERFORM ON COMMIT**
- **3) Update Module (업데이트 모듈)**
- **4) Lock (SE11, SM12)**
- **5) CALL TRANSACTION MODE·UPDATE 및 호출 방식 요약**
- **6) Number Range (TCODE: `SNRO`)**
</br>

- **반복문(LOOP) 안에서 DB 테이블 직접 UPDATE 하면 안 됨**
</br>
</br>

---

</br>

## < ABAP LUW 기반 DB 처리 흐름 정리 >
- V1 Update는 즉시 실행되는 필수 DB 변경이며, V2 Update는 지연 실행되는 부가 작업임
- Lock은 V1 Update가 끝나면 자동 해제되고, V2 Update는 그 이후에 실행되며 Lock과는 무관함
- PERFORM ON COMMIT은 V1 Update가 끝난 뒤 DB COMMIT 직전에 자동 실행됨
</br>

### 1) COMMIT / ROLLBACK 구분 정리
</br>

- `COMMIT WORK` : 현재 LUW에서 수행된 모든 DB 변경사항을 확정 저장
- `ROLLBACK WORK` : 현재 LUW에서 수행된 모든 DB 변경사항을 취소 (COMMIT 이전까지만 가능)
</br>

**1-1) 암묵적 COMMIT**
- 화면이 변경되거나 프로그램이 비정상 종료될 때 자동 COMMIT
- RFC(Remote Function Call) 호출 시 / RFC 종료 시 자동 COMMIT
  
**1-2) 명시적 COMMIT**
- ABAP 구문으로 개발자가 직접 COMMIT 실행 : `COMMIT WORK`
  
**2-1) 암묵적 ROLLBACK**
- ABAP 덤프 발생 시 자동 ROLLBACK
- `MESSAGE TYPE 'A'` 또는 `MESSAGE TYPE 'X'` 발생 시 자동 ROLLBACK
  
**2-2) 명시적 ROLLBACK**
- ABAP 구문으로 개발자가 직접 ROLLBACK 실행 : `ROLLBACK WORK`
</br>


```abap
*************** 암묵적 COMMIT ****************
INSERT ztable FROM gs_data.
CALL SCREEN 200.     " 화면 전환 발생

INSERT ztable FROM gs_data.
LEAVE PROGRAM.      " 프로그램 비정상 종료 

INSERT ztable FROM gs_data.
CALL FUNCTION 'Z_RFC_FUNC'    " RFC 호출 / 종료 
  DESTINATION 'RFC_DEST'.

*************** 명시적 COMMIT ****************
INSERT ztable FROM gs_data.
COMMIT WORK.

*************** 암묵적 ROLLBACK ****************
INSERT ztable FROM gs_data.    " ABAP Dump 발생 → RUNTIME ERROR 발생

INSERT ztable FROM gs_data.
MESSAGE 'Fatal Error' TYPE 'A'.   " MESSAGE TYPE A / X 

*************** 명시적 ROLLBACK ****************
INSERT ztable FROM gs_data.
IF sy-subrc <> 0.
  ROLLBACK WORK.
ENDIF.
```
```abap
REPORT ZPROGB03_0034.

DATA: gt_scustom TYPE TABLE OF ZTSCUSTOM_B03,
      gs_scustom TYPE ZTSCUSTOM_B03.

DELETE FROM ZTSCUSTOM_B03.

SELECT * FROM scustom
  INTO TABLE gt_scustom
  WHERE ID BETWEEN 1 AND 30.

INSERT ZTSCUSTOM_B03 FROM TABLE gt_scustom.

UPDATE ZTSCUSTOM_B03
   SET name = 'First update~~~~~~'
   WHERE ID = 3.

COMMIT WORK. " LUW 종료되면서, 이전에 있던 변경사항이 DB에 반영됨

UPDATE ZTSCUSTOM_B03  " 여기서부터 새로운 LUW 시작
   SET name = 'Second update~~~~~'
   WHERE ID = 2.

UPDATE ZTSCUSTOM_B03
   SET name = 'Third update~~~~~'
   WHERE ID = 1.

ROLLBACK WORK.  " 해당 LUW에 있던 변경사항들 다 취소됨

IF sy-subrc = 0.
  WRITE: '성공'.
  ELSE.
    WRITE: '실패'.
ENDIF.
```
</br>
</br>
</br>

### 2) PERFORM ON COMMIT
- COMMIT WORK가 실행된 뒤 등록된 FORM들을 시스템 테이블에 쌓아두었다가 순서대로 실행
- ON COMMIT으로 묶인 Update Task는 하나라도 실패하면 전부 롤백
```abap
PERFORM x ON COMMIT.
PERFORM y ON COMMIT.
COMMIT WORK.
→ x 실행
→ y 실행
→ DB Commit 완료 (되돌릴 수 없음)
```
```abap
REPORT ZPROGB03_0034.

DATA: gt_scustom TYPE TABLE OF ZTSCUSTOM_B03,
      gs_scustom TYPE ZTSCUSTOM_B03.

DELETE FROM ZTSCUSTOM_B03.
SELECT *
  FROM scustom
  INTO TABLE gt_scustom
  WHERE id BETWEEN 1 AND 30.
INSERT ZTSCUSTOM_B03 FROM TABLE gt_scustom.

PERFORM update_1 ON COMMIT. " 커밋 대기
PERFORM update_2 ON COMMIT.

COMMIT WORK.

*&---------------------------------------------------------------------*

FORM update_1 .
  LOOP AT gt_scustom INTO gs_scustom.
    gs_scustom-name = 'Hone GIldong~~~~22'.
    MODIFY gt_scustom FROM gs_scustom.
  ENDLOOP.

  MODIFY ZTSCUSTOM_B03 FROM TABLE gt_scustom.
  IF sy-subrc = 0.
    WRITE: 'update 1번 성공'.
  ELSE.
    MESSAGE 'update 1번 실패' TYPE 'A'. " 롤백
  ENDIF.
ENDFORM.

*&---------------------------------------------------------------------*

FORM update_2 .
  READ TABLE gt_scustom INTO gs_scustom INDEX 10.
  gs_scustom-name = 'Hong Gildong~~~~~'.
  UPDATE ZTSCUSTOM_B03
     SET name = gs_scustom-name
   WHERE id = gs_scustom-id.

  IF sy-subrc = 0.
    WRITE: 'Update 2번 성공'.
  ELSE.
    MESSAGE 'Update 2번 실패' TYPE 'A'.
  ENDIF.
ENDFORM.
```
</br>
</br>
</br>

### 3) Update Module (업데이트 모듈)
- `CALL FUNCTION … IN UPDATE TASK` 로 등록된 후 COMMIT WORK 시점에 별도 Update Work Process에서 실행되는 DB 전용 Function Module
- IMPORTING 파라미터만 사용하며, DB 변경 중 오류(MESSAGE A/X) 발생 시 해당 Update LUW 전체가 롤백되고 즉시 종료됨
</br>

**1) 비동기 Update**
- `COMMIT WORK` 시 실제 DB 저장은 나중에 `Update Work Process` 가 따로 처리하고, 프로그램은 먼저 종료되는 방식
  
**2) 동기 Update**
- `COMMIT WORK AND WAIT` 를 사용해 Update 작업이 DB에 끝날 때까지 기다린 후 다음 로직(LUW 2)으로 넘어가는 방식
  
**3) Local Update**
- SET UPDATE TASK LOCAL로 Update Task를 같은 워크프로세스에서 즉시 실행해, 별도 Update Work Process 없이 현재 LUW 안에서 DB 반영되는 방식
  
</br>

```abap
******** Dialog Program ********
CALL FUNCTION 'F1' IN UPDATE TASK EXPORTING p1 = a.
CALL FUNCTION 'F2' IN UPDATE TASK EXPORTING q1 = b.
CALL FUNCTION 'F3' IN UPDATE TASK EXPORTING s1 = a.
COMMIT WORK.   " Update Task 실행 시작

******** Update Module ********
FUNCTION F1.
  UPDATE ztable.
     SET field = p1
  IF sy-subrc <> 0.
    MESSAGE 'Error' TYPE 'A'.   " Update LUW 롤백
  ENDIF.
ENDFUNCTION.
```
</br>
</br>

- `SE37` 로 확인 가능
<img width="489" height="270" alt="image" src="https://github.com/user-attachments/assets/cdc3eb43-91f7-4d3b-b09c-f00066d31b74" />
</br>
</br>

- Importing 파라미터만 받음
<img width="486" height="121" alt="image" src="https://github.com/user-attachments/assets/d0192e24-aa8a-40ee-988b-f09a9e39f165" />

</br>
</br>
</br>
</br>
</br>

### 4) Lock (SE11, SM12)
- 다른 사용자가 같은 데이터를 동시에 수정하지 못하게 막는 장치
- Lock Object 이름은 EY 또는 EZ로 시작해야 함
- `SM12` 에서는 현재 설정된 Lock 정보를 확인 가능
- Lock은 전달한 키 값은 정확히 그 값만 잠그고, 키를 안 준 필드는 와일드카드(*)처럼 전부 잠금
</br>

- 기존 Lock과 충돌: 다른 세션이 이미 Lock을 보유한 경우 → 예외 `FOREIGN_LOCK`
- Lock 관리 오류: 시스템 또는 Lock 서버 문제로 Lock 처리 실패 → 예외 `SYSTEM_FAILURE`
</br>


**1) Set lock**
- 특정 데이터(키)에 대해 새로운 Lock 설정

**2️) Promote optimistic lock**
- 기존 약한 Lock을 더 강한 Lock으로 승격

**3️) Check whether lock can be set or promoted**
- 기존 Lock 존재 여부 확인 후 Lock 설정/승격 가능 여부 판단
</br>

- 같은 프로그램에서는 S·O·E Lock은 누적 가능하지만, X Lock이 있으면 추가 Lock은 불가능
- Lock은 너무 일찍 잡거나 오래 유지하면 충돌과 성능 문제를 유발함
  
| Parameter / Mode        | Value        | Meaning |
|-------------------------|-------------|---------|
| mode_<table_name>       | 'S' / 'W'   | **Shared Lock** </br> → 모두 조회 가능, 누구도 수정 불가 </br> → 여러 프로그램에서 추가 Shared Lock 가능 |
|                         | 'O'         | **Optimistic Lock** </br> → 모두 조회/수정 가능 </br> → 실제 DB Update 시에만 나만 수정 가능하도록 E Lock으로 전환 |
|                         | 'E' / 'V'   | **Exclusive Lock (누적)** </br> → 나만 수정 가능, 다른 세션 조회/수정 불가 </br> → 동일 프로그램에서는 추가 Lock 설정 가능 |
|                         | 'X' / 'U'   | **Exclusive Lock (비누적)** </br> → 나만 수정 가능, 다른 세션 조회/수정 불가 </br> → 동일 프로그램에서도 추가 Lock 설정 불가 |
|                         | 'R' / 'C'   | Optimistic(O) Lock을 Exclusive(E) Lock으로 **승격** </br> 또는 승격 가능 여부 체크 |
| <lock_parameter>        | <val>       | Lock Object에 정의된 키 필드 값 </br> (Lock Argument 구성 요소) |
| x_<lock_parameter>      | space       | 해당 Lock Parameter 값 기준으로 Lock 설정 (기본값) |
|                         | 'X'         | 해당 필드 값이 Initial인 모든 레코드에 대해 Lock |
| _scope                  | '1'         | Lock이 현재 프로그램 내에서만 유지 |
|                         | '2'         | Lock을 V1 Update Task로 전달 (기본값) |
|                         | '3'         | 프로그램 + V1 Update Task 모두에서 Lock 유지 |
| _wait                   | space       | 외부 Lock 존재 시 대기 없이 즉시 실패 (기본값) |
|                         | 'X'         | 외부 Lock 존재 시 한 번 더 Lock 시도 |
| _collect                | space       | Lock Container 미사용 </br> 즉시 Lock table에 반영 (기본값) |
|                         | 'X'         | Lock Container 사용 </br> 여러 Lock을 모아두었다가 FLUSH_ENQUEUE로 한 번에 반영 |

</br>

```abap
*************** LOCK 설정 (ENQUEUE) ****************
CALL FUNCTION 'ENQUEUE_ESFLIGHT'
  EXPORTING
    carrid = lv_carrid
    connid = lv_connid
    fldate = lv_fldate
  EXCEPTIONS
    foreign_lock   = 1
    system_failure = 2.

CASE sy-subrc.
  WHEN 0.
    " Lock 설정 성공
  WHEN 1.
    " FOREIGN_LOCK : 다른 세션이 이미 Lock 보유
  WHEN 2.
    " SYSTEM_FAILURE : Lock 서버/시스템 오류
ENDCASE.

*************** LOCK 해제 (DEQUEUE) ****************
CALL FUNCTION 'DEQUEUE_ESFLIGHT'
  EXPORTING
    carrid = lv_carrid
    connid = lv_connid
    fldate = lv_fldate.
```
- 같은 창에서는 이미 Lock을 잡고 있어서 성공하고, 다른 창에서는 해당 Lock이 선점되어 있어 FOREIGN_LOCK으로 실패함
```abap
REPORT ZPROGB03_0034.

*************** LOCK 설정 (ENQUEUE) ****************
CALL FUNCTION 'ENQUEUE_EZ_WORKB03'
 EXPORTING
   MODE_ZDBWORK_B03       = 'E'
   MANDT                  = SY-MANDT
   WORKNO                 = 1
 EXCEPTIONS
   FOREIGN_LOCK           = 1
   SYSTEM_FAILURE         = 2
   OTHERS                 = 3.
IF sy-subrc <> 0.
  WRITE: '실패'.
  ELSE.
    WRITE: '성공'.
ENDIF.

*************** LOCK 해제 (DEQUEUE) ****************
CALL FUNCTION 'DEQUEUE_EZ_WORKB03'
 EXPORTING
   MODE_ZDBWORK_B03       = 'E'
   MANDT                  = SY-MANDT
   WORKNO                 = 1.
* CALL FUNCTION 'DEQUEUE_ALL'. " 모든 락 해제
```
</br>
</br>

- Lock을 걸 대상 테이블(SPFLI)과 어떤 방식으로 잠글지 정하는 화면
- `primary table` : 락을 설정할 테이블
<img width="503" height="220" alt="image" src="https://github.com/user-attachments/assets/d5d730e6-e767-445c-bbaf-8b2248ca9fc7" />
</br>

- 드롭다운 리스트에서 키 값(S, O, E, X 등) 을 함께 표시하도록 하는 옵션
<img width="501" height="261" alt="image" src="https://github.com/user-attachments/assets/056eaeb6-c3e6-4e45-b6ad-f4b03b9a7925" />
</br>
</br>

<img width="484" height="376" alt="image" src="https://github.com/user-attachments/assets/e735aae2-0c76-4f13-875d-69fbc9f1d63a" />
</br>
</br>

- 해당 Lock Object로 자동 생성된 ENQUEUE / DEQUEUE 함수 목록을 확인하는 버튼
<img width="401" height="82" alt="image" src="https://github.com/user-attachments/assets/08595954-e580-4572-8ceb-9b6f861d139d" />
</br>

<img width="375" height="107" alt="image" src="https://github.com/user-attachments/assets/80c173bf-0a89-41ce-bbb6-4760e0c5bdf1" />
</br>
</br>

- `SM12` : 현재 시스템에 설정된 Lock 정보 조회
<img width="467" height="236" alt="image" src="https://github.com/user-attachments/assets/e55af051-0840-4e6f-8561-cabdee10e5b3" />
</br>
</br>
</br>
</br>
</br>

### 5) CALL TRANSACTION MODE·UPDATE 및 호출 방식 요약
- `MODE 'A'` : 모든 화면 표시 (디버깅용)
- `MODE 'N'` : 화면 없이 백그라운드 실행
- `MODE 'E'` : 오류 발생 시에만 화면 표시
- `UPDATE 'S'` : 동기 Update, COMMIT 끝날 때까지 대기
- `UPDATE 'A'` : 비동기 Update, COMMIT 후 바로 진행

| 호출 방식 | Data 공유 | SAP LUW | 언제 사용? |
|----------|-----------|---------|------------|
| CALL FUNCTION<br>CALL METHOD | 분리됨 | 동일 | 같은 LUW 안에서 조회 / 변경 |
| SUBMIT AND RETURN<br>CALL TRANSACTION | 분리됨 | 분리됨 | 다른 LUW에서 조회 / 변경 |
| CALL FUNCTION<br>STARTING NEW TASK | 분리됨 | 분리됨 | 병렬 처리 (Parallel Task) |

```abap
CALL TRANSACTION '<T_CODE>'
  USING <BDC_ITAB>
  MODE   '<A/N/E>'
  UPDATE '<S/A>'.
```
```abap
" 화면 모두 표시
CALL TRANSACTION 'T1'
  USING bdc_itab
  MODE 'A'      " 모든 화면 표시
  UPDATE 'S'.   " 동기 Update (완료까지 대기)

" 화면 없이 실행
CALL TRANSACTION 'T2'
  USING bdc_itab
  MODE 'N'      " 백그라운드 실행
  UPDATE 'A'.   " 비동기 Update (대기 없음)

" 오류 시에만 화면 표시
CALL TRANSACTION 'T3'
  USING bdc_itab
  MODE 'E'      " 오류 발생 시 화면 표시
  UPDATE 'S'.   " 동기 Update
```
</br>
</br>
</br>

---

</br>

## < Number Range (TCODE: `SNRO`) >
- 번호 범위는 `From ~ To` 로 정의되며, 서로 겹칠 수 없음
- Ext 체크 여부로 내부 번호 (시스템 자동 증가) 부여 / 외부 번호 (사용자 입력) 부여를 결정함
- 같은 번호라도 Subobject가 다르면 중복 사용 가능
- 그룹 테이블로 분류값을 지정해, 특정 종류별로 다른 번호 범위를 사용하도록 구성 가능
</br>

- `Number Range Object` 는 이름을 `Z` 또는 `Y` 로 시작해야 함
- `Number Length Domain` 은 필수값이며, 도메인에서 `NUMC` 또는 `CHAR` 타입으로 정의하고 최대 20자리까지 가능
- `% Warning` 은 번호 범위 사용률이 `0.1 ~ 99.9%` 에 도달하면 경고를 주는 기준이며, 보통 10.0으로 설정함
- `No rolling` 은 번호 범위를 다 써도 다시 처음으로 돌아가지 않고 더 이상 번호를 부여하지 않는 설정
- `To business year flag` 는 데이터를 사업연도(연도별)로 구분해서 관리 가능하게 해주는 표시
- `NR Status` 는 현재까지 채번된 번호

<img width="508" height="316" alt="image" src="https://github.com/user-attachments/assets/dbcfea6c-aab7-424f-968d-1c70d07578c4" />
</br>
</br>

```abap
*************** Number Range 정보 조회 ****************
CALL FUNCTION 'NUMBER_GET_INFO'
  EXPORTING
    nr_range_nr = <number_range_number>      " Number Range Interval
    object      = <number_range_object_name> " Number Range Object
    subobject   = <number_range_sub_object>  " Subobject (옵션)
    toyear      = <to_fiscal_year>           " 회계연도 (옵션)
  IMPORTING
    interval    = <interval_info>             " Interval 정보
    NRIV        = <internal_info_table>       " 내부 관리 정보 테이블
  EXCEPTIONS
    interval_not_found = 1
    object_not_found  = 2.

*************** Number Range 다음 번호 채번 ****************
CALL FUNCTION 'NUMBER_GET_NEXT'
  EXPORTING
    nr_range_nr   = <number_range_number>       " Number Range Interval 번호
    object        = <number_range_object_name>  " Number Range Object
    quantity      = <quantity_of_numbers>       " 요청할 번호 개수 (보통 1)
    subobject     = <number_range_sub_object>   " Subobject (옵션)
    toyear        = <to_fiscal_year>             " 회계연도 기준 (옵션)
    ignore_buffer = <ignore_buffer_flag>        " 버퍼 무시 여부
  IMPORTING
    number        = <next_free_number>           " 할당된 다음 번호
    quantity      = <quantity_of_numbers_read>  " 실제 할당된 개수
    returncode    = <return_code>                " 처리 결과 코드
  EXCEPTIONS
    interval_not_found       = 1
    number_range_not_intern  = 2
    object_not_found         = 3
    quantity_is_0            = 4
    quantity_is_not_1        = 5
    interval_overflow        = 6
    buffer_overflow          = 7.

*************** External Number Range 값 검증 ****************
CALL FUNCTION 'NUMBER_CHECK'
  EXPORTING
    nr_range_nr   = <number_range_number>        " Number Range Interval 번호
    number        = <number_to_be_checked>       " 사용자가 입력한 번호
    object        = <number_range_object_name>   " Number Range Object
    subobject     = <number_range_sub_object>    " Subobject (옵션)
    toyear        = <to_fiscal_year>              " 회계연도 기준 (옵션)
    numeric_check = <numeric_check_flag>         " 숫자 여부 체크
  IMPORTING
    returncode    = <return_code>                 " space: 사용 가능 / 'X': 사용 불가
  EXCEPTIONS
    interval_not_found      = 1
    number_range_not_extern = 2
    object_not_found        = 3.
```
</br>
</br>

- 번호 범위를 정해두고 순서대로 번호를 발급하는 과정
<img width="492" height="282" alt="image" src="https://github.com/user-attachments/assets/83103505-1afd-4666-9bf2-7d1bde67045e" />
</br>

<img width="364" height="99" alt="image" src="https://github.com/user-attachments/assets/c187b9e3-1763-4e75-a57e-b5fe3cb53210" />
</br>

<img width="526" height="86" alt="image" src="https://github.com/user-attachments/assets/bcd30086-2172-4876-a8c3-4262f4f100e7" />
</br>
</br>

```abap
REPORT ZPROGB03_0035.

DATA: lv_number TYPE NUMC10.

*************** Number Range 다음 번호 채번 ****************
CALL FUNCTION 'NUMBER_GET_NEXT'
  EXPORTING
    nr_range_nr = 'A1'
    object      = 'ZNUM_B03'
  IMPORTING
    NUMBER      = lv_number
  EXCEPTIONS
    INTERVAL_NOT_FOUND            = 1
    NUMBER_RANGE_NOT_INTERN       = 2
    OBJECT_NOT_FOUND              = 3
    QUANTITY_IS_0                 = 4
    QUANTITY_IS_NOT_1             = 5
    INTERVAL_OVERFLOW             = 6
    BUFFER_OVERFLOW               = 7
    OTHERS      = 8.

IF sy-subrc = 0.
  WRITE: lv_number.
ELSE.
  EXIT.
ENDIF.
```
</br>

- 현재까지 사용된 마지막 번호 확인
<img width="528" height="87" alt="image" src="https://github.com/user-attachments/assets/ee38de26-11bd-4415-9da0-856c7684d883" />
</br>
</br>

- NR Status에서 값을 직접 바꿔서 마지막 사용 번호를 수정
<img width="380" height="111" alt="image" src="https://github.com/user-attachments/assets/c2e42be0-a083-4666-9d3b-050bd211b684" />
</br>

<img width="523" height="90" alt="image" src="https://github.com/user-attachments/assets/c813b8e0-5523-4bf6-9346-99aad5b773d4" />
</br>
</br>

- 수정된 번호 결과 확인
<img width="528" height="88" alt="image" src="https://github.com/user-attachments/assets/0910bf1b-eecd-49b6-b57e-b85958e6d321" />
</br>
</br>
</br>
</br>
</br>
</br>

---

</br>

## < 실습 코드 >
</br>

### 실습 1
</br>

- 문제
- Number Range 실습
</br>

<img width="426" height="235" alt="image" src="https://github.com/user-attachments/assets/a055f4dd-2cc4-4f10-82aa-5d200ce1446f" />
</br>
</br>
</br>

**1) Number Range Object 생성**

<img width="446" height="271" alt="image" src="https://github.com/user-attachments/assets/75d8940f-3d14-4b1d-b942-88a5a586445f" />
</br>
</br>

- NR Status를 29로 설정 -> 30부터 시작이므로
<img width="538" height="87" alt="image" src="https://github.com/user-attachments/assets/9c8e782c-7492-4843-a054-9fb29bce36b5" />
</br>
</br>
</br>

**2) Program 코드 생성**
```abap
REPORT ZBC400_B03_PRACTICE9.

DATA: gv_num TYPE S_BUSPANUM,
      gv_cnt TYPE I VALUE 31,
      gt_data TYPE TABLE OF ZTSCUSTOM_B03.
PARAMETERS: pa_num TYPE I.

DO pa_num TIMES.
  PERFORM number_get_next CHANGING gv_num gv_cnt gt_data.
ENDDO.

INSERT ZTSCUSTOM_B03 FROM TABLE gt_data.

*&---------------------------------------------------------------------*

FORM number_get_next CHANGING gv_num TYPE S_BUSPANUM
                              gv_cnt TYPE I
                              gt_data LIKE gt_data.
  DATA: gs_data TYPE ZTSCUSTOM_B03.

  CALL FUNCTION 'NUMBER_GET_NEXT'
    EXPORTING
      nr_range_nr = '01'
      object      = 'ZNO_B03'
    IMPORTING
      NUMBER      = gv_num
    EXCEPTIONS
      INTERVAL_NOT_FOUND            = 1
      NUMBER_RANGE_NOT_INTERN       = 2
      OBJECT_NOT_FOUND              = 3
      QUANTITY_IS_0                 = 4
      QUANTITY_IS_NOT_1             = 5
      INTERVAL_OVERFLOW             = 6
      BUFFER_OVERFLOW               = 7
      OTHERS      = 8.
  gs_data-id = gv_cnt.
  gs_data-NUM_RANGE = gv_num.
  APPEND gs_data TO gt_data.
  gv_cnt = gv_cnt + 1.

  IF sy-subrc = 0.
    WRITE:/ gv_num.
  ELSE.
    EXIT.
  ENDIF.

ENDFORM.
```
</br>

**3) 결과 확인**
- 20 입력
  
<img width="236" height="273" alt="image" src="https://github.com/user-attachments/assets/51995506-1e91-4bb1-a640-b0126e842e69" />

</br>

<img width="413" height="280" alt="image" src="https://github.com/user-attachments/assets/318d16a4-d30f-4044-a04a-cb31591d0e4e" />
</br>

<img width="486" height="82" alt="image" src="https://github.com/user-attachments/assets/83b8badc-30ce-4078-b88c-9fec0c1c4d63" />

</br>
</br>
</br>
</br>
</br>
</br>

# 01/09
</br>
</br>

## <  핵심 개념 >
- **1) `CALL METHOD go_alv->check_changed_data.` : ALV에 바인딩된 it_outtab 내부테이블의 변경사항을 반영함**
</br>
</br>

---

</br>

## < ALV 셀 단위 편집(Edit) 제어 구현 >
</br>

### 1) ALV 셀 단위 Edit 제어
- 필드카탈로그를 이용해 해당 컬럼을 ALV에서 수정 가능하도록 설정하는 UI 플래그
```abap
gs_fcat-edit = 'X'.
```
- 선택한 ALV 행의 INVOICE 컬럼만 수정 가능하도록, 버튼(EDIT) 클릭 시 셀 단위로 Edit 모드를 켜는 로직
- `cl_gui_alv_grid=>mc_style_enabled` : ALV에서 특정 셀만 수정 가능하게 만드는 셀 스타일 플래그
- `set_ready_for_input` : ALV 그리드를 수정 모드로 켜고/끄는 스위치
```abap
REPORT ZPROGB03_0029.

*************** TOP ****************
DATA: gs_layout TYPE LVC_S_LAYO.
DATA: BEGIN OF gs_data.
        INCLUDE TYPE sbook.
DATA: it_cell_style TYPE LVC_T_STYL,
     END OF gs_data.
DATA gs_cell_style TYPE LVC_S_STYL.

*************** PAI ****************
MODULE user_command_0100 INPUT.
  CASE OK_CODE.
    WHEN 'EDIT'.
      PERFORM set_edit_rows.
  ENDCASE.
ENDMODULE.

*************** F01 ****************
FORM set_edit_rows.
  DATA: lt_index_rows TYPE lvc_t_row,
        ls_index_row TYPE lvc_s_row.

  CALL METHOD go_alv->get_selected_rows
    IMPORTING
      et_index_rows = lt_index_rows.

  IF lt_index_rows IS INITIAL.
    MESSAGE '변경할 데이터를 선택하세요' TYPE 'I'.
    EXIT.
  ENDIF.

  " 기존에 변경모드로 설정되어있던 셀들 초기화
  LOOP AT gt_data INTO gs_data WHERE it_cell_style IS NOT INITIAL.
    DELETE gs_data-it_cell_style WHERE fieldname = 'INVOICE'.
    MODIFY gt_data FROM gs_data TRANSPORTING it_cell_style.
  ENDLOOP.

  " 선택한 Row 기준으로 변경모드 세팅
  LOOP AT lt_index_rows INTO ls_index_row.
    CLEAR: gs_data, gs_cell_style.
    READ TABLE gt_data INTO gs_data INDEX ls_index_row-index.
    IF sy-subrc = 0.
      gs_cell_style-fieldname = 'INVOICE'.
      gs_cell_style-style = cl_gui_alv_grid=>mc_style_enabled.
      INSERT gs_cell_style INTO TABLE gs_data-it_cell_style.
      MODIFY gt_data FROM gs_data INDEX ls_index_row-index
      TRANSPORTING it_cell_style.
    ENDIF.
  ENDLOOP.

  " Edit 활성화
  CALL METHOD go_alv->set_ready_for_input
    EXPORTING i_ready_for_input = 1.

  " ALV Refresh
  CALL METHOD go_alv->refresh_table_display.
ENDFORM.

FORM set_layout.
  gs_layout-stylefname = 'IT_CELL_STYLE'.
ENDFORM.

*************** PBO ****************
CALL METHOD go_alv->set_table_for_first_display
      EXPORTING
        is_layout = gs_layout
      CHANGING
        it_outtab = gt_data.
```
</br>

- 결과: 특정 열 수정 가능
  
<img width="502" height="297" alt="image" src="https://github.com/user-attachments/assets/2a4f9024-0f91-4619-9935-11df9ed4d17b" />
</br>
</br>
</br>
</br>

---

</br>

## < 팀과제 - 실습 코드 >
- 프로그램 코드 : `ZDSBOOK_CL222_01`
- `CALL METHOD go_alv->check_changed_data.` : ALV에 바인딩된 it_outtab 내부테이블의 변경사항을 반영함
</br>
</br>

**1) Report 프로그램 생성**
```abap
REPORT ZDSBOOK_CL222.

INCLUDE ZDSBOOK_CL222_TOP.
INCLUDE ZDSBOOK_CL222_C01.
INCLUDE ZDSBOOK_CL222_F01.
INCLUDE ZDSBOOK_CL222_O01.
INCLUDE ZDSBOOK_CL222_I01.

START-OF-SELECTION.
  PERFORM set_data.
  CALL SCREEN 100.
```
</br>

**2) Screen 100 코드에 서브스크린 생성**
```abap
PROCESS BEFORE OUTPUT.
 MODULE STATUS_0100.
 CALL SUBSCREEN SUB INCLUDING sy-repid '110'.
 MODULE init_alv.
 MODULE CLEAR_OK_CODE.

PROCESS AFTER INPUT.
 MODULE exit AT EXIT-COMMAND.
 CALL SUBSCREEN SUB.
 MODULE USER_COMMAND_0100.
```
</br>

**3) `TOP` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZDSBOOK_CL222_01_TOP
*&---------------------------------------------------------------------*

DATA: go_alv TYPE REF TO cl_gui_alv_grid,
      go_dock TYPE REF TO cl_gui_docking_container.

DATA: BEGIN OF gs_sbook.
        INCLUDE TYPE ZTBOOK_CL222.
DATA: it_cell_style TYPE LVC_T_STYL,
      update_cell TYPE icon-id,
     END OF gs_sbook.
DATA: gt_sbook LIKE TABLE OF gs_sbook.
DATA: gt_data TYPE TABLE OF ZTBOOK_CL222,
      gs_data LIKE LINE OF gt_data.

DATA gs_cell_style TYPE LVC_S_STYL.
DATA save_flag TYPE I.

DATA: OK_CODE TYPE sy-ucomm.
DATA: gs_layout TYPE LVC_S_LAYO.
DATA: gt_fcat TYPE LVC_T_FCAT,
      gs_fcat TYPE LVC_S_FCAT.

SELECTION-SCREEN BEGIN OF SCREEN 110 AS SUBSCREEN.
  SELECT-OPTIONS: pa_car FOR gs_sbook-carrid DEFAULT 'AA',
                  pa_con FOR gs_sbook-connid DEFAULT '17',
                  pa_fld FOR gs_sbook-fldate DEFAULT '20250508'.
SELECTION-SCREEN END OF SCREEN 110.
```
</br>

**3) `C01` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZDSBOOK_CL222_01_C01
*&---------------------------------------------------------------------*

CLASS lcl_event_handler DEFINITION.
  PUBLIC SECTION.
  CLASS-METHODS: on_toolbar FOR EVENT toolbar
    OF cl_gui_alv_grid IMPORTING e_object,
      on_user_command FOR EVENT user_command
    OF cl_gui_alv_grid IMPORTING e_ucomm.
ENDCLASS.

CLASS lcl_event_handler IMPLEMENTATION.
  METHOD on_toolbar.
    DATA ls_button TYPE STB_BUTTON.
    ls_button-butn_type = 3.
    INSERT ls_button INTO TABLE e_object->mt_toolbar.

    CLEAR ls_button.
    ls_button-function = 'UPDATE'.
    ls_button-icon = ICON_EXPAND.
    ls_button-butn_type = 0.
    ls_button-text = 'UPDATE'.
    INSERT ls_button INTO TABLE e_object->mt_toolbar.
  ENDMETHOD.

  METHOD on_user_command.
    CASE e_ucomm.
      WHEN 'UPDATE'.
        DATA: lt_select_data TYPE LVC_T_ROW,
              ls_select_data TYPE LVC_S_ROW.

        CALL METHOD go_alv->get_selected_rows
          IMPORTING
            et_index_rows = lt_select_data.

        READ TABLE gt_sbook TRANSPORTING NO FIELDS
          WITH KEY update_cell = ICON_CHANGE.
        IF sy-subrc = 0.
          MESSAGE '이미 수정중인 셀이 있습니다.' TYPE 'I'.
        ELSE.
          IF lt_select_data IS INITIAL.
            MESSAGE '변경할 데이터를 선택하세요' TYPE 'I'.
          ELSE.
            PERFORM update_data USING lt_select_data ls_select_data.
          ENDIF.
        ENDIF.
      WHEN OTHERS.
    ENDCASE.
  ENDMETHOD.
ENDCLASS.
```
</br>

**4) `F01` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZDSBOOK_CL222_01_F01
*&---------------------------------------------------------------------*

FORM set_data .
* 초기 설정
*  SELECT * from sbook
*    INTO CORRESPONDING FIELDS OF TABLE gt_data
*    WHERE cancelled = 'X'.
*
*  SORT gt_data BY carrid connid fldate.
*  INSERT ztbook_cl222 FROM TABLE gt_data
*    ACCEPTING DUPLICATE KEYS.

  SELECT * from ztbook_cl222
    INTO CORRESPONDING FIELDS OF TABLE gt_sbook
    WHERE carrid IN pa_car
      AND connid IN pa_con
      AND fldate IN pa_fld.
ENDFORM.

*&---------------------------------------------------------------------*

FORM update_data USING lt_select_data TYPE LVC_T_ROW
                       ls_select_data TYPE LVC_S_ROW.
  READ TABLE gt_sbook TRANSPORTING NO FIELDS
       WITH KEY update_cell = ICON_CHANGE.
  IF sy-subrc = 0.
    MESSAGE '이미 수정중인 셀이 있습니다.' TYPE 'I'.
  ELSE.
    save_flag = 1.
    LOOP AT gt_sbook INTO gs_sbook WHERE it_cell_style IS NOT INITIAL.
      DELETE gs_sbook-it_cell_style WHERE fieldname = 'REFUND'.
      MODIFY gt_sbook FROM gs_sbook TRANSPORTING it_cell_style.
    ENDLOOP.

    LOOP AT lt_select_data INTO ls_select_data.
      CLEAR: gs_sbook-it_cell_style, gs_cell_style.
      READ TABLE gt_sbook INTO gs_sbook INDEX ls_select_data-index.
      IF sy-subrc = 0.
        gs_cell_style-fieldname = 'REFUND'.
        gs_cell_style-style = cl_gui_alv_grid=>mc_style_enabled.
        INSERT gs_cell_style INTO TABLE gs_sbook-it_cell_style.

        gs_sbook-update_cell = ICON_CHANGE.

        MODIFY gt_sbook FROM gs_sbook INDEX ls_select_data-index
        TRANSPORTING it_cell_style update_cell.
      ENDIF.
    ENDLOOP.

    CALL METHOD go_alv->set_ready_for_input
      EXPORTING i_ready_for_input = 1.
    CALL METHOD go_alv->refresh_table_display.
  ENDIF.
ENDFORM.

*&---------------------------------------------------------------------*

FORM set_layout .
  gs_layout-sel_mode = 'A'.
  gs_layout-stylefname = 'IT_CELL_STYLE'.
ENDFORM.

*&---------------------------------------------------------------------*

FORM set_fieldcat .
  CLEAR gs_fcat.
  gs_fcat-fieldname = 'REFUND'.
  gs_fcat-coltext = '환불여부'.
  gs_fcat-checkbox = 'X'.
  gs_fcat-col_pos = 2.
  APPEND gs_fcat TO gt_fcat.

  CLEAR gs_fcat.
  gs_fcat-fieldname = 'UPDATE_CELL'.
  gs_fcat-coltext = '수정중'.
  gs_fcat-icon = 'X'.
  gs_fcat-col_pos = 1.
  APPEND gs_fcat TO gt_fcat.
ENDFORM.

*&---------------------------------------------------------------------*

FORM select_data .
  SELECT * from ztbook_cl222
    INTO CORRESPONDING FIELDS OF TABLE gt_sbook
    WHERE carrid IN pa_car
      AND connid IN pa_con
      AND fldate IN pa_fld.
  SORT gt_sbook BY carrid connid fldate.
ENDFORM.

*&---------------------------------------------------------------------*

FORM save_data .
  CALL METHOD go_alv->check_changed_data.

  CLEAR gt_data.
  LOOP AT gt_sbook INTO gs_sbook.
    CLEAR gs_data.
    MOVE-CORRESPONDING gs_sbook TO gs_data.
    APPEND gs_data TO gt_data.
  ENDLOOP.

  UPDATE ztbook_cl222 FROM TABLE gt_data.

  LOOP AT gt_sbook INTO gs_sbook WHERE update_cell = ICON_CHANGE.
    CLEAR gs_sbook-update_cell.
    DELETE gs_sbook-it_cell_style WHERE fieldname = 'REFUND'.

    MODIFY gt_sbook FROM gs_sbook INDEX sy-tabix.
  ENDLOOP.

  CALL METHOD go_alv->refresh_table_display.
  IF sy-subrc = 0.
    MESSAGE '저장되었습니다.' TYPE 'I'.
  ENDIF.
ENDFORM.
```
</br>

**5) `PBO` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZDSBOOK_CL222_01_O01
*&---------------------------------------------------------------------*

MODULE status_0100 OUTPUT.
 SET PF-STATUS 'S100'.
 SET TITLEBAR 'T100'.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE init_alv OUTPUT.
  IF go_dock IS INITIAL.
    CREATE OBJECT go_dock
      EXPORTING
        side = cl_gui_docking_container=>dock_at_bottom
        extension = 400
        repid = sy-repid
        dynnr = sy-dynnr.
    CREATE OBJECT go_alv
      EXPORTING
        i_parent = go_dock.

    PERFORM set_layout.
    PERFORM set_fieldcat.
    SET HANDLER lcl_event_handler=>on_toolbar FOR go_alv.
    SET HANDLER lcl_event_handler=>on_user_command FOR go_alv.
    CALL METHOD go_alv->set_table_for_first_display
      EXPORTING
        is_layout                     = gs_layout
        i_structure_name              = 'ZTBOOK_CL222'
      CHANGING
        it_outtab                     = gt_sbook
        it_fieldcatalog               = gt_fcat
      EXCEPTIONS
        invalid_parameter_combination = 1
        program_error                 = 2
        too_many_lines                = 3
        others                        = 4.

    IF sy-subrc <> 0.
      MESSAGE '데이터 조회 중 오류 발생' TYPE 'E'.
    ENDIF.
  ELSE.
    CALL METHOD go_alv->refresh_table_display
      EXCEPTIONS
        finished       = 1
        others         = 2.
  ENDIF.
ENDMODULE.

*&---------------------------------------------------------------------*

MODULE clear_ok_code OUTPUT.
  CLEAR OK_CODE.
ENDMODULE.
```
</br>

**6) `PAI` 모듈 생성**
```abap
*&---------------------------------------------------------------------*
*& Include          ZDSBOOK_CL222_01_I01
*&---------------------------------------------------------------------*

MODULE user_command_0100 INPUT.
  CASE OK_CODE.
    WHEN 'ENTER' OR ''.
      PERFORM select_data.
    WHEN 'SAVE'.
      PERFORM save_data.
    WHEN 'BACK'.
      LEAVE TO SCREEN 0.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.

*----------------------------------------------------------------------*

MODULE exit INPUT.
  CASE OK_CODE.
    WHEN 'CANCEL'.
      LEAVE TO SCREEN 0.
    WHEN 'EXIT'.
      LEAVE PROGRAM.
    WHEN OTHERS.
  ENDCASE.
ENDMODULE.
```
</br>

**7) 결과 확인**

<img width="512" height="309" alt="image" src="https://github.com/user-attachments/assets/6797cf68-25f3-4baf-a039-5f92b72884aa" />
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>

# 01/13
</br>
</br>

## <  핵심 개념 >
- **1) `PUBLIC SECTION`**
- **2) `PRIVATE SECTION`**
</br>

- **정적(Class) 메서드는 `클래스=>` , 인스턴스(Object) 메서드는 `객체->` 로 접근함**
- **Static Method(CLASS-METHODS) 안에서는 Static 컴포넌트(CLASS-DATA)만 직접 접근 가능**
- **캡슐화된 인스턴스 어트리뷰트 = `PRIVATE SECTION` 에 선언해 외부 직접 접근을 막은 객체 전용 변수**
- **CTS 생성 - `SE09`**
</br>
</br>

---

</br>

## < ABAP 클래스 정의 기본 구조 >
</br>

**1) PUBLIC SECTION (외부 접근 가능)**
- `DATA` : 인스턴스 속성 (객체마다 생성)
- `CLASS-DATA` : 정적 속성 (클래스 1개 공유)
- `METHODS` : 인스턴스 메서드
- `CLASS-METHODS` : 정적 메서드

**2) PRIVATE SECTION (외부 접근 불가)**
- `DATA / CLASS-DATA` : 내부 전용 속성
- `METHODS / CLASS-METHODS` : 내부 전용 메서드
</br>
</br>

### 1) ABAP 클래스 구조와 호출 방식 정리
- 정적 메서드는 클래스 기준, 인스턴스 메서드는 객체 기준으로 호출
```abap
클래스명=>CLASS-METHOD( ).     " 가능 (정적 메서드)
클래스명=>METHOD( ).           " ❌ 오류 (인스턴스 메서드)

참조변수->METHOD( ).           " 가능 (인스턴스 메서드)
참조변수->CLASS-METHOD( ).     " 가능 (정적 메서드, 문법상 허용)
```
- `DATA` 는 객체마다 따로 생기는 변수, `CLASS-DATA` 는 클래스 전체가 하나를 공유하는 변수
- `METHODS` 는 객체(인스턴스) 생성 후 호출, `CLASS-METHODS` 는 객체 없이 클래스명으로 바로 호출
- Static Method(`CLASS-METHODS`) 안에서는 Static 컴포넌트(`CLASS-DATA`)만 직접 접근 가능
- Public 속성은 외부 접근 가능, Private 속성은 내부 전용이며 READ-ONLY는 외부 수정만 제한
```abap
*************** 클래스 정의 (CLASS DEFINITION) ****************
CLASS class_name DEFINITION.
  PUBLIC SECTION.
    " 정적 속성 (Static Attribute)
    " 클래스당 1개만 존재
    CLASS-DATA: gv_n_o_vehicles TYPE i.       " 전체 객체가 공유
  PRIVATE SECTION.
    " 인스턴스 속성 (Instance Attribute)
    " 객체 생성 시마다 개별로 생성
    DATA: variable5 TYPE string READ-ONLY.    " 읽기 전용 - 외부: 조회 가능, 수정 불가
                                                          " 클래스 내부: 둘 다 가능
ENDCLASS.
```
```abap
*************** 메서드 정의 (METHODS Syntax) ****************
CLASS class_name DEFINITION.
  PUBLIC SECTION.
    METHODS method_name
      IMPORTING         iv_par TYPE type_name    " 입력 파라미터
      EXPORTING         ev_par TYPE type_name    " 출력 파라미터
      CHANGING          cv_par TYPE type_name    " 입·출력 파라미터
      RETURNING VALUE(rv_par)  TYPE type_name    " 반환값 (메서드 실행 결과를 단일 값으로 반환)
      EXCEPTIONS  exception.                  " Classic Exception
      RAISING   cx_exception_class.           " Class-based Exception
    CLASS-METHODS static_method.               " 정적 메서드
ENDCLASS.

*************** 메서드 구현 (METHOD IMPLEMENTATION) ****************
CLASS class_name IMPLEMENTATION.
  METHOD method_name.
    " 인스턴스 메서드 로직
  ENDMETHOD.
  METHOD static_method.
    " 정적 메서드 로직
  ENDMETHOD.
ENDCLASS.
```
- 정적 메서드는 객체 생성 없이 호출 가능
```abap
*************** 클래스 정의 ****************
CLASS <class> DEFINITION.
  PUBLIC SECTION.
    METHODS <inst_meth>.
    CLASS-METHODS <static_meth>.
  PRIVATE SECTION.
    DATA mv_attr TYPE <type>.
    CLASS-DATA gv_attr TYPE i.
ENDCLASS.

*************** 클래스 구현 ****************
CLASS <class> IMPLEMENTATION.
  METHOD <inst_meth>. ENDMETHOD.
  METHOD <static_meth>. ENDMETHOD.
ENDCLASS.

*************** 객체 생성 및 호출 ****************
DATA go_obj TYPE REF TO <class>.
CREATE OBJECT go_obj.
CALL METHOD go_obj-><inst_meth>.
CALL METHOD <class>=><static_meth>.
```
```abap
REPORT ZPROGB03_0036.

*************** 클래스 정의 ****************
CLASS lcl_vehicle DEFINITION.
  PUBLIC SECTION.  " 외부에서 접근이 가능
   METHODS: set_attribute IMPORTING iv_make TYPE s_make
                                    iv_mode TYPE s_model,
            display_attributes.
   CLASS-METHODS: display_global_vehicles.
  PRIVATE SECTION. " 외부에서 접근이 불가능
   DATA: mv_make TYPE s_make,
         mv_model TYPE s_model.
   CLASS-DATA: gv_vehicles TYPE I.
ENDCLASS.

*************** 클래스 구현 ****************
CLASS lcl_vehicle IMPLEMENTATION.
  METHOD set_attribute.  " instance Method
    mv_make = iv_make.
    mv_model = iv_mode.
    gv_vehicles = gv_vehicles + 1.
  ENDMETHOD.

  METHOD display_attributes. " instance Method
    WRITE:/ 'Make: ', mv_make,
          / 'Model: ', mv_model.
  ENDMETHOD.

  METHOD display_global_vehicles.  " Static Method
    WRITE:/ 'Number of vehicle: ', gv_vehicles.
  ENDMETHOD.
ENDCLASS.
```
</br>
</br>

### 2) ABAP 객체 참조 정리
- 참조 대입(=)은 객체를 복사하지 않고 같은 객체를 함께 가리킴
- `go_vehicle1` , `go_vehicle2` → 동일 객체, `go_vehicle3` → 별도 객체
- 같은 객체를 참조하므로 `go_vehicle1` 으로 변경한 내용은 `go_vehicle2` 에서도 그대로 보임
```abap
*************** 객체 참조 (Reference) ****************
DATA: go_vehicle1 TYPE REF TO lcl_vehicle,
      go_vehicle2 LIKE go_vehicle1,
      go_vehicle3 LIKE go_vehicle1.

CREATE OBJECT go_vehicle1.
go_vehicle2 = go_vehicle1.    " 같은 객체를 참조 (참조 복사)
CREATE OBJECT go_vehicle3.    " 새로운 객체 생성

" go_vehicle1, go_vehicle2 → 동일 객체
" go_vehicle3             → 별도 객체
```
</br>
</br>

### 3) ABAP 객체 참조 테이블 (TABLE OF REF) 사용 패턴
- `TABLE OF REF TO` 는 객체 자체를 테이블에 저장하는 것이 아니라, 객체를 가리키는 참조(주소) 를 저장함
- 실제 데이터는 객체 안에 있고, 테이블에는 그 객체로 가는 포인터만 존재
```abap
*************** 객체 참조 테이블 (Multiple Instantiation) ****************
DATA:
  go_obj   TYPE REF TO <class>,                 " 단일 객체 참조
  gt_objs  TYPE TABLE OF REF TO <class>.        " 객체 참조를 담는 내부테이블

CREATE OBJECT go_obj.
APPEND go_obj TO gt_objs.    " 첫 번째 객체 참조 저장

CREATE OBJECT go_obj.
APPEND go_obj TO gt_objs.    " 두 번째 객체 참조 저장

*************** 객체 참조 테이블 접근 ****************
gt_objs[ 1 ]-><inst_meth>( ).    " 1번째 객체의 인스턴스 메서드 호출
gt_objs[ 2 ]-><static_meth>( ).  " 정적 메서드 호출 (클래스 공용)
```
```abap
REPORT ZPROGB03_0036.
START-OF-SELECTION.

*************** 객체 참조 변수 선언 ****************
 DATA: go_vehicle TYPE REF TO lcl_vehicle.
* DATA: go_vehicle2 TYPE REF TO lcl_vehicle.
 DATA: gt_vehicle TYPE TABLE OF REF TO lcl_vehicle.

*************** 객체 생성 및 설정 ****************
 CREATE OBJECT go_vehicle.
 CALL METHOD go_vehicle->set_attribute
  EXPORTING iv_make = 'MK1'
            iv_mode = 'MODEL1'.
 APPEND go_vehicle TO gt_vehicle.

 CREATE OBJECT go_vehicle.
 CALL METHOD go_vehicle->set_attribute
  EXPORTING iv_make = 'MK2'
            iv_mode = 'MODEL2'.
 APPEND go_vehicle TO gt_vehicle.

*************** 객체 참조 테이블을 통한 메서드 호출 ****************
* CALL METHOD go_vehicle1->display_attributes.
* CALL METHOD go_vehicle2->display_attributes.
* CALL METHOD go_vehicle1->display_global_vehicles.
 gt_vehicle[ 1 ]->display_attributes( ).
 gt_vehicle[ 2 ]->display_attributes( ).
 gt_vehicle[ 2 ]->display_global_vehicles( ).
```
</br>
</br>

### 4) ABAP 최신 메서드 호출 및 Static/Instance 메서드 호출 정리
- 최신 메서드 호출은 `객체->메서드( )` 형식을 사용
```abap
*************** 메서드 호출 (Method Call) ****************
DATA go_obj TYPE REF TO <class>.

CREATE OBJECT go_obj.
<ref_obj>-><method_name>(
  EXPORTING
    <iv_par1> = <value1>
    <iv_par2> = <value2>
).

*************** 정적 메서드 호출 (Static Method Call) ****************
<class_name>=><static_method>( ).
```
- 정적(Class) 메서드는 `클래스=>` , 인스턴스(Object) 메서드는 `객체->` 로 접근함
```abap
REPORT ZPROGB03_0036.

*************** 클래스 정의 ****************
CLASS lcl_vehicle DEFINITION.
  PUBLIC SECTION.                 " 외부 접근 가능
    DATA: gv_data(2) TYPE c VALUE 'OK'.        " 인스턴스 속성
    CLASS-DATA: gv_cdata(2) TYPE c VALUE 'HI'. " 정적 속성
ENDCLASS.

START-OF-SELECTION.

*************** 객체 참조 변수 선언 ****************
DATA: go_vehicle TYPE REF TO lcl_vehicle.
DATA: gt_vehicle TYPE TABLE OF REF TO lcl_vehicle.

*************** 객체 생성 및 설정 ****************
CREATE OBJECT go_vehicle.
go_vehicle->set_attribute(
  EXPORTING
    iv_make = 'MK1'
    iv_mode = 'MODEL1'
).
APPEND go_vehicle TO gt_vehicle.

CREATE OBJECT go_vehicle.
go_vehicle->set_attribute(
  EXPORTING
    iv_make = 'MK2'
    iv_mode = 'MODEL2'
).
APPEND go_vehicle TO gt_vehicle.

*************** 정적 메서드 호출 ****************
lcl_vehicle=>display_global_vehicles( ).   " 정석 호출
* gt_vehicle[ 1 ]->display_global_vehicles( ). " 문법상 가능 (비권장)

*************** 데이터 접근 방식 비교 ****************
WRITE: / gt_vehicle[ 1 ]->gv_cdata,     " 객체 통해 정적 데이터 접근
       / lcl_vehicle=>gv_cdata,         " 클래스 통해 정적 데이터 접근 (정석)
       / go_vehicle->gv_data,           " 인스턴스 데이터
       / go_vehicle->gv_cdata.          " 정적 데이터 (객체 통해 접근 가능)
```
</br>
</br>

### 5) Functional Method (함수형 메서드)
- RETURNING 파라미터를 정확히 1개만 가지는 메서드 (함수처럼 동작)
- 대입문, 조건문, 계산식 안에서 바로 호출 가능
```abap
*************** Functional Method 정의 ****************
CLASS <class_name> DEFINITION.
  PUBLIC SECTION.
    METHODS <func_method>
      IMPORTING
        iv_par TYPE <type>
      RETURNING
        VALUE(rv_result) TYPE <return_type>.
ENDCLASS.

*************** 인스턴스 함수형 메서드 ****************
result = <ref_obj>-><func_method>(
  iv_par_1 = val_1
  iv_par_n = val_n
).

<ref_obj>-><func_method>(
  EXPORTING
    iv_par_1 = <value1>
    iv_par_n = <valueN>
  RECEIVING
    rv_result = <result>
).

*************** 정적 함수형 메서드 ****************
result = <class_name>=><func_method>(
  iv_par_1 = val_1
  iv_par_n = val_n
).

<class_name>=><func_method>(
  EXPORTING
    iv_par_1 = <value1>
    iv_par_n = <valueN>
  RECEIVING
    rv_result = <result>
).
```
```abap
REPORT ZPROGB03_0036.

*************** Static Functional Method 정의 ****************
CLASS lcl_vehicle DEFINITION.
  PUBLIC SECTION.  " 외부에서 접근이 가능
   CLASS-METHODS: add_vehicles IMPORTING lv_num TYPE I
                               RETURNING VALUE(rv_veh) TYPE I.
ENDCLASS.

*************** 정적 함수형 메서드 ****************
START-OF-SELECTION.
 DATA: gv_vehicle TYPE i. " 리턴값 받을 변수

 gv_vehicle = lcl_vehicle=>add_vehicles( EXPORTING lv_num = 100 ).
* lcl_vehicle=>add_vehicles( EXPORTING lv_num = 100            위랑 같은 코드
*                            RECEIVING rv_veh = gv_vehicle ).
 WRITE:/ gv_vehicle.
```
</br>
</br>

---

</br>

## < 실습 코드 >
</br>

### 실습 1
- local class 만들기 실습
```abap
REPORT ZBC401_03_MAIN.
TYPE-POOLS icon.

CLASS lcl_airplane DEFINITION.
  PUBLIC SECTION.
    METHODS: set_attributes IMPORTING iv_name TYPE string
                                      iv_planetype TYPE saplane-planetype,
             display_attributes.
    CLASS-METHODS: display_gv_n_o_airplanes.
  PRIVATE SECTION.
    CONSTANTS: c_pos_l TYPE I VALUE 30.
    DATA: mv_name TYPE string,
          mv_planetype TYPE saplane-planetype.
    CLASS-DATA: gv_n_o_airplanes TYPE I.
ENDCLASS.

CLASS lcl_airplane IMPLEMENTATION.
  METHOD set_attributes.
    mv_name = iv_name.
    mv_planetype = iv_planetype.
    gv_n_o_airplanes = gv_n_o_airplanes + 1.
  ENDMETHOD.

  METHOD display_attributes.
    WRITE:/ icon_ws_plane AS ICON,
          / 'Name: ', AT c_pos_l mv_name,
          / 'Planetype: ', AT c_pos_l mv_planetype.
  ENDMETHOD.

  METHOD display_gv_n_o_airplanes.
    WRITE:/ 'Number of airplane: ', gv_n_o_airplanes.
  ENDMETHOD.
ENDCLASS.

START-OF-SELECTION.
  DATA: go_airplane TYPE REF TO lcl_airplane,
        gt_airplane TYPE TABLE OF REF TO lcl_airplane.

  CREATE OBJECT go_airplane.
  APPEND go_airplane TO gt_airplane.
```
</br>
</br>

### 실습 2
</br>

- 문제
- 캡슐화된 인스턴스 어트리뷰트 = `PRIVATE SECTION` 에 선언해 외부 직접 접근을 막은 객체 전용 변수
</br>

<img width="379" height="196" alt="image" src="https://github.com/user-attachments/assets/82d06abd-b1ed-47cf-8641-827addf4b214" />

</br>
</br>

```abap
REPORT ZBC401_03_MAIN.

TYPE-POOLS icon.

CLASS lcl_airplane DEFINITION.
  PUBLIC SECTION.
    METHODS: set_attributes IMPORTING iv_name TYPE string
                                      iv_planetype TYPE saplane-planetype,
             display_attributes.
    CLASS-METHODS: display_gv_n_o_airplanes,
                   get_n_o_airpalnes RETURNING VALUE(rv_result) TYPE I.
  PRIVATE SECTION.
    CONSTANTS: c_pos_l TYPE I VALUE 30.
    DATA: mv_name TYPE string,
          mv_planetype TYPE saplane-planetype.
    CLASS-DATA: gv_n_o_airplanes TYPE I.
ENDCLASS.

CLASS lcl_airplane IMPLEMENTATION.
  METHOD set_attributes.
    mv_name = iv_name.
    mv_planetype = iv_planetype.
    gv_n_o_airplanes = gv_n_o_airplanes + 1.
  ENDMETHOD.

  METHOD display_attributes.
    WRITE:/ icon_ws_plane AS ICON,
          / 'Name: ', AT c_pos_l mv_name,
          / 'Planetype: ', AT c_pos_l mv_planetype.
  ENDMETHOD.

  METHOD display_gv_n_o_airplanes.
    WRITE:/ 'Number of airplane: ', gv_n_o_airplanes.
  ENDMETHOD.

  METHOD get_n_o_airpalnes.
    rv_result = gv_n_o_airplanes.
  ENDMETHOD.
ENDCLASS.

START-OF-SELECTION.
  DATA: go_airplane TYPE REF TO lcl_airplane,
        gt_airplane TYPE TABLE OF REF TO lcl_airplane,
        gv_cnt TYPE I.

  lcl_airplane=>display_gv_n_o_airplanes( ).
  CREATE OBJECT go_airplane.
  APPEND go_airplane TO gt_airplane.
  go_airplane->set_attributes(
    EXPORTING iv_name = '이름1'
              iv_planetype = '747-400'
  ).

  CREATE OBJECT go_airplane.
  APPEND go_airplane TO gt_airplane.
  go_airplane->set_attributes(
    EXPORTING iv_name = '이름2'
              iv_planetype = '146-200'
  ).

  CREATE OBJECT go_airplane.
  APPEND go_airplane TO gt_airplane.
  go_airplane->set_attributes(
    EXPORTING iv_name = '이름3'
              iv_planetype = '777-300'
  ).
  gt_airplane[ 1 ]->display_gv_n_o_airplanes( ).

  LOOP AT gt_airplane INTO go_airplane.
    go_airplane->display_attributes( ).
  ENDLOOP.
  lcl_airplane=>get_n_o_airpalnes( RECEIVING rv_result = gv_cnt ).
  WRITE:/ 'Number of airplane: ', gv_cnt.
```
</br>

- 결과 확인
<img width="288" height="256" alt="image" src="https://github.com/user-attachments/assets/6bb72263-072a-45b6-ac5d-a586f8f9d355" />
</br>
</br>
</br>
</br>
</br>
</br>

---

</br>

# 01/30
</br>

## <  핵심 개념 >
- **1) `FIELD-SYMBOLS`**
- **2) `FIELD-SYMBOL CASTING` (타입 캐스팅)**
- **3) `Dynamic ASSIGN` 을 이용한 데이터·구조·속성 접근 방식**
- **4) New Open SQL 인라인 선언 형식 (`@DATA` 사용)**
- **5) 동적 Field Catalog 설정 (`FIELD-SYMBOL` 활용)**
- **6) 엑셀 업로드 표준 형식 (row/col 기반 내부테이블 구성)**
- **7) Simple Tree 생성 및 노드 구성**
</br>
</br>

---

</br>

## < FIELD-SYMBOLS >
</br>

### 1) FIELD-SYMBOLS & ASSIGN
- 변수 값을 복사하지 않고, 메모리를 직접 가리켜서 공유·수정하는 방식 (`< >` 으로 표시)
- 한쪽 변경 시 원본도 즉시 변경
- `FIELD-SYMBOL` → 변수 값을 복사 ❌, 메모리 주소를 직접 참조 ⭕
- `ASSIGN` → 특정 변수/테이블 라인을 필드심볼에 연결
```abap
FIELD-SYMBOLS <fs>.                      " TYPE ANY와 동일 → 어떤 타입이든 참조 가능 (제네릭)
FIELD-SYMBOLS:
  <fs_all>    TYPE ANY,                  " 모든 타입 참조 가능 (구조/단순/테이블 라인 등)
  <fs_data>   TYPE SIMPLE,               " 문자·숫자 등 단순 타입만 참조 가능 (WRITE/계산용)
  <fs_flight> TYPE SFLIGHT,              " SFLIGHT 구조 전용 → 필드 접근 가능 (<fs_flight>-carrid)
  <fs_tab>    TYPE ANY TABLE.            " 내부 테이블 전용 참조 → 테이블 자체를 가리킴
```
```abap
*************** LOOP ASSIGNING 방식 ****************
CLASS-METHODS <write_any_table>
  IMPORTING
    <ig_info> TYPE SIMPLE
    <it_data> TYPE ANY TABLE.

METHOD <write_any_table>.
  FIELD-SYMBOLS <ls_line> TYPE ANY.

  LOOP AT <it_data> ASSIGNING <ls_line>.
    ...
  ENDLOOP.

  WRITE / <ig_info>.
ENDMETHOD.


*************** DIRECT ASSIGN 방식 ****************
DATA: <gt_scarr>      TYPE TABLE OF <scarr>,
      <gt_sbook>      TYPE TABLE OF <sbook>,
      <gv_table_name> TYPE string.

FIELD-SYMBOLS <fs_tab> TYPE ANY TABLE.

CASE <gv_table_name>.
  WHEN 'SCARR'.
    ASSIGN <gt_scarr> TO <fs_tab>.
  WHEN 'SBOOK'.
    ASSIGN <gt_sbook> TO <fs_tab>.
ENDCASE.

IF <fs_tab> IS ASSIGNED.
  SELECT * FROM (<gv_table_name>)
    UP TO 100 ROWS
    INTO TABLE <fs_tab>.
ENDIF.
```
```abap
REPORT ZPROGB03_0038.

*************** DIRECT ASSIGN 방식 ****************
* Field Symbols 선언문
FIELD-SYMBOLS <fs>. " TYPE ANY와 동일함
FIELD-SYMBOLS: <fs_all> TYPE ANY,
               <fs_data> TYPE SIMPLE,
               <fs_flight> TYPE SFLIGHT,
               <fs_tab> TYPE ANY TABLE.

* Assign 특정 변수와 연결하기
* Assign 하면 변수의 메모리 주소를 바라보게 됨

DATA: lv_text(10) TYPE C VALUE 'Hello'.

ASSIGN lv_text TO <fs>.
" IS ASSIGNED 구문 말고도, sy-subrc 로 확인 가능
" ASSIGN 구문 성공 시 0, 실패 시 4 가 들어옴
IF <fs> IS ASSIGNED.
  <fs> = 'Symbols~~'. " 직접 변경 가능
  WRITE: <fs>.
ENDIF.

*************** LOOP ASSIGNING 방식 ****************
*FIELD-SYMBOLS <gs_flight> TYPE sflight.
DATA: gt_flight TYPE TABLE OF sflight.

SELECT MANDT CARRID CONNID FLDATE
  FROM SFLIGHT
  INTO TABLE gt_flight
  WHERE CARRID EQ 'AA'
    AND CONNID EQ '17'.

*LOOP AT gt_flight ASSIGNING <gs_flight>.
LOOP AT gt_flight ASSIGNING FIELD-SYMBOL(<gs_flight>).
  <gs_flight>-connid = '20'.
  WRITE:/ <gs_flight>-carrid,
          <gs_flight>-connid,
          <gs_flight>-fldate.
ENDLOOP.
cl_demo_output=>display( gt_flight ).
```
</br>
</br>

### 2) FIELD-SYMBOL CASTING (타입 캐스팅)
- `CASTING` → 값을 바꾸지 않고, 같은 메모리를 다른 타입 구조로 해석하는 것
- 값 변환 ❌ / 해석 방식만 변경
- FIELD-SYMBOL에 연결할 때 타입을 암시적/명시적으로 지정 가능
```abap
*************** 타입 정의 ****************
TYPES: BEGIN OF <gty_s_date>,
         year  TYPE n LENGTH 4,
         month TYPE n LENGTH 2,
         day   TYPE n LENGTH 2,
       END OF <gty_s_date>.

*************** 암시적 CASTING ****************
FIELD-SYMBOLS <fs_date> TYPE <gty_s_date>.

ASSIGN sy-datum TO <fs_date> CASTING.
WRITE: / <fs_date>-year,
       / <fs_date>-month,
       / <fs_date>-day.

*************** 명시적 CASTING ****************
FIELD-SYMBOLS <fs_any> TYPE ANY.

ASSIGN sy-datum TO <fs_any> CASTING TYPE <gty_s_date>.
WRITE: / <fs_any>-year,
       / <fs_any>-month,
       / <fs_any>-day.
```
```abap
REPORT ZPROGB03_0038.

*************** CASTING (날짜 → 구조 해석) ****************
TYPES: BEGIN OF ty_date,
        year TYPE N LENGTH 4,
        month TYPE N LENGTH 2,
        dat TYPE N LENGTH 2,
       END OF ty_date.
FIELD-SYMBOLS <fs> TYPE ty_date.
DATA: gv_date TYPE D.
gv_date = sy-datum.

ASSIGN gv_date TO <fs> CASTING.
<fs>-year = 2023.

WRITE:/ '시스템 날짜: ', sy-datum,
      / 'gs_date: ', gv_date.

*************** CASTING (문자열 → 구조 해석) ****************
TYPES: BEGIN OF ty_user,
        id(5) TYPE C,
        name(10) TYPE C,
       END OF ty_user.
DATA: gv_data(20) TYPE C VALUE 'C0001HONGGILD'.
FIELD-SYMBOLS <fs_user> TYPE ANY.

ASSIGN gv_data TO <fs_user> CASTING TYPE ty_user.
WRITE: gv_data.
```
</br>
</br>

### 3) Dynamic ASSIGN을 이용한 데이터·구조·속성 접근 방식
- `ASSIGN (변수)` 는 문자열로 된 이름을 실제 데이터 객체로 해석해 필드심볼`(<fs>)` 에 연결
- Structure 필드는 전체 이름 / 필드명 / 위치 번호로 접근할 수 있음
```abap
*************** Any Data Object (일반 변수) ****************
gv_name = 'GV_CARRID'.        " 변수명 문자열 (대문자)
ASSIGN (gv_name) TO <fs>.     " gv_carrid 변수에 동적 연결

*************** Structure Component (스트럭처 필드) ****************
gv_name = 'GS_SPFLI-CARRID'.  " 구조명-필드명
ASSIGN (gv_name) TO <fs>.     " 구조 필드에 동적 접근

*************** Static Attribute (클래스 정적 속성) ****************
gv_name = 'LCL_VEHICLE=>N_O_AIRPLANES'.
ASSIGN (gv_name) TO <fs>.

*************** Instance Attribute (객체 인스턴스 속성) ****************
gv_name = 'LO_VEHICLE->N_O_AIRPLANES'.
ASSIGN (gv_name) TO <fs>.

*************** Structure Component (필드명만 사용) ****************
gv_comp_name = 'CARRID'.
ASSIGN COMPONENT gv_comp_name
  OF STRUCTURE gs_spfli TO <fs>.

*************** Structure Component (위치 번호 사용) ****************
gv_comp_number = 2.
ASSIGN COMPONENT gv_comp_number
  OF STRUCTURE gs_spfli TO <fs>.
```
</br>
</br>

### 4) New Open SQL 인라인 선언 형식 (@DATA 사용)
- `DATA(변수)` → SELECT 문 안에서 변수 즉시 선언(인라인 선언)
- `@` → DB 컬럼이 아니라, ABAP 변수라는 걸 알려주기 위해 붙임
- `UNASSIGN` → 필드심볼이 가리키던 메모리 참조를 해제
```abap
SELECT SINGLE *
  FROM <DB_TABLE>
  INTO @DATA(<ABAP_VARIABLE>)   " @ : ABAP 변수 표시 / DATA() : 즉시 선언 형식
  WHERE <DB_FIELD> = <VALUE>
    AND <DB_FIELD> = <VALUE>.
```
```abap
REPORT ZPROGB03_0038.

*************** New Open SQL (@DATA 인라인 선언) ****************
FIELD-SYMBOLS <fs> TYPE SIMPLE.

SELECT SINGLE *
  FROM spfli
  INTO @DATA(gs_spfli)     
  WHERE carrid = 'AA'
    AND connid = '17'.

*************** Structure Component 순차 접근 (위치 기반) ****************
DO.
  " gs_spfli 스트럭처의 각 Component 위치를 sy-index로 접근해서
  " Field symbol과 연결함
  ASSIGN COMPONENT sy-index OF STRUCTURE gs_spfli TO <fs>.
  IF sy-subrc <> 0. " 만약 ASSIGN에 성공하면 0이 들어옴
    EXIT.
  ENDIF.
  IF <fs> IS ASSIGNED.
    WRITE: <fs>.
    UNASSIGN <fs>. " <fs> 연결 해제
  ENDIF.

  IF <fs> IS NOT ASSIGNED. " UNASSIGN 하고 나서는 OK
  ENDIF.
ENDDO.
```
</br>
</br>

### 5) 동적 Field Catalog 설정 (FIELD-SYMBOL 활용)
- 필드 이름을 문자로 넘겨서, ALV 컬럼 속성을 하나씩 설정하는 방식
- S로 시작하고 E로 끝내며, FIELD-SYMBOL로 바로 값을 넣어 컬럼을 완성
```abap
*************** 동적 Field Catalog 설정 ****************
FORM <set_fieldcat> USING <pv_type>  TYPE c
                           <pv_fname> TYPE any
                           <pv_value> TYPE any.
  FIELD-SYMBOLS <fs> TYPE any.

  IF <pv_type> = 'S'.          " Start
    CLEAR <gs_fcat>.
  ENDIF.

  ASSIGN <gs_fcat>-(<pv_fname>) TO <fs>.   " 필드명 문자열로 동적 접근
  <fs> = <pv_value>.                       " 값 설정

  IF <pv_type> = 'E'.          " End
    APPEND <gs_fcat> TO <gt_fcat>.
  ENDIF.
ENDFORM.


*************** Field Catalog 설정 호출 ****************
PERFORM <set_fieldcat> USING:
  'S'  <FIELDNAME>  <VALUE>,
  ' '  <FIELDNAME>  <VALUE>,
  'E'  <FIELDNAME>  <VALUE>.
```
```abap
REPORT ZPROGB03_0029.

*************** 동적 Field Catalog 설정 ****************
FORM set_fieldcat USING pv_type TYPE C
                        pv_fname TYPE ANY
                        pv_value TYPE ANY.
  FIELD-SYMBOLS <fs> TYPE ANY.
  
  IF pv_type = 'S'. "Start
    CLEAR gs_fcat.
  ENDIF.
  
  ASSIGN gs_fcat-(pv_fname) TO <fs>.
  <fs> = pv_value.
  
  IF pv_type = 'E'. "End
    APPEND gs_fcat TO gt_fcat.
  ENDIF.
ENDFORM.

*************** Field Catalog 설정 호출 ****************
PERFORM set_fieldcat USING:
    'S'  'FIELDNAME'  'CANCELLED_ICON',
    ' '  'ICON'       'X',
    'E'  'COLTEXT'    'Cancelled',
    'S'  'FIELDNAME'  'CANCELLED',
    'E'  'NO_OUT'     'X',
    'S'  'FIELDNAME'  'PASSFORM',
    'E'  'NO_OUT'     'X',
    'S'  'FIELDNAME'  'PASSBIRTH',
    'E'  'NO_OUT'     'X',
    'S'  'FIELDNAME'  'PHONE',
    ' '  'REF_FIELD'  'TELEPHONE',
    ' '  'REF_TABLE'  'SCUSTOM',
    ' '  'COL_POS'    4,
    'E'  'HOTSPOT'    'X',
    'S'  'FIELDNAME'  'SMOKER',
    'E'  'CHECKBOX'   'X',
    'S'  'FIELDNAME'  'INVOICE',
    'E'  'CHECKBOX'   'X',
    'S'  'FIELDNAME'  'CLASS',
    'E'  'EMPHASIZE'  'C510',
    'S'  'FIELDNAME'  'LOCCURAM',
    'E'  'COL_POS'    6,
    'S'  'FIELDNAME'  'DISPLAY_BOOKINGS',
    ' '  'COLTEXT'    'Display Detail',
    'E'  'COL_POS'    3
    .
```
</br>
</br>

---

</br>

## < 엑셀 업로드 표준 형식 (row/col 기반 내부테이블 구성) >
- 엑셀 파일을 선택해 row/col 구조의 임시 테이블로 읽어오는 형식
- col 값으로 필드에 매핑하고, `AT END OF row` 에서 한 행을 완성해 결과 테이블에 추가하는 패턴
</br>

- `cl_gui_frontend_services=>file_open_dialog` : PC에서 파일 선택 창을 띄워서 사용자가 고른 파일 경로를 가져오는 메서드
- `CALL FUNCTION 'ALSM_EXCEL_TO_INTERNAL_TABLE'` : 엑셀 파일을 읽어서 셀 단위(row/col) 내부테이블로 변환해주는 표준 함수
```abap
*************** 파일 선택 파라미터 ****************
PARAMETERS <파일경로> TYPE localfile.

*************** 파일 선택 다이얼로그 ****************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR <파일경로>.
  cl_gui_frontend_services=>file_open_dialog(
    EXPORTING
      file_filter = <파일필터>
    CHANGING
      file_table  = <선택파일목록>
      rc          = <리턴코드>
  ).
  READ TABLE <선택파일목록> INTO <파일경로> INDEX 1.

*************** 엑셀 데이터 임시 테이블 ****************
DATA <엑셀원본테이블> TYPE TABLE OF alsmex_tabline.

*************** 엑셀 → 내부테이블 변환 ****************
CALL FUNCTION 'ALSM_EXCEL_TO_INTERNAL_TABLE'
  EXPORTING
    filename    = <파일경로>
    i_begin_col = <시작컬럼>
    i_begin_row = <시작행>
    i_end_col   = <종료컬럼>
    i_end_row   = <종료행>
  TABLES
    intern      = <엑셀원본테이블>.

*************** 엑셀 데이터 가공 (row/col 핵심 로직) ****************
SORT <엑셀원본테이블> BY row col.

LOOP AT <엑셀원본테이블> INTO <엑셀한셀>.
  CASE <엑셀한셀>-col.
    WHEN <컬럼번호>.
      <결과한행>-<필드명> = <엑셀한셀>-value.
  ENDCASE.

  AT END OF row.        " 같은 행(row)의 마지막 컬럼일 때
    APPEND <결과한행> TO <결과테이블>.
    CLEAR <결과한행>.
  ENDAT.
ENDLOOP.
```
```abap
REPORT ZPROGB03_0039.

*************** 파라미터 및 데이터 선언 ****************
PARAMETERS pa_file TYPE localfile.           " 엑셀업로드를 위한 파일업로드 타입의 파라미터 선언

TYPES BEGIN OF ts_data.
  TYPES: a_field(20),
         b_field(20),
         c_field(20).
TYPES END OF ts_data.

DATA: gt_filename   TYPE filetable,          " 선택한 파일 목록
      gv_rc         TYPE i,                  " 파일 선택 결과 코드
      gt_excel_data TYPE TABLE OF alsmex_tabline. " 엑셀 원본(row/col) 데이터
DATA: gt_itab TYPE TABLE OF ts_data,          " 결과 내부테이블
      gs_itab TYPE ts_data.                   " 결과 한 행
FIELD-SYMBOLS: <fs>.                          " 동적 필드 매핑용
CONSTANTS gc_filters TYPE string VALUE
  'EXCEL FILES (*.XLSX)|*.XLSX|EXCEL FILES (*.XLS)|*.XLS|'.

*************** 파일 선택 다이얼로그 ****************
AT SELECTION-SCREEN ON VALUE-REQUEST FOR pa_file.    " pa_file 입력칸에서 F4(값 도움) 눌렀을 때 실행됨
  cl_gui_frontend_services=>file_open_dialog(
    EXPORTING
      window_title     = '파일찾기'    " 파일 선택 창 상단에 표시될 제목
      default_filename = space         " 기본으로 입력되어 있을 파일명 (없으면 공백)
      file_filter      = gc_filters    " 선택 가능한 파일 확장자 제한 (엑셀만 보이게)
      initial_directory= 'C:'          " 파일 선택 창이 처음 열릴 경로
    CHANGING
      file_table       = gt_filename   " 사용자가 선택한 파일 목록이 담기는 내부테이블
      rc               = gv_rc         " 선택 결과
                                        "  > 0 : 선택한 파일 개수
                                        "  -1  : 오류 발생
  ).
  IF sy-subrc = 0.
    READ TABLE gt_filename INTO pa_file INDEX 1. " 선택 파일 중 첫 번째 사용
  ENDIF.

*************** 엑셀 업로드 및 데이터 가공 ****************
START-OF-SELECTION.
  IF pa_file IS NOT INITIAL.
    CALL FUNCTION 'ALSM_EXCEL_TO_INTERNAL_TABLE'
      EXPORTING
        filename    = pa_file   " 사용자가 선택한 엑셀 파일 전체 경로
        i_begin_col = 1         " 엑셀에서 읽기 시작할 컬럼 번호
        i_begin_row = 2         " 엑셀에서 읽기 시작할 행 번호 (보통 헤더 제외)
        i_end_col   = 3         " 엑셀에서 읽을 마지막 컬럼 번호
        i_end_row   = 100       " 엑셀에서 읽을 마지막 행 번호 (2~100행)
      TABLES
        intern      = gt_excel_data. " 엑셀을 row/col 단위로 담는 임시 내부테이블

    IF sy-subrc = 0.
      SORT gt_excel_data BY row col.
      LOOP AT gt_excel_data INTO DATA(gs_excel_data).
*        CASE gs_excel_data-col.
*          WHEN '1'.
*            gs_itab-a_field = gs_excel_data-value.
*          WHEN '2'.
*            gs_itab-b_field = gs_excel_data-value.
*          WHEN '3'.
*            gs_itab-c_field = gs_excel_data-value.
*          WHEN OTHERS.
*        ENDCASE.

" 필드 심볼 이용
        UNASSIGN <fs>. "CLEAR와 비슷하게 필드심볼 재사용 시 연결 해제
        ASSIGN COMPONENT gs_excel_data-col OF STRUCTURE gs_itab TO <fs>.
        <fs> = gs_excel_data-value.

        AT END OF row. " row 값이 변경되기 전 마지막에 반영
          APPEND gs_itab TO gt_itab.
          CLEAR gs_itab.
        ENDAT.
      ENDLOOP.
      cl_demo_output=>display( gt_itab ).
    ENDIF.
  ENDIF.
```
</br>
</br>

---

</br>

## < Simple Tree 생성 및 노드 구성 >
- `CL_GUI_SIMPLE_TREE` : 화면에 폴더처럼 생긴 메뉴 트리를 만들고, 클릭한 항목으로 동작을 나누는 UI 컨트롤
- `CLASS … DEFINITION DEFERRED` : 클래스 구현이 뒤에 나오니까, 지금은 “이런 클래스가 있다”만 미리 알려주는 선언
- `CALL METHOD go_tree->add_nodes` : 만들어둔 노드 테이블(MTREESNODE)을 Tree 화면에 실제로 그려주는 메서드
- `go_tree->set_registered_events` : Tree가 어떤 이벤트(예: 더블클릭)를 사용할지 미리 등록해주는 설정 메서드
```abap
*************** Tree 관련 데이터 선언 ****************
DATA: <go_tree>       TYPE REF TO cl_gui_simple_tree,   " Tree 컨트롤 객체
      <go_tree_event> TYPE REF TO <lcl_tree_event>,     " Tree 이벤트 객체
      <gs_node>       TYPE mtreesnode,                  " 노드 1건
      <gt_node>       TYPE TABLE OF mtreesnode,         " 노드 전체 테이블
      <lt_events>     TYPE cntl_simple_events,          " 등록 이벤트 목록
      <ls_event>      TYPE cntl_simple_event.           " 이벤트 1건

*************** Tree 생성 ****************
CREATE OBJECT <go_tree>
  EXPORTING
    parent              = <부모컨테이너>
    node_selection_mode = cl_gui_simple_tree=>node_sel_mode_single.

*************** Tree 노드 구성 ****************
CLEAR <gs_node>.
<gs_node>-node_key  = <노드키>.        " 이 노드를 구분하는 고유 ID (겹치면 안 됨)
<gs_node>-relatkey  = <부모노드키>.    " 이 노드가 속한 부모 노드의 KEY
<gs_node>-isfolder  = 'X'.             " 폴더 노드 여부 (X: 펼칠 수 있음 / 공백: 말단 노드)
<gs_node>-text      = <노드텍스트>.    " 트리 화면에 실제로 보여줄 글자
<gs_node>-n_image   = <기본아이콘>.    " 노드가 접혀 있을 때 아이콘
<gs_node>-exp_image = <확장아이콘>.    " 노드를 펼쳤을 때 아이콘
APPEND <gs_node> TO <gt_node>.

*************** Tree 노드 반영 ****************
* 노드 테이블을 Tree에 추가
CALL METHOD <go_tree>->add_nodes
  EXPORTING
    table_structure_name = 'MTREESNODE'
    node_table           = <gt_node>.

*************** Tree 이벤트 핸들러 클래스 ****************
* 노드 더블클릭 이벤트 처리
CLASS <lcl_tree_event> DEFINITION.
  PUBLIC SECTION.
    METHODS <on_node_double_click>
      FOR EVENT node_double_click OF cl_gui_simple_tree
      IMPORTING node_key.  " 클릭된 노드 키
ENDCLASS.

CLASS <lcl_tree_event> IMPLEMENTATION.
  METHOD <on_node_double_click>.
    " node_key 기준 처리 로직
  ENDMETHOD.
ENDCLASS.

*************** Tree 이벤트 등록 ****************
CREATE OBJECT <go_tree_event>.
SET HANDLER <go_tree_event>-><on_node_double_click> FOR <go_tree>.

<ls_event>-eventid    = cl_gui_simple_tree=>eventid_node_double_click. " 더블클릭 이벤트
<ls_event>-appl_event = 'X'.  " 화면 PAI 먼저 실행
APPEND <ls_event> TO <lt_events>.

CALL METHOD <go_tree>->set_registered_events
  EXPORTING
    events = <lt_events>.
```
```abap
REPORT zprogb03_0040.

*************** Tree 관련 데이터 선언 ****************
DATA: go_tree       TYPE REF TO cl_gui_simple_tree,   " 트리 컨트롤 객체
      gs_node       TYPE mtreesnode,                  " 트리 노드 1건
      gt_node       TYPE TABLE OF mtreesnode.         " 트리 노드 전체 목록
CLASS: lcl_node_event_handler DEFINITION DEFERRED.
DATA: go_node_event TYPE REF TO lcl_node_event_handler. " 트리 이벤트 핸들러 객체

*************** Tree 이벤트 핸들러 클래스 ****************
CLASS lcl_node_event_handler DEFINITION.
  PUBLIC SECTION.
    METHODS:
      double_click
        FOR EVENT node_double_click OF cl_gui_simple_tree
        IMPORTING node_key.   " 더블클릭한 노드 KEY
ENDCLASS.

CLASS lcl_node_event_handler IMPLEMENTATION.
  METHOD double_click.
    MESSAGE node_key TYPE 'E' DISPLAY LIKE 'S'.  " 클릭된 노드 KEY 표시
  ENDMETHOD.
ENDCLASS.

*************** Tree 생성 MODULE ****************
MODULE init_tree OUTPUT.
  IF go_tree IS INITIAL.
    CREATE OBJECT go_tree
      EXPORTING
        parent              = go_cont_r
        node_selection_mode = cl_gui_simple_tree=>node_sel_mode_single.
    IF sy-subrc = 0.
      PERFORM add_node.
      PERFORM set_node_events.
    ENDIF.
  ENDIF.
ENDMODULE.

*************** Tree 노드 구성 FORM ****************
FORM add_node .
  CLEAR gs_node.
  gs_node-node_key  = 'ROOT'.        " 루트 노드
  gs_node-relatkey  = ' '.           " 최상위
  gs_node-isfolder  = 'X'.           " 폴더 노드
  gs_node-text      = 'TREE Header'. " 헤더 텍스트
  gs_node-n_image   = '@5C@'.        " 접힘 아이콘
  gs_node-exp_image = '@5B@'.        " 펼침 아이콘
  APPEND gs_node TO gt_node.

  CLEAR gs_node.
  gs_node-node_key  = 'LV11'.
  gs_node-relatkey  = 'ROOT'.        " ROOT의 자식
  gs_node-isfolder  = 'X'.
  gs_node-text      = '자식노드'.
  gs_node-n_image   = '@5C@'.
  gs_node-exp_image = '@5B@'.
  APPEND gs_node TO gt_node.

  CLEAR gs_node.
  gs_node-node_key  = 'LV21'.
  gs_node-relatkey  = 'ROOT'.        " ROOT의 형제 레벨
  gs_node-isfolder  = 'X'.
  gs_node-text      = '형제노드'.
  gs_node-n_image   = '@5C@'.
  gs_node-exp_image = '@5B@'.
  APPEND gs_node TO gt_node.

  CLEAR gs_node.
  gs_node-node_key  = 'LV12'.
  gs_node-relatkey  = 'LV11'.        " LV11의 자식
  gs_node-isfolder  = 'X'.
  gs_node-text      = '자식의 자식 노드'.
  gs_node-n_image   = '@BU@'.
  gs_node-exp_image = '@GZ@'.
  APPEND gs_node TO gt_node.

  CLEAR gs_node.
  gs_node-node_key  = 'LV13'.
  gs_node-relatkey  = 'LV12'.        " LV12의 자식
  gs_node-isfolder  = 'X'.
  gs_node-text      = '자식의 자식의 자식 노드'.
  gs_node-n_image   = '@BU@'.
  gs_node-exp_image = '@GZ@'.
  APPEND gs_node TO gt_node.

  CLEAR gs_node.
  gs_node-node_key  = 'LV22'.
  gs_node-relatkey  = 'LV21'.        " LV21의 자식
  gs_node-isfolder  = 'X'.
  gs_node-text      = '형제의 자식 노드'.
  gs_node-n_image   = '@BU@'.
  gs_node-exp_image = '@GZ@'.
  APPEND gs_node TO gt_node.

  CALL METHOD go_tree->add_nodes
    EXPORTING
      table_structure_name = 'MTREESNODE'
      node_table           = gt_node.
ENDFORM.

*************** Tree 이벤트 등록 FORM ****************
FORM set_node_events .
  DATA: lt_events TYPE cntl_simple_events,
        ls_event  TYPE cntl_simple_event.

  CREATE OBJECT go_node_event.
  SET HANDLER go_node_event->double_click FOR go_tree.

  " tree 객체에도 실행할 이벤트가 어떤건지 알려줘야 함
  ls_event-eventid = cl_gui_simple_tree=>eventid_node_double_click.
  ls_event-appl_event = 'X'. " Tree가 속한 화면(100번)의 PAI를 먼저 실행
  APPEND ls_event TO lt_events.

  CALL METHOD go_tree->set_registered_events
    EXPORTING
      events = lt_events.
ENDFORM.
```
</br>

- 아이콘 코드 찾기 (`SE28`)
- `SE38` 에서 **RSTXICON** 입력 후 실행
<img width="432" height="263" alt="image" src="https://github.com/user-attachments/assets/3f4c7d08-c642-4874-8557-06e79f018542" />



