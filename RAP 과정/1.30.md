## < FIELD-SYMBOLS & ASSIGN >
- 변수 값을 복사하지 않고, 메모리를 직접 가리켜서 공유·수정하는 방식
- 한쪽 변경 시 원본도 즉시 변경
- `FIELD-SYMBOL` → 변수 값을 복사 ❌, 메모리 주소를 직접 참조 ⭕
- `ASSIGN` → 특정 변수/테이블 라인을 필드심볼에 연결
```abap
FIELD-SYMBOLS <fs>.                      " TYPE ANY와 동일 → 어떤 타입이든 참조 가능 (제네릭)
FIELD-SYMBOLS:
  <fs_all>    TYPE ANY,                  " 모든 타입 참조 가능 (구조/단순/테이블 라인 등)
  <fs_data>   TYPE SIMPLE,               " 문자·숫자 등 단순 타입만 참조 가능 (WRITE/계산용)
  <fs_flight> TYPE SFLIGHT,              " SFLIGHT 구조 전용 → 필드 접근 가능 (<fs_flight>-carrid)
  <fs_tab>    TYPE ANY TABLE.            " 내부 테이블 전용 참조 → 테이블 자체를 가리킴
```
```abap
*************** LOOP ASSIGNING 방식 ****************
CLASS-METHODS <write_any_table>
  IMPORTING
    <ig_info> TYPE SIMPLE
    <it_data> TYPE ANY TABLE.

METHOD <write_any_table>.
  FIELD-SYMBOLS <ls_line> TYPE ANY.

  LOOP AT <it_data> ASSIGNING <ls_line>.
    ...
  ENDLOOP.

  WRITE / <ig_info>.
ENDMETHOD.


*************** DIRECT ASSIGN 방식 ****************
DATA: <gt_scarr>      TYPE TABLE OF <scarr>,
      <gt_sbook>      TYPE TABLE OF <sbook>,
      <gv_table_name> TYPE string.

FIELD-SYMBOLS <fs_tab> TYPE ANY TABLE.

CASE <gv_table_name>.
  WHEN 'SCARR'.
    ASSIGN <gt_scarr> TO <fs_tab>.
  WHEN 'SBOOK'.
    ASSIGN <gt_sbook> TO <fs_tab>.
ENDCASE.

IF <fs_tab> IS ASSIGNED.
  SELECT * FROM (<gv_table_name>)
    UP TO 100 ROWS
    INTO TABLE <fs_tab>.
ENDIF.
```
